
Wireless Communication.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000298  00800200  00002386  0000241a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002386  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000782  00800498  00800498  000026b2  2**0
                  ALLOC
  3 .stab         000033fc  00000000  00000000  000026b4  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000009aa  00000000  00000000  00005ab0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000c0  00000000  00000000  00006460  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002241  00000000  00000000  00006520  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000456  00000000  00000000  00008761  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000b2d  00000000  00000000  00008bb7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000006c8  00000000  00000000  000096e4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000061c  00000000  00000000  00009dac  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001c83  00000000  00000000  0000a3c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000078  00000000  00000000  0000c04b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 b3 00 	jmp	0x166	; 0x166 <__ctors_end>
       4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
       8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
       c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      10:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      14:	0c 94 2b 06 	jmp	0xc56	; 0xc56 <__vector_5>
      18:	0c 94 06 06 	jmp	0xc0c	; 0xc0c <__vector_6>
      1c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      20:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      24:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      28:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      2c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      30:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      34:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      38:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      3c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      40:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      44:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      48:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      4c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      50:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      54:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      58:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      5c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      60:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      64:	0c 94 08 05 	jmp	0xa10	; 0xa10 <__vector_25>
      68:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      6c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      70:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      74:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      78:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      7c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      80:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      84:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      88:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      8c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      90:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      94:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      98:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      9c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      ac:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      bc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      cc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      dc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      e0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	lds	r29, 0x78
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	sts	0xb8, r17
      f2:	ba ab       	sts	0x5a, r27
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	sts	0x9b, r26
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	sts	0x5e, r27
     126:	aa aa       	sts	0x9a, r26
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	sts	0x41, r30
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <shortest_path+0x396>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	14 e0       	ldi	r17, 0x04	; 4
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	e6 e8       	ldi	r30, 0x86	; 134
     17e:	f3 e2       	ldi	r31, 0x23	; 35
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	a8 39       	cpi	r26, 0x98	; 152
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	1c e0       	ldi	r17, 0x0C	; 12
     192:	a8 e9       	ldi	r26, 0x98	; 152
     194:	b4 e0       	ldi	r27, 0x04	; 4
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	aa 31       	cpi	r26, 0x1A	; 26
     19c:	b1 07       	cpc	r27, r17
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	0e 94 63 0a 	call	0x14c6	; 0x14c6 <main>
     1a4:	0c 94 c1 11 	jmp	0x2382	; 0x2382 <_exit>

000001a8 <__bad_interrupt>:
     1a8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001ac <lcd_set_4bit>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     1ac:	86 e6       	ldi	r24, 0x66	; 102
     1ae:	9e e0       	ldi	r25, 0x0E	; 14
     1b0:	01 97       	sbiw	r24, 0x01	; 1
     1b2:	f1 f7       	brne	.-4      	; 0x1b0 <lcd_set_4bit+0x4>
     1b4:	00 00       	nop
//Function to Reset LCD
void lcd_set_4bit()
{
	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     1b6:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     1b8:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     1ba:	80 e3       	ldi	r24, 0x30	; 48
     1bc:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     1be:	42 9a       	sbi	0x08, 2	; 8
     1c0:	ef ef       	ldi	r30, 0xFF	; 255
     1c2:	f7 e4       	ldi	r31, 0x47	; 71
     1c4:	31 97       	sbiw	r30, 0x01	; 1
     1c6:	f1 f7       	brne	.-4      	; 0x1c4 <lcd_set_4bit+0x18>
     1c8:	00 c0       	rjmp	.+0      	; 0x1ca <lcd_set_4bit+0x1e>
     1ca:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     1cc:	42 98       	cbi	0x08, 2	; 8
     1ce:	e6 e6       	ldi	r30, 0x66	; 102
     1d0:	fe e0       	ldi	r31, 0x0E	; 14
     1d2:	31 97       	sbiw	r30, 0x01	; 1
     1d4:	f1 f7       	brne	.-4      	; 0x1d2 <lcd_set_4bit+0x26>
     1d6:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     1d8:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     1da:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     1dc:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     1de:	42 9a       	sbi	0x08, 2	; 8
     1e0:	ef ef       	ldi	r30, 0xFF	; 255
     1e2:	f7 e4       	ldi	r31, 0x47	; 71
     1e4:	31 97       	sbiw	r30, 0x01	; 1
     1e6:	f1 f7       	brne	.-4      	; 0x1e4 <lcd_set_4bit+0x38>
     1e8:	00 c0       	rjmp	.+0      	; 0x1ea <lcd_set_4bit+0x3e>
     1ea:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     1ec:	42 98       	cbi	0x08, 2	; 8
     1ee:	e6 e6       	ldi	r30, 0x66	; 102
     1f0:	fe e0       	ldi	r31, 0x0E	; 14
     1f2:	31 97       	sbiw	r30, 0x01	; 1
     1f4:	f1 f7       	brne	.-4      	; 0x1f2 <lcd_set_4bit+0x46>
     1f6:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     1f8:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     1fa:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     1fc:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     1fe:	42 9a       	sbi	0x08, 2	; 8
     200:	8f ef       	ldi	r24, 0xFF	; 255
     202:	97 e4       	ldi	r25, 0x47	; 71
     204:	01 97       	sbiw	r24, 0x01	; 1
     206:	f1 f7       	brne	.-4      	; 0x204 <lcd_set_4bit+0x58>
     208:	00 c0       	rjmp	.+0      	; 0x20a <lcd_set_4bit+0x5e>
     20a:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     20c:	42 98       	cbi	0x08, 2	; 8
     20e:	e6 e6       	ldi	r30, 0x66	; 102
     210:	fe e0       	ldi	r31, 0x0E	; 14
     212:	31 97       	sbiw	r30, 0x01	; 1
     214:	f1 f7       	brne	.-4      	; 0x212 <lcd_set_4bit+0x66>
     216:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     218:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     21a:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x20;				//Sending 2 to initialise LCD 4-bit mode
     21c:	80 e2       	ldi	r24, 0x20	; 32
     21e:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     220:	42 9a       	sbi	0x08, 2	; 8
     222:	8f ef       	ldi	r24, 0xFF	; 255
     224:	97 e4       	ldi	r25, 0x47	; 71
     226:	01 97       	sbiw	r24, 0x01	; 1
     228:	f1 f7       	brne	.-4      	; 0x226 <lcd_set_4bit+0x7a>
     22a:	00 c0       	rjmp	.+0      	; 0x22c <lcd_set_4bit+0x80>
     22c:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     22e:	42 98       	cbi	0x08, 2	; 8

	
}
     230:	08 95       	ret

00000232 <lcd_wr_command>:
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
	lcd_port &= 0x0F;
     232:	98 b1       	in	r25, 0x08	; 8
     234:	9f 70       	andi	r25, 0x0F	; 15
     236:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     238:	98 b1       	in	r25, 0x08	; 8
//Function to Write Command on LCD
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
     23a:	28 2f       	mov	r18, r24
     23c:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     23e:	92 2b       	or	r25, r18
     240:	98 b9       	out	0x08, r25	; 8
	cbit(lcd_port,RS);
     242:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     244:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     246:	42 9a       	sbi	0x08, 2	; 8
     248:	ef ef       	ldi	r30, 0xFF	; 255
     24a:	f7 e4       	ldi	r31, 0x47	; 71
     24c:	31 97       	sbiw	r30, 0x01	; 1
     24e:	f1 f7       	brne	.-4      	; 0x24c <lcd_wr_command+0x1a>
     250:	00 c0       	rjmp	.+0      	; 0x252 <lcd_wr_command+0x20>
     252:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     254:	42 98       	cbi	0x08, 2	; 8
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
	lcd_port &= 0x0F;
     256:	98 b1       	in	r25, 0x08	; 8
     258:	9f 70       	andi	r25, 0x0F	; 15
     25a:	98 b9       	out	0x08, r25	; 8
	lcd_port |= cmd;
     25c:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
     25e:	82 95       	swap	r24
     260:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= cmd;
     262:	89 2b       	or	r24, r25
     264:	88 b9       	out	0x08, r24	; 8
	cbit(lcd_port,RS);
     266:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     268:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     26a:	42 9a       	sbi	0x08, 2	; 8
     26c:	8f ef       	ldi	r24, 0xFF	; 255
     26e:	97 e4       	ldi	r25, 0x47	; 71
     270:	01 97       	sbiw	r24, 0x01	; 1
     272:	f1 f7       	brne	.-4      	; 0x270 <lcd_wr_command+0x3e>
     274:	00 c0       	rjmp	.+0      	; 0x276 <lcd_wr_command+0x44>
     276:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     278:	42 98       	cbi	0x08, 2	; 8
}
     27a:	08 95       	ret

0000027c <lcd_init>:
}

//Function to Initialize LCD
void lcd_init()
{
	lcd_set_4bit();
     27c:	0e 94 d6 00 	call	0x1ac	; 0x1ac <lcd_set_4bit>
     280:	86 e6       	ldi	r24, 0x66	; 102
     282:	9e e0       	ldi	r25, 0x0E	; 14
     284:	01 97       	sbiw	r24, 0x01	; 1
     286:	f1 f7       	brne	.-4      	; 0x284 <lcd_init+0x8>
     288:	00 00       	nop
	_delay_ms(1);

	lcd_wr_command(0x28);			//LCD 4-bit mode and 2 lines.
     28a:	88 e2       	ldi	r24, 0x28	; 40
     28c:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
	lcd_wr_command(0x01);
     290:	81 e0       	ldi	r24, 0x01	; 1
     292:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
	lcd_wr_command(0x06);
     296:	86 e0       	ldi	r24, 0x06	; 6
     298:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
	lcd_wr_command(0x0E);
     29c:	8e e0       	ldi	r24, 0x0E	; 14
     29e:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
	lcd_wr_command(0x80);
     2a2:	80 e8       	ldi	r24, 0x80	; 128
     2a4:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
		
}
     2a8:	08 95       	ret

000002aa <lcd_wr_char>:
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
	lcd_port &= 0x0F;
     2aa:	98 b1       	in	r25, 0x08	; 8
     2ac:	9f 70       	andi	r25, 0x0F	; 15
     2ae:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     2b0:	98 b1       	in	r25, 0x08	; 8
//Function to Write Data on LCD
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
     2b2:	28 2f       	mov	r18, r24
     2b4:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     2b6:	92 2b       	or	r25, r18
     2b8:	98 b9       	out	0x08, r25	; 8
	sbit(lcd_port,RS);
     2ba:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     2bc:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     2be:	42 9a       	sbi	0x08, 2	; 8
     2c0:	ef ef       	ldi	r30, 0xFF	; 255
     2c2:	f7 e4       	ldi	r31, 0x47	; 71
     2c4:	31 97       	sbiw	r30, 0x01	; 1
     2c6:	f1 f7       	brne	.-4      	; 0x2c4 <lcd_wr_char+0x1a>
     2c8:	00 c0       	rjmp	.+0      	; 0x2ca <lcd_wr_char+0x20>
     2ca:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     2cc:	42 98       	cbi	0x08, 2	; 8

	letter = letter & 0x0F;
	letter = letter<<4;
	lcd_port &= 0x0F;
     2ce:	98 b1       	in	r25, 0x08	; 8
     2d0:	9f 70       	andi	r25, 0x0F	; 15
     2d2:	98 b9       	out	0x08, r25	; 8
	lcd_port |= letter;
     2d4:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);

	letter = letter & 0x0F;
	letter = letter<<4;
     2d6:	82 95       	swap	r24
     2d8:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= letter;
     2da:	89 2b       	or	r24, r25
     2dc:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,RS);
     2de:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     2e0:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     2e2:	42 9a       	sbi	0x08, 2	; 8
     2e4:	8f ef       	ldi	r24, 0xFF	; 255
     2e6:	97 e4       	ldi	r25, 0x47	; 71
     2e8:	01 97       	sbiw	r24, 0x01	; 1
     2ea:	f1 f7       	brne	.-4      	; 0x2e8 <lcd_wr_char+0x3e>
     2ec:	00 c0       	rjmp	.+0      	; 0x2ee <lcd_wr_char+0x44>
     2ee:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     2f0:	42 98       	cbi	0x08, 2	; 8
}
     2f2:	08 95       	ret

000002f4 <lcd_home>:


//Function to bring cursor at home position
void lcd_home()
{
	lcd_wr_command(0x80);
     2f4:	80 e8       	ldi	r24, 0x80	; 128
     2f6:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
}
     2fa:	08 95       	ret

000002fc <lcd_string>:


//Function to Print String on LCD
void lcd_string(char *str)
{
     2fc:	cf 93       	push	r28
     2fe:	df 93       	push	r29
     300:	ec 01       	movw	r28, r24
	while(*str != '\0')
     302:	88 81       	ld	r24, Y
     304:	88 23       	and	r24, r24
     306:	31 f0       	breq	.+12     	; 0x314 <lcd_string+0x18>
	lcd_wr_command(0x80);
}


//Function to Print String on LCD
void lcd_string(char *str)
     308:	21 96       	adiw	r28, 0x01	; 1
{
	while(*str != '\0')
	{
		lcd_wr_char(*str);
     30a:	0e 94 55 01 	call	0x2aa	; 0x2aa <lcd_wr_char>


//Function to Print String on LCD
void lcd_string(char *str)
{
	while(*str != '\0')
     30e:	89 91       	ld	r24, Y+
     310:	88 23       	and	r24, r24
     312:	d9 f7       	brne	.-10     	; 0x30a <lcd_string+0xe>
	{
		lcd_wr_char(*str);
		str++;
	}
}
     314:	df 91       	pop	r29
     316:	cf 91       	pop	r28
     318:	08 95       	ret

0000031a <lcd_cursor>:

//Position the LCD cursor at "row", "column".

void lcd_cursor (char row, char column)
{
	switch (row) {
     31a:	82 30       	cpi	r24, 0x02	; 2
     31c:	79 f0       	breq	.+30     	; 0x33c <lcd_cursor+0x22>
     31e:	83 30       	cpi	r24, 0x03	; 3
     320:	18 f4       	brcc	.+6      	; 0x328 <lcd_cursor+0xe>
     322:	81 30       	cpi	r24, 0x01	; 1
     324:	c9 f4       	brne	.+50     	; 0x358 <lcd_cursor+0x3e>
     326:	05 c0       	rjmp	.+10     	; 0x332 <lcd_cursor+0x18>
     328:	83 30       	cpi	r24, 0x03	; 3
     32a:	69 f0       	breq	.+26     	; 0x346 <lcd_cursor+0x2c>
     32c:	84 30       	cpi	r24, 0x04	; 4
     32e:	a1 f4       	brne	.+40     	; 0x358 <lcd_cursor+0x3e>
     330:	0f c0       	rjmp	.+30     	; 0x350 <lcd_cursor+0x36>
		case 1: lcd_wr_command (0x80 + column - 1); break;
     332:	86 2f       	mov	r24, r22
     334:	81 58       	subi	r24, 0x81	; 129
     336:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
     33a:	08 95       	ret
		case 2: lcd_wr_command (0xc0 + column - 1); break;
     33c:	86 2f       	mov	r24, r22
     33e:	81 54       	subi	r24, 0x41	; 65
     340:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
     344:	08 95       	ret
		case 3: lcd_wr_command (0x94 + column - 1); break;
     346:	86 2f       	mov	r24, r22
     348:	8d 56       	subi	r24, 0x6D	; 109
     34a:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
     34e:	08 95       	ret
		case 4: lcd_wr_command (0xd4 + column - 1); break;
     350:	86 2f       	mov	r24, r22
     352:	8d 52       	subi	r24, 0x2D	; 45
     354:	0e 94 19 01 	call	0x232	; 0x232 <lcd_wr_command>
     358:	08 95       	ret

0000035a <lcd_print>:
	}
}

//Function To Print Any input value upto the desired digit on LCD
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
     35a:	0f 93       	push	r16
     35c:	1f 93       	push	r17
     35e:	cf 93       	push	r28
     360:	df 93       	push	r29
     362:	8a 01       	movw	r16, r20
     364:	e9 01       	movw	r28, r18
	unsigned char flag=0;
	if(row==0||coloumn==0)
     366:	88 23       	and	r24, r24
     368:	11 f0       	breq	.+4      	; 0x36e <lcd_print+0x14>
     36a:	66 23       	and	r22, r22
     36c:	19 f4       	brne	.+6      	; 0x374 <lcd_print+0x1a>
	{
		lcd_home();
     36e:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <lcd_home>
     372:	02 c0       	rjmp	.+4      	; 0x378 <lcd_print+0x1e>
	}
	else
	{
		lcd_cursor(row,coloumn);
     374:	0e 94 8d 01 	call	0x31a	; 0x31a <lcd_cursor>
	}
	if(digits==5 || flag==1)
     378:	c5 30       	cpi	r28, 0x05	; 5
     37a:	d1 05       	cpc	r29, r1
     37c:	71 f4       	brne	.+28     	; 0x39a <lcd_print+0x40>
	{
		million=value/10000+48;
     37e:	c8 01       	movw	r24, r16
     380:	60 e1       	ldi	r22, 0x10	; 16
     382:	77 e2       	ldi	r23, 0x27	; 39
     384:	0e 94 9a 11 	call	0x2334	; 0x2334 <__udivmodhi4>
     388:	cb 01       	movw	r24, r22
     38a:	c0 96       	adiw	r24, 0x30	; 48
     38c:	90 93 7d 06 	sts	0x067D, r25
     390:	80 93 7c 06 	sts	0x067C, r24
		lcd_wr_char(million);
     394:	0e 94 55 01 	call	0x2aa	; 0x2aa <lcd_wr_char>
     398:	03 c0       	rjmp	.+6      	; 0x3a0 <lcd_print+0x46>
		flag=1;
	}
	if(digits==4 || flag==1)
     39a:	c4 30       	cpi	r28, 0x04	; 4
     39c:	d1 05       	cpc	r29, r1
     39e:	b9 f4       	brne	.+46     	; 0x3ce <lcd_print+0x74>
	{
		temp = value/1000;
     3a0:	c8 01       	movw	r24, r16
     3a2:	68 ee       	ldi	r22, 0xE8	; 232
     3a4:	73 e0       	ldi	r23, 0x03	; 3
     3a6:	0e 94 9a 11 	call	0x2334	; 0x2334 <__udivmodhi4>
     3aa:	cb 01       	movw	r24, r22
     3ac:	70 93 7f 06 	sts	0x067F, r23
     3b0:	60 93 7e 06 	sts	0x067E, r22
		thousand = temp%10 + 48;
     3b4:	6a e0       	ldi	r22, 0x0A	; 10
     3b6:	70 e0       	ldi	r23, 0x00	; 0
     3b8:	0e 94 9a 11 	call	0x2334	; 0x2334 <__udivmodhi4>
     3bc:	c0 96       	adiw	r24, 0x30	; 48
     3be:	90 93 15 0c 	sts	0x0C15, r25
     3c2:	80 93 14 0c 	sts	0x0C14, r24
		lcd_wr_char(thousand);
     3c6:	0e 94 55 01 	call	0x2aa	; 0x2aa <lcd_wr_char>
		flag=1;
     3ca:	81 e0       	ldi	r24, 0x01	; 1
     3cc:	01 c0       	rjmp	.+2      	; 0x3d0 <lcd_print+0x76>
}

//Function To Print Any input value upto the desired digit on LCD
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
	unsigned char flag=0;
     3ce:	80 e0       	ldi	r24, 0x00	; 0
		temp = value/1000;
		thousand = temp%10 + 48;
		lcd_wr_char(thousand);
		flag=1;
	}
	if(digits==3 || flag==1)
     3d0:	c3 30       	cpi	r28, 0x03	; 3
     3d2:	d1 05       	cpc	r29, r1
     3d4:	11 f0       	breq	.+4      	; 0x3da <lcd_print+0x80>
     3d6:	81 30       	cpi	r24, 0x01	; 1
     3d8:	b1 f4       	brne	.+44     	; 0x406 <lcd_print+0xac>
	{
		temp = value/100;
     3da:	c8 01       	movw	r24, r16
     3dc:	64 e6       	ldi	r22, 0x64	; 100
     3de:	70 e0       	ldi	r23, 0x00	; 0
     3e0:	0e 94 9a 11 	call	0x2334	; 0x2334 <__udivmodhi4>
     3e4:	cb 01       	movw	r24, r22
     3e6:	70 93 7f 06 	sts	0x067F, r23
     3ea:	60 93 7e 06 	sts	0x067E, r22
		hundred = temp%10 + 48;
     3ee:	6a e0       	ldi	r22, 0x0A	; 10
     3f0:	70 e0       	ldi	r23, 0x00	; 0
     3f2:	0e 94 9a 11 	call	0x2334	; 0x2334 <__udivmodhi4>
     3f6:	c0 96       	adiw	r24, 0x30	; 48
     3f8:	90 93 7e 0a 	sts	0x0A7E, r25
     3fc:	80 93 7d 0a 	sts	0x0A7D, r24
		lcd_wr_char(hundred);
     400:	0e 94 55 01 	call	0x2aa	; 0x2aa <lcd_wr_char>
		flag=1;
     404:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==2 || flag==1)
     406:	c2 30       	cpi	r28, 0x02	; 2
     408:	d1 05       	cpc	r29, r1
     40a:	11 f0       	breq	.+4      	; 0x410 <lcd_print+0xb6>
     40c:	81 30       	cpi	r24, 0x01	; 1
     40e:	b1 f4       	brne	.+44     	; 0x43c <lcd_print+0xe2>
	{
		temp = value/10;
     410:	2a e0       	ldi	r18, 0x0A	; 10
     412:	30 e0       	ldi	r19, 0x00	; 0
     414:	c8 01       	movw	r24, r16
     416:	b9 01       	movw	r22, r18
     418:	0e 94 9a 11 	call	0x2334	; 0x2334 <__udivmodhi4>
     41c:	cb 01       	movw	r24, r22
     41e:	70 93 7f 06 	sts	0x067F, r23
     422:	60 93 7e 06 	sts	0x067E, r22
		tens = temp%10 + 48;
     426:	b9 01       	movw	r22, r18
     428:	0e 94 9a 11 	call	0x2334	; 0x2334 <__udivmodhi4>
     42c:	c0 96       	adiw	r24, 0x30	; 48
     42e:	90 93 6a 0a 	sts	0x0A6A, r25
     432:	80 93 69 0a 	sts	0x0A69, r24
		lcd_wr_char(tens);
     436:	0e 94 55 01 	call	0x2aa	; 0x2aa <lcd_wr_char>
		flag=1;
     43a:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==1 || flag==1)
     43c:	c1 30       	cpi	r28, 0x01	; 1
     43e:	d1 05       	cpc	r29, r1
     440:	11 f0       	breq	.+4      	; 0x446 <lcd_print+0xec>
     442:	81 30       	cpi	r24, 0x01	; 1
     444:	61 f4       	brne	.+24     	; 0x45e <lcd_print+0x104>
	{
		unit = value%10 + 48;
     446:	c8 01       	movw	r24, r16
     448:	6a e0       	ldi	r22, 0x0A	; 10
     44a:	70 e0       	ldi	r23, 0x00	; 0
     44c:	0e 94 9a 11 	call	0x2334	; 0x2334 <__udivmodhi4>
     450:	c0 96       	adiw	r24, 0x30	; 48
     452:	90 93 13 0c 	sts	0x0C13, r25
     456:	80 93 12 0c 	sts	0x0C12, r24
		lcd_wr_char(unit);
     45a:	0e 94 55 01 	call	0x2aa	; 0x2aa <lcd_wr_char>
	}
	if(digits>5)
     45e:	c6 30       	cpi	r28, 0x06	; 6
     460:	d1 05       	cpc	r29, r1
     462:	1c f0       	brlt	.+6      	; 0x46a <lcd_print+0x110>
	{
		lcd_wr_char('E');
     464:	85 e4       	ldi	r24, 0x45	; 69
     466:	0e 94 55 01 	call	0x2aa	; 0x2aa <lcd_wr_char>
	}
	
}
     46a:	df 91       	pop	r29
     46c:	cf 91       	pop	r28
     46e:	1f 91       	pop	r17
     470:	0f 91       	pop	r16
     472:	08 95       	ret

00000474 <rem>:
Output :      none
Logic:       it searches for the node in arena and sets it value to 0 to make sure that the node can never be used again in path
Example Call:rem(55)
*/
void rem(int b)
{
     474:	9c 01       	movw	r18, r24
     476:	e2 e0       	ldi	r30, 0x02	; 2
     478:	f2 e0       	ldi	r31, 0x02	; 2
Input :       b(node number)
Output :      none
Logic:       it searches for the node in arena and sets it value to 0 to make sure that the node can never be used again in path
Example Call:rem(55)
*/
void rem(int b)
     47a:	4e eb       	ldi	r20, 0xBE	; 190
     47c:	54 e0       	ldi	r21, 0x04	; 4
     47e:	df 01       	movw	r26, r30
{
	int j=0;
    for(int i=0;i<175;i++)
    {
        if(dist[i][0]==b||dist[i][1]==b)
     480:	80 81       	ld	r24, Z
     482:	91 81       	ldd	r25, Z+1	; 0x01
     484:	82 17       	cp	r24, r18
     486:	93 07       	cpc	r25, r19
     488:	29 f0       	breq	.+10     	; 0x494 <rem+0x20>
     48a:	82 81       	ldd	r24, Z+2	; 0x02
     48c:	93 81       	ldd	r25, Z+3	; 0x03
     48e:	82 17       	cp	r24, r18
     490:	93 07       	cpc	r25, r19
     492:	39 f4       	brne	.+14     	; 0x4a2 <rem+0x2e>
        {
            //cout<<"\nREMOVED="<<i<<" "<<dist[i][0]<< " "<<dist[i][1];
			dist[i][0]=0;
     494:	11 96       	adiw	r26, 0x01	; 1
     496:	1c 92       	st	X, r1
     498:	1e 92       	st	-X, r1
            dist[i][1]=0;
     49a:	13 96       	adiw	r26, 0x03	; 3
     49c:	1c 92       	st	X, r1
     49e:	1e 92       	st	-X, r1
     4a0:	12 97       	sbiw	r26, 0x02	; 2
     4a2:	34 96       	adiw	r30, 0x04	; 4
Example Call:rem(55)
*/
void rem(int b)
{
	int j=0;
    for(int i=0;i<175;i++)
     4a4:	e4 17       	cp	r30, r20
     4a6:	f5 07       	cpc	r31, r21
     4a8:	51 f7       	brne	.-44     	; 0x47e <rem+0xa>
            dist[i][1]=0;
        }


    }
}
     4aa:	08 95       	ret

000004ac <rem1>:
Output :      none
Logic:       it searches for the node in arena and copies it config and sets it value to 0 to make sure that the node can never be used again in path temporarily
Example Call:rem1(55)
*/
void rem1(int b)
{
     4ac:	cf 92       	push	r12
     4ae:	df 92       	push	r13
     4b0:	ef 92       	push	r14
     4b2:	ff 92       	push	r15
     4b4:	0f 93       	push	r16
     4b6:	1f 93       	push	r17
     4b8:	cf 93       	push	r28
     4ba:	df 93       	push	r29
     4bc:	ac 01       	movw	r20, r24
	int j=0;
     4be:	e2 e0       	ldi	r30, 0x02	; 2
     4c0:	f2 e0       	ldi	r31, 0x02	; 2
Input :       b(node number)
Output :      none
Logic:       it searches for the node in arena and copies it config and sets it value to 0 to make sure that the node can never be used again in path temporarily
Example Call:rem1(55)
*/
void rem1(int b)
     4c2:	0e eb       	ldi	r16, 0xBE	; 190
     4c4:	14 e0       	ldi	r17, 0x04	; 4
{
	int j=0;
     4c6:	60 e0       	ldi	r22, 0x00	; 0
     4c8:	70 e0       	ldi	r23, 0x00	; 0
	for(int i=0;i<175;i++)
	{
		if(dist[i][0]==b||dist[i][1]==b)
		{
			//cout<<"\nREMOVED="<<i<<" "<<dist[i][0]<< " "<<dist[i][1];
			dist1[j][0]=dist[i][0];
     4ca:	0f 2e       	mov	r0, r31
     4cc:	fd e6       	ldi	r31, 0x6D	; 109
     4ce:	cf 2e       	mov	r12, r31
     4d0:	fa e0       	ldi	r31, 0x0A	; 10
     4d2:	df 2e       	mov	r13, r31
     4d4:	f0 2d       	mov	r31, r0
			dist1[j][1]=dist[i][1];
			j++;
			dist[i][0]=180;
     4d6:	0f 2e       	mov	r0, r31
     4d8:	f4 eb       	ldi	r31, 0xB4	; 180
     4da:	ef 2e       	mov	r14, r31
     4dc:	ff 24       	eor	r15, r15
     4de:	f0 2d       	mov	r31, r0
Input :       b(node number)
Output :      none
Logic:       it searches for the node in arena and copies it config and sets it value to 0 to make sure that the node can never be used again in path temporarily
Example Call:rem1(55)
*/
void rem1(int b)
     4e0:	df 01       	movw	r26, r30
	int j=0;
	//lcd_string("removed");
	//lcd_print(2,1,b,3);
	for(int i=0;i<175;i++)
	{
		if(dist[i][0]==b||dist[i][1]==b)
     4e2:	20 81       	ld	r18, Z
     4e4:	31 81       	ldd	r19, Z+1	; 0x01
     4e6:	24 17       	cp	r18, r20
     4e8:	35 07       	cpc	r19, r21
     4ea:	29 f0       	breq	.+10     	; 0x4f6 <rem1+0x4a>
     4ec:	82 81       	ldd	r24, Z+2	; 0x02
     4ee:	93 81       	ldd	r25, Z+3	; 0x03
     4f0:	84 17       	cp	r24, r20
     4f2:	95 07       	cpc	r25, r21
     4f4:	c9 f4       	brne	.+50     	; 0x528 <rem1+0x7c>
		{
			//cout<<"\nREMOVED="<<i<<" "<<dist[i][0]<< " "<<dist[i][1];
			dist1[j][0]=dist[i][0];
     4f6:	cb 01       	movw	r24, r22
     4f8:	88 0f       	add	r24, r24
     4fa:	99 1f       	adc	r25, r25
     4fc:	88 0f       	add	r24, r24
     4fe:	99 1f       	adc	r25, r25
     500:	e6 01       	movw	r28, r12
     502:	c8 0f       	add	r28, r24
     504:	d9 1f       	adc	r29, r25
     506:	39 83       	std	Y+1, r19	; 0x01
     508:	28 83       	st	Y, r18
			dist1[j][1]=dist[i][1];
     50a:	12 96       	adiw	r26, 0x02	; 2
     50c:	8d 91       	ld	r24, X+
     50e:	9c 91       	ld	r25, X
     510:	13 97       	sbiw	r26, 0x03	; 3
     512:	9b 83       	std	Y+3, r25	; 0x03
     514:	8a 83       	std	Y+2, r24	; 0x02
			j++;
     516:	6f 5f       	subi	r22, 0xFF	; 255
     518:	7f 4f       	sbci	r23, 0xFF	; 255
			dist[i][0]=180;
     51a:	11 96       	adiw	r26, 0x01	; 1
     51c:	fc 92       	st	X, r15
     51e:	ee 92       	st	-X, r14
			dist[i][1]=180;
     520:	13 96       	adiw	r26, 0x03	; 3
     522:	fc 92       	st	X, r15
     524:	ee 92       	st	-X, r14
     526:	12 97       	sbiw	r26, 0x02	; 2
     528:	34 96       	adiw	r30, 0x04	; 4
void rem1(int b)
{
	int j=0;
	//lcd_string("removed");
	//lcd_print(2,1,b,3);
	for(int i=0;i<175;i++)
     52a:	e0 17       	cp	r30, r16
     52c:	f1 07       	cpc	r31, r17
     52e:	c1 f6       	brne	.-80     	; 0x4e0 <rem1+0x34>
			j++;
			dist[i][0]=180;
			dist[i][1]=180;
		}
	}
	while(j<4)
     530:	64 30       	cpi	r22, 0x04	; 4
     532:	71 05       	cpc	r23, r1
     534:	8c f4       	brge	.+34     	; 0x558 <rem1+0xac>
Input :       b(node number)
Output :      none
Logic:       it searches for the node in arena and copies it config and sets it value to 0 to make sure that the node can never be used again in path temporarily
Example Call:rem1(55)
*/
void rem1(int b)
     536:	fb 01       	movw	r30, r22
     538:	ee 0f       	add	r30, r30
     53a:	ff 1f       	adc	r31, r31
     53c:	ee 0f       	add	r30, r30
     53e:	ff 1f       	adc	r31, r31
     540:	e3 59       	subi	r30, 0x93	; 147
     542:	f5 4f       	sbci	r31, 0xF5	; 245
     544:	8d e7       	ldi	r24, 0x7D	; 125
     546:	9a e0       	ldi	r25, 0x0A	; 10
			dist[i][1]=180;
		}
	}
	while(j<4)
	{
		dist1[j][0]=0;
     548:	11 82       	std	Z+1, r1	; 0x01
     54a:	10 82       	st	Z, r1
		dist1[j][1]=0;
     54c:	13 82       	std	Z+3, r1	; 0x03
     54e:	12 82       	std	Z+2, r1	; 0x02
     550:	34 96       	adiw	r30, 0x04	; 4
			j++;
			dist[i][0]=180;
			dist[i][1]=180;
		}
	}
	while(j<4)
     552:	e8 17       	cp	r30, r24
     554:	f9 07       	cpc	r31, r25
     556:	c1 f7       	brne	.-16     	; 0x548 <rem1+0x9c>
		dist1[j][0]=0;
		dist1[j][1]=0;
		j++;
		
	}
}
     558:	df 91       	pop	r29
     55a:	cf 91       	pop	r28
     55c:	1f 91       	pop	r17
     55e:	0f 91       	pop	r16
     560:	ff 90       	pop	r15
     562:	ef 90       	pop	r14
     564:	df 90       	pop	r13
     566:	cf 90       	pop	r12
     568:	08 95       	ret

0000056a <add>:
Output :      none
Logic:       it searches for the node in config table and copies the config in adj matrix to make sure that the node can now be used again in path
Example Call:add(55)
*/
int add(int k)
{
     56a:	cf 93       	push	r28
     56c:	df 93       	push	r29
	int j=0;
     56e:	a2 e0       	ldi	r26, 0x02	; 2
     570:	b2 e0       	ldi	r27, 0x02	; 2
Input :       k(node number)
Output :      none
Logic:       it searches for the node in config table and copies the config in adj matrix to make sure that the node can now be used again in path
Example Call:add(55)
*/
int add(int k)
     572:	2e eb       	ldi	r18, 0xBE	; 190
     574:	34 e0       	ldi	r19, 0x04	; 4
{
	int j=0;
     576:	40 e0       	ldi	r20, 0x00	; 0
     578:	50 e0       	ldi	r21, 0x00	; 0
	for(int i=0;i<175;i++)
	{
		if(dist[i][0]==180&&dist[i][1]==180)
		{
			//cout<<"\nREMOVED="<<i<<" "<<dist[i][0]<< " "<<dist[i][1];
			dist[i][0]=dist1[j][0];
     57a:	6d e6       	ldi	r22, 0x6D	; 109
     57c:	7a e0       	ldi	r23, 0x0A	; 10
Input :       k(node number)
Output :      none
Logic:       it searches for the node in config table and copies the config in adj matrix to make sure that the node can now be used again in path
Example Call:add(55)
*/
int add(int k)
     57e:	ed 01       	movw	r28, r26
{
	int j=0;
	for(int i=0;i<175;i++)
	{
		if(dist[i][0]==180&&dist[i][1]==180)
     580:	8d 91       	ld	r24, X+
     582:	9c 91       	ld	r25, X
     584:	11 97       	sbiw	r26, 0x01	; 1
     586:	84 3b       	cpi	r24, 0xB4	; 180
     588:	91 05       	cpc	r25, r1
     58a:	c1 f4       	brne	.+48     	; 0x5bc <add+0x52>
     58c:	12 96       	adiw	r26, 0x02	; 2
     58e:	8d 91       	ld	r24, X+
     590:	9c 91       	ld	r25, X
     592:	13 97       	sbiw	r26, 0x03	; 3
     594:	84 3b       	cpi	r24, 0xB4	; 180
     596:	91 05       	cpc	r25, r1
     598:	89 f4       	brne	.+34     	; 0x5bc <add+0x52>
		{
			//cout<<"\nREMOVED="<<i<<" "<<dist[i][0]<< " "<<dist[i][1];
			dist[i][0]=dist1[j][0];
     59a:	fa 01       	movw	r30, r20
     59c:	ee 0f       	add	r30, r30
     59e:	ff 1f       	adc	r31, r31
     5a0:	ee 0f       	add	r30, r30
     5a2:	ff 1f       	adc	r31, r31
     5a4:	e6 0f       	add	r30, r22
     5a6:	f7 1f       	adc	r31, r23
     5a8:	80 81       	ld	r24, Z
     5aa:	91 81       	ldd	r25, Z+1	; 0x01
     5ac:	99 83       	std	Y+1, r25	; 0x01
     5ae:	88 83       	st	Y, r24
			dist[i][1]=dist1[j][1];
     5b0:	82 81       	ldd	r24, Z+2	; 0x02
     5b2:	93 81       	ldd	r25, Z+3	; 0x03
     5b4:	9b 83       	std	Y+3, r25	; 0x03
     5b6:	8a 83       	std	Y+2, r24	; 0x02
			j++;
     5b8:	4f 5f       	subi	r20, 0xFF	; 255
     5ba:	5f 4f       	sbci	r21, 0xFF	; 255
     5bc:	14 96       	adiw	r26, 0x04	; 4
Example Call:add(55)
*/
int add(int k)
{
	int j=0;
	for(int i=0;i<175;i++)
     5be:	a2 17       	cp	r26, r18
     5c0:	b3 07       	cpc	r27, r19
     5c2:	e9 f6       	brne	.-70     	; 0x57e <add+0x14>
			dist[i][0]=dist1[j][0];
			dist[i][1]=dist1[j][1];
			j++;
		}
	}
}
     5c4:	df 91       	pop	r29
     5c6:	cf 91       	pop	r28
     5c8:	08 95       	ret

000005ca <shortest_path>:
Output :      none
Logic:       standard implementation of dijkstra algorithm
Example Call:shortest_path(55,68)
*/
void shortest_path(unsigned int s,unsigned int t)
{
     5ca:	2f 92       	push	r2
     5cc:	3f 92       	push	r3
     5ce:	4f 92       	push	r4
     5d0:	5f 92       	push	r5
     5d2:	6f 92       	push	r6
     5d4:	7f 92       	push	r7
     5d6:	8f 92       	push	r8
     5d8:	9f 92       	push	r9
     5da:	af 92       	push	r10
     5dc:	bf 92       	push	r11
     5de:	cf 92       	push	r12
     5e0:	df 92       	push	r13
     5e2:	ef 92       	push	r14
     5e4:	ff 92       	push	r15
     5e6:	0f 93       	push	r16
     5e8:	1f 93       	push	r17
     5ea:	cf 93       	push	r28
     5ec:	df 93       	push	r29
     5ee:	cd b7       	in	r28, 0x3d	; 61
     5f0:	de b7       	in	r29, 0x3e	; 62
     5f2:	28 97       	sbiw	r28, 0x08	; 8
     5f4:	0f b6       	in	r0, 0x3f	; 63
     5f6:	f8 94       	cli
     5f8:	de bf       	out	0x3e, r29	; 62
     5fa:	0f be       	out	0x3f, r0	; 63
     5fc:	cd bf       	out	0x3d, r28	; 61
     5fe:	1c 01       	movw	r2, r24
     600:	4b 01       	movw	r8, r22

   unsigned int f=0,part;
   unsigned int i,k,min;
   struct state *p;
   for(p=&state[0];p<&state[n];p++)
     602:	80 91 96 04 	lds	r24, 0x0496
     606:	90 91 97 04 	lds	r25, 0x0497
     60a:	9c 01       	movw	r18, r24
     60c:	22 0f       	add	r18, r18
     60e:	33 1f       	adc	r19, r19
     610:	22 0f       	add	r18, r18
     612:	33 1f       	adc	r19, r19
     614:	82 0f       	add	r24, r18
     616:	93 1f       	adc	r25, r19
     618:	80 58       	subi	r24, 0x80	; 128
     61a:	99 4f       	sbci	r25, 0xF9	; 249
     61c:	26 e0       	ldi	r18, 0x06	; 6
     61e:	80 38       	cpi	r24, 0x80	; 128
     620:	92 07       	cpc	r25, r18
     622:	89 f0       	breq	.+34     	; 0x646 <shortest_path+0x7c>
     624:	80 f0       	brcs	.+32     	; 0x646 <shortest_path+0x7c>
     626:	e0 e8       	ldi	r30, 0x80	; 128
     628:	f6 e0       	ldi	r31, 0x06	; 6
   {
		p->predecessor=-1;
     62a:	2f ef       	ldi	r18, 0xFF	; 255
     62c:	3f ef       	ldi	r19, 0xFF	; 255
		p->length=INFINITE;
     62e:	4f e0       	ldi	r20, 0x0F	; 15
     630:	57 e2       	ldi	r21, 0x27	; 39
		p->label=tentative;
     632:	61 e0       	ldi	r22, 0x01	; 1
   unsigned int f=0,part;
   unsigned int i,k,min;
   struct state *p;
   for(p=&state[0];p<&state[n];p++)
   {
		p->predecessor=-1;
     634:	31 83       	std	Z+1, r19	; 0x01
     636:	20 83       	st	Z, r18
		p->length=INFINITE;
     638:	53 83       	std	Z+3, r21	; 0x03
     63a:	42 83       	std	Z+2, r20	; 0x02
		p->label=tentative;
     63c:	64 83       	std	Z+4, r22	; 0x04
{

   unsigned int f=0,part;
   unsigned int i,k,min;
   struct state *p;
   for(p=&state[0];p<&state[n];p++)
     63e:	35 96       	adiw	r30, 0x05	; 5
     640:	e8 17       	cp	r30, r24
     642:	f9 07       	cpc	r31, r25
     644:	b8 f3       	brcs	.-18     	; 0x634 <shortest_path+0x6a>
   {
		p->predecessor=-1;
		p->length=INFINITE;
		p->label=tentative;
   }
   state[t].length=0;
     646:	f4 01       	movw	r30, r8
     648:	ee 0f       	add	r30, r30
     64a:	ff 1f       	adc	r31, r31
     64c:	ee 0f       	add	r30, r30
     64e:	ff 1f       	adc	r31, r31
     650:	e8 0d       	add	r30, r8
     652:	f9 1d       	adc	r31, r9
     654:	e0 58       	subi	r30, 0x80	; 128
     656:	f9 4f       	sbci	r31, 0xF9	; 249
     658:	13 82       	std	Z+3, r1	; 0x03
     65a:	12 82       	std	Z+2, r1	; 0x02
   state[t].label=permanent;
     65c:	14 82       	std	Z+4, r1	; 0x04
   k=t;

   do
   {
	   //lcd_string("do started");
		for(i=0;i<n;i++)
     65e:	c0 90 96 04 	lds	r12, 0x0496
     662:	d0 90 97 04 	lds	r13, 0x0497
		p->length=INFINITE;
		p->label=tentative;
   }
   state[t].length=0;
   state[t].label=permanent;
   k=t;
     666:	a4 01       	movw	r20, r8

   do
   {
	   //lcd_string("do started");
		for(i=0;i<n;i++)
     668:	66 24       	eor	r6, r6
     66a:	77 24       	eor	r7, r7
     66c:	0f 2e       	mov	r0, r31
     66e:	f4 e8       	ldi	r31, 0x84	; 132
     670:	4f 2e       	mov	r4, r31
     672:	f6 e0       	ldi	r31, 0x06	; 6
     674:	5f 2e       	mov	r5, r31
     676:	f0 2d       	mov	r31, r0
     678:	c2 01       	movw	r24, r4
     67a:	04 97       	sbiw	r24, 0x04	; 4
     67c:	9c 83       	std	Y+4, r25	; 0x04
     67e:	8b 83       	std	Y+3, r24	; 0x03
     680:	4d 82       	std	Y+5, r4	; 0x05
     682:	5e 82       	std	Y+6, r5	; 0x06
Input :       s(source),d(destination)
Output :      none
Logic:       standard implementation of dijkstra algorithm
Example Call:shortest_path(55,68)
*/
void shortest_path(unsigned int s,unsigned int t)
     684:	6e e8       	ldi	r22, 0x8E	; 142
     686:	74 e0       	ldi	r23, 0x04	; 4
   k=t;

   do
   {
	   //lcd_string("do started");
		for(i=0;i<n;i++)
     688:	0f 2e       	mov	r0, r31
     68a:	f2 e0       	ldi	r31, 0x02	; 2
     68c:	af 2e       	mov	r10, r31
     68e:	f2 e0       	ldi	r31, 0x02	; 2
     690:	bf 2e       	mov	r11, r31
     692:	f0 2d       	mov	r31, r0
     694:	c1 14       	cp	r12, r1
     696:	d1 04       	cpc	r13, r1
     698:	09 f4       	brne	.+2      	; 0x69c <shortest_path+0xd2>
     69a:	6e c0       	rjmp	.+220    	; 0x778 <shortest_path+0x1ae>
     69c:	f2 01       	movw	r30, r4
     69e:	eb 80       	ldd	r14, Y+3	; 0x03
     6a0:	fc 80       	ldd	r15, Y+4	; 0x04
     6a2:	0d 81       	ldd	r16, Y+5	; 0x05
     6a4:	1e 81       	ldd	r17, Y+6	; 0x06
     6a6:	d3 01       	movw	r26, r6
			}
			//lcd_string("break");

			 if(f==1 && state[i].label==tentative)
			{
				if(state[k].length+1<state[i].length)
     6a8:	ca 01       	movw	r24, r20
     6aa:	88 0f       	add	r24, r24
     6ac:	99 1f       	adc	r25, r25
     6ae:	88 0f       	add	r24, r24
     6b0:	99 1f       	adc	r25, r25
     6b2:	84 0f       	add	r24, r20
     6b4:	95 1f       	adc	r25, r21
     6b6:	80 58       	subi	r24, 0x80	; 128
     6b8:	99 4f       	sbci	r25, 0xF9	; 249
     6ba:	9c 01       	movw	r18, r24
     6bc:	2e 5f       	subi	r18, 0xFE	; 254
     6be:	3f 4f       	sbci	r19, 0xFF	; 255
     6c0:	3a 83       	std	Y+2, r19	; 0x02
     6c2:	29 83       	std	Y+1, r18	; 0x01
     6c4:	18 87       	std	Y+8, r17	; 0x08
     6c6:	0f 83       	std	Y+7, r16	; 0x07
     6c8:	87 01       	movw	r16, r14
     6ca:	7f 01       	movw	r14, r30
     6cc:	38 c0       	rjmp	.+112    	; 0x73e <shortest_path+0x174>
		{
			f=0;
			for(part=0;part<163;part++)
			{

				if((dist[part][0]==k)&&(dist[part][1]==i))
     6ce:	80 81       	ld	r24, Z
     6d0:	91 81       	ldd	r25, Z+1	; 0x01
     6d2:	84 17       	cp	r24, r20
     6d4:	95 07       	cpc	r25, r21
     6d6:	29 f4       	brne	.+10     	; 0x6e2 <shortest_path+0x118>
     6d8:	82 81       	ldd	r24, Z+2	; 0x02
     6da:	93 81       	ldd	r25, Z+3	; 0x03
     6dc:	8a 17       	cp	r24, r26
     6de:	9b 07       	cpc	r25, r27
     6e0:	39 f0       	breq	.+14     	; 0x6f0 <shortest_path+0x126>
     6e2:	34 96       	adiw	r30, 0x04	; 4
   {
	   //lcd_string("do started");
		for(i=0;i<n;i++)
		{
			f=0;
			for(part=0;part<163;part++)
     6e4:	e6 17       	cp	r30, r22
     6e6:	f7 07       	cpc	r31, r23
     6e8:	91 f7       	brne	.-28     	; 0x6ce <shortest_path+0x104>
     6ea:	38 87       	std	Y+8, r19	; 0x08
     6ec:	2f 83       	std	Y+7, r18	; 0x07
     6ee:	1b c0       	rjmp	.+54     	; 0x726 <shortest_path+0x15c>
     6f0:	38 87       	std	Y+8, r19	; 0x08
     6f2:	2f 83       	std	Y+7, r18	; 0x07

				}
			}
			//lcd_string("break");

			 if(f==1 && state[i].label==tentative)
     6f4:	f9 01       	movw	r30, r18
     6f6:	80 81       	ld	r24, Z
     6f8:	81 30       	cpi	r24, 0x01	; 1
     6fa:	a9 f4       	brne	.+42     	; 0x726 <shortest_path+0x15c>
			{
				if(state[k].length+1<state[i].length)
     6fc:	e9 81       	ldd	r30, Y+1	; 0x01
     6fe:	fa 81       	ldd	r31, Y+2	; 0x02
     700:	80 81       	ld	r24, Z
     702:	91 81       	ldd	r25, Z+1	; 0x01
     704:	01 96       	adiw	r24, 0x01	; 1
     706:	f8 01       	movw	r30, r16
     708:	22 81       	ldd	r18, Z+2	; 0x02
     70a:	33 81       	ldd	r19, Z+3	; 0x03
     70c:	82 17       	cp	r24, r18
     70e:	93 07       	cpc	r25, r19
     710:	50 f4       	brcc	.+20     	; 0x726 <shortest_path+0x15c>
				{
					state[i].predecessor=k;
     712:	51 83       	std	Z+1, r21	; 0x01
     714:	40 83       	st	Z, r20
					state[i].length=state[k].length+1;
     716:	e9 81       	ldd	r30, Y+1	; 0x01
     718:	fa 81       	ldd	r31, Y+2	; 0x02
     71a:	80 81       	ld	r24, Z
     71c:	91 81       	ldd	r25, Z+1	; 0x01
     71e:	01 96       	adiw	r24, 0x01	; 1
     720:	f8 01       	movw	r30, r16
     722:	93 83       	std	Z+3, r25	; 0x03
     724:	82 83       	std	Z+2, r24	; 0x02
   k=t;

   do
   {
	   //lcd_string("do started");
		for(i=0;i<n;i++)
     726:	11 96       	adiw	r26, 0x01	; 1
     728:	2f 81       	ldd	r18, Y+7	; 0x07
     72a:	38 85       	ldd	r19, Y+8	; 0x08
     72c:	2b 5f       	subi	r18, 0xFB	; 251
     72e:	3f 4f       	sbci	r19, 0xFF	; 255
     730:	38 87       	std	Y+8, r19	; 0x08
     732:	2f 83       	std	Y+7, r18	; 0x07
     734:	0b 5f       	subi	r16, 0xFB	; 251
     736:	1f 4f       	sbci	r17, 0xFF	; 255
     738:	ac 15       	cp	r26, r12
     73a:	bd 05       	cpc	r27, r13
     73c:	20 f4       	brcc	.+8      	; 0x746 <shortest_path+0x17c>
     73e:	f5 01       	movw	r30, r10
     740:	2f 81       	ldd	r18, Y+7	; 0x07
     742:	38 85       	ldd	r19, Y+8	; 0x08
     744:	c4 cf       	rjmp	.-120    	; 0x6ce <shortest_path+0x104>
     746:	af e0       	ldi	r26, 0x0F	; 15
     748:	b7 e2       	ldi	r27, 0x27	; 39
     74a:	a3 01       	movw	r20, r6
     74c:	93 01       	movw	r18, r6
     74e:	87 01       	movw	r16, r14
		}
		//lcd_string("to");
		k=0;min=INFINITE;
		for(i=0;i<n;i++)
		{
			if(state[i].label==tentative && state[i].length<min)
     750:	f8 01       	movw	r30, r16
     752:	80 81       	ld	r24, Z
     754:	81 30       	cpi	r24, 0x01	; 1
     756:	41 f4       	brne	.+16     	; 0x768 <shortest_path+0x19e>
Input :       s(source),d(destination)
Output :      none
Logic:       standard implementation of dijkstra algorithm
Example Call:shortest_path(55,68)
*/
void shortest_path(unsigned int s,unsigned int t)
     758:	32 97       	sbiw	r30, 0x02	; 2
		}
		//lcd_string("to");
		k=0;min=INFINITE;
		for(i=0;i<n;i++)
		{
			if(state[i].label==tentative && state[i].length<min)
     75a:	80 81       	ld	r24, Z
     75c:	91 81       	ldd	r25, Z+1	; 0x01
     75e:	8a 17       	cp	r24, r26
     760:	9b 07       	cpc	r25, r27
     762:	10 f4       	brcc	.+4      	; 0x768 <shortest_path+0x19e>
			{
				min=state[i].length;
     764:	dc 01       	movw	r26, r24
		}
		//lcd_string("to");
		k=0;min=INFINITE;
		for(i=0;i<n;i++)
		{
			if(state[i].label==tentative && state[i].length<min)
     766:	a9 01       	movw	r20, r18
				}
		    }
		}
		//lcd_string("to");
		k=0;min=INFINITE;
		for(i=0;i<n;i++)
     768:	2f 5f       	subi	r18, 0xFF	; 255
     76a:	3f 4f       	sbci	r19, 0xFF	; 255
     76c:	0b 5f       	subi	r16, 0xFB	; 251
     76e:	1f 4f       	sbci	r17, 0xFF	; 255
     770:	2c 15       	cp	r18, r12
     772:	3d 05       	cpc	r19, r13
     774:	69 f7       	brne	.-38     	; 0x750 <shortest_path+0x186>
     776:	01 c0       	rjmp	.+2      	; 0x77a <shortest_path+0x1b0>
   k=t;

   do
   {
	   //lcd_string("do started");
		for(i=0;i<n;i++)
     778:	a3 01       	movw	r20, r6
				min=state[i].length;
				k=i;
			}

		}
		state[k].label=permanent;
     77a:	ca 01       	movw	r24, r20
     77c:	88 0f       	add	r24, r24
     77e:	99 1f       	adc	r25, r25
     780:	88 0f       	add	r24, r24
     782:	99 1f       	adc	r25, r25
     784:	84 0f       	add	r24, r20
     786:	95 1f       	adc	r25, r21
     788:	80 58       	subi	r24, 0x80	; 128
     78a:	99 4f       	sbci	r25, 0xF9	; 249
     78c:	dc 01       	movw	r26, r24
     78e:	14 96       	adiw	r26, 0x04	; 4
     790:	1c 92       	st	X, r1
     792:	14 97       	sbiw	r26, 0x04	; 4
   }while(k!=s);
     794:	42 15       	cp	r20, r2
     796:	53 05       	cpc	r21, r3
     798:	09 f0       	breq	.+2      	; 0x79c <shortest_path+0x1d2>
     79a:	7c cf       	rjmp	.-264    	; 0x694 <shortest_path+0xca>
     79c:	0f 2e       	mov	r0, r31
     79e:	f8 ee       	ldi	r31, 0xE8	; 232
     7a0:	cf 2e       	mov	r12, r31
     7a2:	f4 e0       	ldi	r31, 0x04	; 4
     7a4:	df 2e       	mov	r13, r31
     7a6:	f0 2d       	mov	r31, r0
     7a8:	f6 01       	movw	r30, r12
     7aa:	91 01       	movw	r18, r2
     7ac:	40 e0       	ldi	r20, 0x00	; 0
     7ae:	50 e0       	ldi	r21, 0x00	; 0
   i=0;k=s;
   do
   {
		path[i++]=k;

		k=state[k].predecessor;
     7b0:	00 e8       	ldi	r16, 0x80	; 128
     7b2:	16 e0       	ldi	r17, 0x06	; 6
     7b4:	01 c0       	rjmp	.+2      	; 0x7b8 <shortest_path+0x1ee>
   }while(k!=s);

   i=0;k=s;
   do
   {
		path[i++]=k;
     7b6:	ab 01       	movw	r20, r22
     7b8:	21 93       	st	Z+, r18
     7ba:	31 93       	st	Z+, r19
     7bc:	ba 01       	movw	r22, r20
     7be:	6f 5f       	subi	r22, 0xFF	; 255
     7c0:	7f 4f       	sbci	r23, 0xFF	; 255

		k=state[k].predecessor;
     7c2:	c9 01       	movw	r24, r18
     7c4:	88 0f       	add	r24, r24
     7c6:	99 1f       	adc	r25, r25
     7c8:	88 0f       	add	r24, r24
     7ca:	99 1f       	adc	r25, r25
     7cc:	82 0f       	add	r24, r18
     7ce:	93 1f       	adc	r25, r19
     7d0:	80 0f       	add	r24, r16
     7d2:	91 1f       	adc	r25, r17
     7d4:	dc 01       	movw	r26, r24
     7d6:	2d 91       	ld	r18, X+
     7d8:	3c 91       	ld	r19, X
     7da:	11 97       	sbiw	r26, 0x01	; 1
   }while(k!=t);
     7dc:	28 15       	cp	r18, r8
     7de:	39 05       	cpc	r19, r9
     7e0:	51 f7       	brne	.-44     	; 0x7b6 <shortest_path+0x1ec>
   path[i++]=t;
     7e2:	fb 01       	movw	r30, r22
     7e4:	ee 0f       	add	r30, r30
     7e6:	ff 1f       	adc	r31, r31
     7e8:	e8 51       	subi	r30, 0x18	; 24
     7ea:	fb 4f       	sbci	r31, 0xFB	; 251
     7ec:	91 82       	std	Z+1, r9	; 0x01
     7ee:	80 82       	st	Z, r8
     7f0:	ca 01       	movw	r24, r20
     7f2:	02 96       	adiw	r24, 0x02	; 2
   tot=i;
     7f4:	90 93 e7 04 	sts	0x04E7, r25
     7f8:	80 93 e6 04 	sts	0x04E6, r24
   for(unsigned int j=0;j<tot-1;j++)
     7fc:	bf ef       	ldi	r27, 0xFF	; 255
     7fe:	4f 3f       	cpi	r20, 0xFF	; 255
     800:	5b 07       	cpc	r21, r27
     802:	79 f0       	breq	.+30     	; 0x822 <shortest_path+0x258>
     804:	af e7       	ldi	r26, 0x7F	; 127
     806:	ba e0       	ldi	r27, 0x0A	; 10
Input :       s(source),d(destination)
Output :      none
Logic:       standard implementation of dijkstra algorithm
Example Call:shortest_path(55,68)
*/
void shortest_path(unsigned int s,unsigned int t)
     808:	ca 01       	movw	r24, r20
     80a:	88 0f       	add	r24, r24
     80c:	99 1f       	adc	r25, r25
     80e:	86 51       	subi	r24, 0x16	; 22
     810:	9b 4f       	sbci	r25, 0xFB	; 251
     812:	f6 01       	movw	r30, r12
   }while(k!=t);
   path[i++]=t;
   tot=i;
   for(unsigned int j=0;j<tot-1;j++)
	{
		original[j]=path[j];
     814:	21 91       	ld	r18, Z+
     816:	31 91       	ld	r19, Z+
     818:	2d 93       	st	X+, r18
     81a:	3d 93       	st	X+, r19

		k=state[k].predecessor;
   }while(k!=t);
   path[i++]=t;
   tot=i;
   for(unsigned int j=0;j<tot-1;j++)
     81c:	e8 17       	cp	r30, r24
     81e:	f9 07       	cpc	r31, r25
     820:	c9 f7       	brne	.-14     	; 0x814 <shortest_path+0x24a>
	{
		original[j]=path[j];
	}
	for(unsigned int j=0;j<tot-1;j++)
     822:	60 90 e6 04 	lds	r6, 0x04E6
     826:	70 90 e7 04 	lds	r7, 0x04E7
Input :       s(source),d(destination)
Output :      none
Logic:       standard implementation of dijkstra algorithm
Example Call:shortest_path(55,68)
*/
void shortest_path(unsigned int s,unsigned int t)
     82a:	c3 01       	movw	r24, r6
     82c:	88 0f       	add	r24, r24
     82e:	99 1f       	adc	r25, r25
     830:	0f 2e       	mov	r0, r31
     832:	f6 ee       	ldi	r31, 0xE6	; 230
     834:	8f 2e       	mov	r8, r31
     836:	f4 e0       	ldi	r31, 0x04	; 4
     838:	9f 2e       	mov	r9, r31
     83a:	f0 2d       	mov	r31, r0
     83c:	88 0e       	add	r8, r24
     83e:	99 1e       	adc	r9, r25
     840:	76 01       	movw	r14, r12
	{
		original[j]=path[j];
	}
	for(unsigned int j=0;j<tot-1;j++)
	{
		if((path[j]/10==path[j+1]/10)&&(path[j]<path[j+1]))
     842:	0f 2e       	mov	r0, r31
     844:	fa e0       	ldi	r31, 0x0A	; 10
     846:	af 2e       	mov	r10, r31
     848:	bb 24       	eor	r11, r11
     84a:	f0 2d       	mov	r31, r0
		else if((path[j]/10==path[j+1]/10)&&(path[j]>path[j+1]))
		path[j]='N';
		else if(path[j]>path[j+1])
		path[j]='W';
		else if(path[j]<path[j+1])
		path[j]='E';
     84c:	0f 2e       	mov	r0, r31
     84e:	f5 e4       	ldi	r31, 0x45	; 69
     850:	4f 2e       	mov	r4, r31
     852:	55 24       	eor	r5, r5
     854:	f0 2d       	mov	r31, r0
		if((path[j]/10==path[j+1]/10)&&(path[j]<path[j+1]))
		path[j]='S';
		else if((path[j]/10==path[j+1]/10)&&(path[j]>path[j+1]))
		path[j]='N';
		else if(path[j]>path[j+1])
		path[j]='W';
     856:	0f 2e       	mov	r0, r31
     858:	f7 e5       	ldi	r31, 0x57	; 87
     85a:	2f 2e       	mov	r2, r31
     85c:	33 24       	eor	r3, r3
     85e:	f0 2d       	mov	r31, r0
     860:	3b c0       	rjmp	.+118    	; 0x8d8 <shortest_path+0x30e>
	{
		original[j]=path[j];
	}
	for(unsigned int j=0;j<tot-1;j++)
	{
		if((path[j]/10==path[j+1]/10)&&(path[j]<path[j+1]))
     862:	f7 01       	movw	r30, r14
     864:	20 81       	ld	r18, Z
     866:	31 81       	ldd	r19, Z+1	; 0x01
     868:	02 80       	ldd	r0, Z+2	; 0x02
     86a:	f3 81       	ldd	r31, Z+3	; 0x03
     86c:	e0 2d       	mov	r30, r0
     86e:	c9 01       	movw	r24, r18
     870:	b5 01       	movw	r22, r10
     872:	0e 94 ae 11 	call	0x235c	; 0x235c <__divmodhi4>
     876:	7a 83       	std	Y+2, r23	; 0x02
     878:	69 83       	std	Y+1, r22	; 0x01
     87a:	cf 01       	movw	r24, r30
     87c:	b5 01       	movw	r22, r10
     87e:	0e 94 ae 11 	call	0x235c	; 0x235c <__divmodhi4>
     882:	89 81       	ldd	r24, Y+1	; 0x01
     884:	9a 81       	ldd	r25, Y+2	; 0x02
     886:	86 17       	cp	r24, r22
     888:	97 07       	cpc	r25, r23
     88a:	a1 f4       	brne	.+40     	; 0x8b4 <shortest_path+0x2ea>
     88c:	2e 17       	cp	r18, r30
     88e:	3f 07       	cpc	r19, r31
     890:	3c f4       	brge	.+14     	; 0x8a0 <shortest_path+0x2d6>
		path[j]='S';
     892:	e3 e5       	ldi	r30, 0x53	; 83
     894:	f0 e0       	ldi	r31, 0x00	; 0
     896:	d7 01       	movw	r26, r14
     898:	11 96       	adiw	r26, 0x01	; 1
     89a:	fc 93       	st	X, r31
     89c:	ee 93       	st	-X, r30
     89e:	18 c0       	rjmp	.+48     	; 0x8d0 <shortest_path+0x306>
		else if((path[j]/10==path[j+1]/10)&&(path[j]>path[j+1]))
     8a0:	e2 17       	cp	r30, r18
     8a2:	f3 07       	cpc	r31, r19
     8a4:	ac f4       	brge	.+42     	; 0x8d0 <shortest_path+0x306>
		path[j]='N';
     8a6:	ee e4       	ldi	r30, 0x4E	; 78
     8a8:	f0 e0       	ldi	r31, 0x00	; 0
     8aa:	d7 01       	movw	r26, r14
     8ac:	11 96       	adiw	r26, 0x01	; 1
     8ae:	fc 93       	st	X, r31
     8b0:	ee 93       	st	-X, r30
     8b2:	0e c0       	rjmp	.+28     	; 0x8d0 <shortest_path+0x306>
		else if(path[j]>path[j+1])
     8b4:	e2 17       	cp	r30, r18
     8b6:	f3 07       	cpc	r31, r19
     8b8:	2c f4       	brge	.+10     	; 0x8c4 <shortest_path+0x2fa>
		path[j]='W';
     8ba:	d7 01       	movw	r26, r14
     8bc:	11 96       	adiw	r26, 0x01	; 1
     8be:	3c 92       	st	X, r3
     8c0:	2e 92       	st	-X, r2
     8c2:	06 c0       	rjmp	.+12     	; 0x8d0 <shortest_path+0x306>
		else if(path[j]<path[j+1])
     8c4:	2e 17       	cp	r18, r30
     8c6:	3f 07       	cpc	r19, r31
     8c8:	1c f4       	brge	.+6      	; 0x8d0 <shortest_path+0x306>
		path[j]='E';
     8ca:	f7 01       	movw	r30, r14
     8cc:	51 82       	std	Z+1, r5	; 0x01
     8ce:	40 82       	st	Z, r4
     8d0:	22 e0       	ldi	r18, 0x02	; 2
     8d2:	30 e0       	ldi	r19, 0x00	; 0
     8d4:	e2 0e       	add	r14, r18
     8d6:	f3 1e       	adc	r15, r19
   tot=i;
   for(unsigned int j=0;j<tot-1;j++)
	{
		original[j]=path[j];
	}
	for(unsigned int j=0;j<tot-1;j++)
     8d8:	e8 14       	cp	r14, r8
     8da:	f9 04       	cpc	r15, r9
     8dc:	11 f6       	brne	.-124    	; 0x862 <shortest_path+0x298>
		path[j]='W';
		else if(path[j]<path[j+1])
		path[j]='E';

	}
	for(unsigned int j=0;j<tot-1;j++)
     8de:	31 e0       	ldi	r19, 0x01	; 1
     8e0:	63 16       	cp	r6, r19
     8e2:	71 04       	cpc	r7, r1
     8e4:	e9 f1       	breq	.+122    	; 0x960 <shortest_path+0x396>
     8e6:	f6 01       	movw	r30, r12
		if((char)path[j]=='E')
		path[j]=1;
		if((char)path[j]=='S')
		path[j]=2;
		if((char)path[j]=='W')
		path[j]=3;
     8e8:	83 e0       	ldi	r24, 0x03	; 3
     8ea:	90 e0       	ldi	r25, 0x00	; 0
		if((char)path[j]=='N')
		path[j]=0;
		if((char)path[j]=='E')
		path[j]=1;
		if((char)path[j]=='S')
		path[j]=2;
     8ec:	22 e0       	ldi	r18, 0x02	; 2
     8ee:	30 e0       	ldi	r19, 0x00	; 0
	for(unsigned int j=0;j<tot-1;j++)
	{
		if((char)path[j]=='N')
		path[j]=0;
		if((char)path[j]=='E')
		path[j]=1;
     8f0:	41 e0       	ldi	r20, 0x01	; 1
     8f2:	50 e0       	ldi	r21, 0x00	; 0
Input :       s(source),d(destination)
Output :      none
Logic:       standard implementation of dijkstra algorithm
Example Call:shortest_path(55,68)
*/
void shortest_path(unsigned int s,unsigned int t)
     8f4:	df 01       	movw	r26, r30
		path[j]='E';

	}
	for(unsigned int j=0;j<tot-1;j++)
	{
		if((char)path[j]=='N')
     8f6:	60 81       	ld	r22, Z
     8f8:	6e 34       	cpi	r22, 0x4E	; 78
     8fa:	19 f4       	brne	.+6      	; 0x902 <shortest_path+0x338>
		path[j]=0;
     8fc:	11 82       	std	Z+1, r1	; 0x01
     8fe:	10 82       	st	Z, r1
     900:	06 c0       	rjmp	.+12     	; 0x90e <shortest_path+0x344>
		if((char)path[j]=='E')
     902:	60 81       	ld	r22, Z
     904:	65 34       	cpi	r22, 0x45	; 69
     906:	19 f4       	brne	.+6      	; 0x90e <shortest_path+0x344>
		path[j]=1;
     908:	51 83       	std	Z+1, r21	; 0x01
     90a:	40 83       	st	Z, r20
     90c:	07 c0       	rjmp	.+14     	; 0x91c <shortest_path+0x352>
		if((char)path[j]=='S')
     90e:	6c 91       	ld	r22, X
     910:	63 35       	cpi	r22, 0x53	; 83
     912:	21 f4       	brne	.+8      	; 0x91c <shortest_path+0x352>
		path[j]=2;
     914:	11 96       	adiw	r26, 0x01	; 1
     916:	3c 93       	st	X, r19
     918:	2e 93       	st	-X, r18
     91a:	06 c0       	rjmp	.+12     	; 0x928 <shortest_path+0x35e>
		if((char)path[j]=='W')
     91c:	6c 91       	ld	r22, X
     91e:	67 35       	cpi	r22, 0x57	; 87
     920:	19 f4       	brne	.+6      	; 0x928 <shortest_path+0x35e>
		path[j]=3;
     922:	11 96       	adiw	r26, 0x01	; 1
     924:	9c 93       	st	X, r25
     926:	8e 93       	st	-X, r24
     928:	32 96       	adiw	r30, 0x02	; 2
		path[j]='W';
		else if(path[j]<path[j+1])
		path[j]='E';

	}
	for(unsigned int j=0;j<tot-1;j++)
     92a:	e8 15       	cp	r30, r8
     92c:	f9 05       	cpc	r31, r9
     92e:	11 f7       	brne	.-60     	; 0x8f4 <shortest_path+0x32a>
     930:	f6 01       	movw	r30, r12
     932:	80 e0       	ldi	r24, 0x00	; 0
     934:	90 e0       	ldi	r25, 0x00	; 0
	int temp=0;
	for(unsigned int j=0;j<tot-1;j++)
	{
		temp=current;
		current=path[j];
		path[j]=(path[j]-temp)*90;
     936:	6a e5       	ldi	r22, 0x5A	; 90
     938:	70 e0       	ldi	r23, 0x00	; 0
     93a:	01 c0       	rjmp	.+2      	; 0x93e <shortest_path+0x374>
	int current =0;
	int temp=0;
	for(unsigned int j=0;j<tot-1;j++)
	{
		temp=current;
		current=path[j];
     93c:	ca 01       	movw	r24, r20
     93e:	40 81       	ld	r20, Z
     940:	51 81       	ldd	r21, Z+1	; 0x01
		path[j]=(path[j]-temp)*90;
     942:	da 01       	movw	r26, r20
     944:	a8 1b       	sub	r26, r24
     946:	b9 0b       	sbc	r27, r25
     948:	a6 9f       	mul	r26, r22
     94a:	90 01       	movw	r18, r0
     94c:	a7 9f       	mul	r26, r23
     94e:	30 0d       	add	r19, r0
     950:	b6 9f       	mul	r27, r22
     952:	30 0d       	add	r19, r0
     954:	11 24       	eor	r1, r1
     956:	21 93       	st	Z+, r18
     958:	31 93       	st	Z+, r19
		path[j]=3;
	}

	int current =0;
	int temp=0;
	for(unsigned int j=0;j<tot-1;j++)
     95a:	e8 15       	cp	r30, r8
     95c:	f9 05       	cpc	r31, r9
     95e:	71 f7       	brne	.-36     	; 0x93c <shortest_path+0x372>
		temp=current;
		current=path[j];
		path[j]=(path[j]-temp)*90;
		//cout<<path[j]<<" ";
	}
	for(unsigned int j=0;j<tot-1;j++)
     960:	40 91 e6 04 	lds	r20, 0x04E6
     964:	50 91 e7 04 	lds	r21, 0x04E7
     968:	41 30       	cpi	r20, 0x01	; 1
     96a:	51 05       	cpc	r21, r1
     96c:	c1 f1       	breq	.+112    	; 0x9de <shortest_path+0x414>
     96e:	41 50       	subi	r20, 0x01	; 1
     970:	50 40       	sbci	r21, 0x00	; 0
     972:	20 e0       	ldi	r18, 0x00	; 0
     974:	30 e0       	ldi	r19, 0x00	; 0
	{
		if(path[j]==90||path[j]==-270)
		{
			path[j]=3;
     976:	63 e0       	ldi	r22, 0x03	; 3
     978:	70 e0       	ldi	r23, 0x00	; 0
		}
		else if(path[j]==270||path[j]==-90)
		{
			path[j]=1;
     97a:	aa 24       	eor	r10, r10
     97c:	bb 24       	eor	r11, r11
     97e:	a3 94       	inc	r10
		{
			path[j]=4;
		}
		else
		{
			path[j]=2;
     980:	88 24       	eor	r8, r8
     982:	99 24       	eor	r9, r9
     984:	68 94       	set
     986:	81 f8       	bld	r8, 1
		{
			path[j]=1;
		}
		else if(path[j]==0)
		{
			path[j]=4;
     988:	04 e0       	ldi	r16, 0x04	; 4
     98a:	10 e0       	ldi	r17, 0x00	; 0
     98c:	7a 01       	movw	r14, r20
     98e:	a9 01       	movw	r20, r18
     990:	96 01       	movw	r18, r12
Input :       s(source),d(destination)
Output :      none
Logic:       standard implementation of dijkstra algorithm
Example Call:shortest_path(55,68)
*/
void shortest_path(unsigned int s,unsigned int t)
     992:	f9 01       	movw	r30, r18
		path[j]=(path[j]-temp)*90;
		//cout<<path[j]<<" ";
	}
	for(unsigned int j=0;j<tot-1;j++)
	{
		if(path[j]==90||path[j]==-270)
     994:	80 81       	ld	r24, Z
     996:	91 81       	ldd	r25, Z+1	; 0x01
     998:	8a 35       	cpi	r24, 0x5A	; 90
     99a:	91 05       	cpc	r25, r1
     99c:	21 f0       	breq	.+8      	; 0x9a6 <shortest_path+0x3dc>
     99e:	be ef       	ldi	r27, 0xFE	; 254
     9a0:	82 3f       	cpi	r24, 0xF2	; 242
     9a2:	9b 07       	cpc	r25, r27
     9a4:	19 f4       	brne	.+6      	; 0x9ac <shortest_path+0x3e2>
		{
			path[j]=3;
     9a6:	71 83       	std	Z+1, r23	; 0x01
     9a8:	60 83       	st	Z, r22
     9aa:	12 c0       	rjmp	.+36     	; 0x9d0 <shortest_path+0x406>
		}
		else if(path[j]==270||path[j]==-90)
     9ac:	a1 e0       	ldi	r26, 0x01	; 1
     9ae:	8e 30       	cpi	r24, 0x0E	; 14
     9b0:	9a 07       	cpc	r25, r26
     9b2:	21 f0       	breq	.+8      	; 0x9bc <shortest_path+0x3f2>
     9b4:	bf ef       	ldi	r27, 0xFF	; 255
     9b6:	86 3a       	cpi	r24, 0xA6	; 166
     9b8:	9b 07       	cpc	r25, r27
     9ba:	19 f4       	brne	.+6      	; 0x9c2 <shortest_path+0x3f8>
		{
			path[j]=1;
     9bc:	b1 82       	std	Z+1, r11	; 0x01
     9be:	a0 82       	st	Z, r10
     9c0:	07 c0       	rjmp	.+14     	; 0x9d0 <shortest_path+0x406>
		}
		else if(path[j]==0)
     9c2:	00 97       	sbiw	r24, 0x00	; 0
     9c4:	19 f4       	brne	.+6      	; 0x9cc <shortest_path+0x402>
		{
			path[j]=4;
     9c6:	11 83       	std	Z+1, r17	; 0x01
     9c8:	00 83       	st	Z, r16
     9ca:	02 c0       	rjmp	.+4      	; 0x9d0 <shortest_path+0x406>
		}
		else
		{
			path[j]=2;
     9cc:	91 82       	std	Z+1, r9	; 0x01
     9ce:	80 82       	st	Z, r8
		temp=current;
		current=path[j];
		path[j]=(path[j]-temp)*90;
		//cout<<path[j]<<" ";
	}
	for(unsigned int j=0;j<tot-1;j++)
     9d0:	4f 5f       	subi	r20, 0xFF	; 255
     9d2:	5f 4f       	sbci	r21, 0xFF	; 255
     9d4:	2e 5f       	subi	r18, 0xFE	; 254
     9d6:	3f 4f       	sbci	r19, 0xFF	; 255
     9d8:	4e 15       	cp	r20, r14
     9da:	5f 05       	cpc	r21, r15
     9dc:	d0 f2       	brcs	.-76     	; 0x992 <shortest_path+0x3c8>
		{
			path[j]=2;
		}
	}

}
     9de:	28 96       	adiw	r28, 0x08	; 8
     9e0:	0f b6       	in	r0, 0x3f	; 63
     9e2:	f8 94       	cli
     9e4:	de bf       	out	0x3e, r29	; 62
     9e6:	0f be       	out	0x3f, r0	; 63
     9e8:	cd bf       	out	0x3d, r28	; 61
     9ea:	df 91       	pop	r29
     9ec:	cf 91       	pop	r28
     9ee:	1f 91       	pop	r17
     9f0:	0f 91       	pop	r16
     9f2:	ff 90       	pop	r15
     9f4:	ef 90       	pop	r14
     9f6:	df 90       	pop	r13
     9f8:	cf 90       	pop	r12
     9fa:	bf 90       	pop	r11
     9fc:	af 90       	pop	r10
     9fe:	9f 90       	pop	r9
     a00:	8f 90       	pop	r8
     a02:	7f 90       	pop	r7
     a04:	6f 90       	pop	r6
     a06:	5f 90       	pop	r5
     a08:	4f 90       	pop	r4
     a0a:	3f 90       	pop	r3
     a0c:	2f 90       	pop	r2
     a0e:	08 95       	ret

00000a10 <__vector_25>:
Output :      received signal from other bot
Logic:       -
Example Call:   -
*/
SIGNAL(SIG_USART0_RECV) 		// ISR for receive complete interrupt
{
     a10:	1f 92       	push	r1
     a12:	0f 92       	push	r0
     a14:	0f b6       	in	r0, 0x3f	; 63
     a16:	0f 92       	push	r0
     a18:	11 24       	eor	r1, r1
     a1a:	8f 93       	push	r24
     a1c:	9f 93       	push	r25
	rec = UDR0; 				//making copy of data from UDR0 in 'rec' variable
     a1e:	80 91 c6 00 	lds	r24, 0x00C6
     a22:	90 e0       	ldi	r25, 0x00	; 0
     a24:	90 93 17 0c 	sts	0x0C17, r25
     a28:	80 93 16 0c 	sts	0x0C16, r24
	if(rec==149)
     a2c:	85 39       	cpi	r24, 0x95	; 149
     a2e:	91 05       	cpc	r25, r1
     a30:	61 f4       	brne	.+24     	; 0xa4a <__vector_25+0x3a>
	{
		z=149;
     a32:	85 e9       	ldi	r24, 0x95	; 149
     a34:	90 e0       	ldi	r25, 0x00	; 0
     a36:	90 93 9d 04 	sts	0x049D, r25
     a3a:	80 93 9c 04 	sts	0x049C, r24
		rec=200;
     a3e:	88 ec       	ldi	r24, 0xC8	; 200
     a40:	90 e0       	ldi	r25, 0x00	; 0
     a42:	90 93 17 0c 	sts	0x0C17, r25
     a46:	80 93 16 0c 	sts	0x0C16, r24
	}
}
     a4a:	9f 91       	pop	r25
     a4c:	8f 91       	pop	r24
     a4e:	0f 90       	pop	r0
     a50:	0f be       	out	0x3f, r0	; 63
     a52:	0f 90       	pop	r0
     a54:	1f 90       	pop	r1
     a56:	18 95       	reti

00000a58 <uart0_init>:
// actual baud rate:9600 (error 0.0%)
// char size: 8 bit
// parity: Disabled
void uart0_init(void)
{
	UCSR0B = 0x00; //disable while setting baud rate
     a58:	e1 ec       	ldi	r30, 0xC1	; 193
     a5a:	f0 e0       	ldi	r31, 0x00	; 0
     a5c:	10 82       	st	Z, r1
	UCSR0A = 0x00;
     a5e:	10 92 c0 00 	sts	0x00C0, r1
	UCSR0C = 0x06;
     a62:	86 e0       	ldi	r24, 0x06	; 6
     a64:	80 93 c2 00 	sts	0x00C2, r24
	UBRR0L = 0x5F; //set baud rate lo
     a68:	8f e5       	ldi	r24, 0x5F	; 95
     a6a:	80 93 c4 00 	sts	0x00C4, r24
	UBRR0H = 0x00; //set baud rate hi
     a6e:	10 92 c5 00 	sts	0x00C5, r1
	UCSR0B = 0x98;
     a72:	88 e9       	ldi	r24, 0x98	; 152
     a74:	80 83       	st	Z, r24
}
     a76:	08 95       	ret

00000a78 <uart2_init>:
// actual baud rate:9600 (error 0.0%)
// char size: 8 bit
// parity: Disabled
void uart2_init(void)
{
	UCSR2B = 0x00; //disable while setting baud rate
     a78:	e1 ed       	ldi	r30, 0xD1	; 209
     a7a:	f0 e0       	ldi	r31, 0x00	; 0
     a7c:	10 82       	st	Z, r1
	UCSR2A = 0x00;
     a7e:	10 92 d0 00 	sts	0x00D0, r1
	UCSR2C = 0x06;
     a82:	86 e0       	ldi	r24, 0x06	; 6
     a84:	80 93 d2 00 	sts	0x00D2, r24
	UBRR2L = 0x5F; //set baud rate lo
     a88:	8f e5       	ldi	r24, 0x5F	; 95
     a8a:	80 93 d4 00 	sts	0x00D4, r24
	UBRR2H = 0x00; //set baud rate hi
     a8e:	10 92 d5 00 	sts	0x00D5, r1
	UCSR2B = 0x98;
     a92:	88 e9       	ldi	r24, 0x98	; 152
     a94:	80 83       	st	Z, r24
}
     a96:	08 95       	ret

00000a98 <led_config>:
void led_config(void)  //configuration setting for led on port H 5,6,7
{
	
	DDRH=0b11100000;
     a98:	80 ee       	ldi	r24, 0xE0	; 224
     a9a:	80 93 01 01 	sts	0x0101, r24
	PORTH=0x00;
     a9e:	10 92 02 01 	sts	0x0102, r1
}
     aa2:	08 95       	ret

00000aa4 <red_on>:
Logic:       -
Example Call:   red_on();
*/
void red_on(void)    //for red led
{
	PORTH=0b10000000;
     aa4:	80 e8       	ldi	r24, 0x80	; 128
     aa6:	80 93 02 01 	sts	0x0102, r24
}
     aaa:	08 95       	ret

00000aac <led_off>:
Logic:       -
Example Call:   led_off();
*/
void led_off(void)			//for led off
{
	PORTH=0x00;
     aac:	10 92 02 01 	sts	0x0102, r1
}
     ab0:	08 95       	ret

00000ab2 <blue_on>:
Logic:       -
Example Call:   blue_on();
*/
void blue_on(void)		//for blue led
{
	PORTH=0b00100000;
     ab2:	80 e2       	ldi	r24, 0x20	; 32
     ab4:	80 93 02 01 	sts	0x0102, r24
}
     ab8:	08 95       	ret

00000aba <green_on>:
Logic:       -
Example Call:   green_on();
*/
void green_on(void)		//for green led
{
	PORTH=0b01000000;
     aba:	80 e4       	ldi	r24, 0x40	; 64
     abc:	80 93 02 01 	sts	0x0102, r24
}
     ac0:	08 95       	ret

00000ac2 <motion_pin_config>:
//Function to configure ports to enable robot's motion
void motion_pin_config (void)
{
	DDRA = DDRA | 0x0F;
     ac2:	81 b1       	in	r24, 0x01	; 1
     ac4:	8f 60       	ori	r24, 0x0F	; 15
     ac6:	81 b9       	out	0x01, r24	; 1
	PORTA = PORTA & 0xF0;
     ac8:	82 b1       	in	r24, 0x02	; 2
     aca:	80 7f       	andi	r24, 0xF0	; 240
     acc:	82 b9       	out	0x02, r24	; 2
	DDRL = DDRL | 0x18;   //Setting PL3 and PL4 pins as output for PWM generation
     ace:	ea e0       	ldi	r30, 0x0A	; 10
     ad0:	f1 e0       	ldi	r31, 0x01	; 1
     ad2:	80 81       	ld	r24, Z
     ad4:	88 61       	ori	r24, 0x18	; 24
     ad6:	80 83       	st	Z, r24
	PORTL = PORTL | 0x18; //PL3 and PL4 pins are for velocity control using PWM.
     ad8:	eb e0       	ldi	r30, 0x0B	; 11
     ada:	f1 e0       	ldi	r31, 0x01	; 1
     adc:	80 81       	ld	r24, Z
     ade:	88 61       	ori	r24, 0x18	; 24
     ae0:	80 83       	st	Z, r24
}
     ae2:	08 95       	ret

00000ae4 <lcd_port_config>:
//Function to configure LCD port
void lcd_port_config (void)
{
	DDRC = DDRC | 0xF7; //all the LCD pin's direction set as output
     ae4:	87 b1       	in	r24, 0x07	; 7
     ae6:	87 6f       	ori	r24, 0xF7	; 247
     ae8:	87 b9       	out	0x07, r24	; 7
	PORTC = PORTC & 0x80; // all the LCD pins are set to logic 0 except PORTC 7
     aea:	88 b1       	in	r24, 0x08	; 8
     aec:	80 78       	andi	r24, 0x80	; 128
     aee:	88 b9       	out	0x08, r24	; 8
}
     af0:	08 95       	ret

00000af2 <adc_pin_config>:

//ADC pin configuration
void adc_pin_config (void)
{
	DDRF = 0x00;
     af2:	10 ba       	out	0x10, r1	; 16
	PORTF = 0x00;
     af4:	11 ba       	out	0x11, r1	; 17
	DDRK = 0x00;
     af6:	10 92 07 01 	sts	0x0107, r1
	PORTK = 0x00;
     afa:	10 92 08 01 	sts	0x0108, r1
}
     afe:	08 95       	ret

00000b00 <left_encoder_pin_config>:

//Function to configure INT4 (PORTE 4) pin as input for the left position encoder
void left_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xEF;  //Set the direction of the PORTE 4 pin as input
     b00:	6c 98       	cbi	0x0d, 4	; 13
	PORTE = PORTE | 0x10; //Enable internal pull-up for PORTE 4 pin
     b02:	74 9a       	sbi	0x0e, 4	; 14
}
     b04:	08 95       	ret

00000b06 <right_encoder_pin_config>:

//Function to configure INT5 (PORTE 5) pin as input for the right position encoder
void right_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xDF;  //Set the direction of the PORTE 4 pin as input
     b06:	6d 98       	cbi	0x0d, 5	; 13
	PORTE = PORTE | 0x20; //Enable internal pull-up for PORTE 4 pin
     b08:	75 9a       	sbi	0x0e, 5	; 14
}
     b0a:	08 95       	ret

00000b0c <buzzer_pin_config>:
void buzzer_pin_config (void)
{
	DDRC = DDRC | 0x08;		//Setting PORTC 3 as output
     b0c:	3b 9a       	sbi	0x07, 3	; 7
	PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer
     b0e:	43 98       	cbi	0x08, 3	; 8
}
     b10:	08 95       	ret

00000b12 <servo1_pin_config>:


//Configure PORTB 5 pin for servo motor 1 operation
void servo1_pin_config (void)
{
	DDRB  = DDRB | 0x20;  //making PORTB 5 pin output
     b12:	25 9a       	sbi	0x04, 5	; 4
	PORTB = PORTB | 0x20; //setting PORTB 5 pin to logic 1
     b14:	2d 9a       	sbi	0x05, 5	; 5
}
     b16:	08 95       	ret

00000b18 <port_init>:
//Function to initialize ports
void port_init()
{
	servo1_pin_config();
     b18:	0e 94 89 05 	call	0xb12	; 0xb12 <servo1_pin_config>
	motion_pin_config(); //robot motion pins config
     b1c:	0e 94 61 05 	call	0xac2	; 0xac2 <motion_pin_config>
	left_encoder_pin_config(); //left encoder pin config
     b20:	0e 94 80 05 	call	0xb00	; 0xb00 <left_encoder_pin_config>
	right_encoder_pin_config(); //right encoder pin config
     b24:	0e 94 83 05 	call	0xb06	; 0xb06 <right_encoder_pin_config>
	lcd_port_config();
     b28:	0e 94 72 05 	call	0xae4	; 0xae4 <lcd_port_config>
	adc_pin_config();
     b2c:	0e 94 79 05 	call	0xaf2	; 0xaf2 <adc_pin_config>
	buzzer_pin_config();
     b30:	0e 94 86 05 	call	0xb0c	; 0xb0c <buzzer_pin_config>
	led_config();
     b34:	0e 94 4c 05 	call	0xa98	; 0xa98 <led_config>
	//color_sensor_pin_config();
}
     b38:	08 95       	ret

00000b3a <timer5_init>:
// Prescale:256
// PWM 8bit fast, TOP=0x00FF
// Timer Frequency:225.000Hz
void timer5_init()
{
	TCCR5B = 0x00;	//Stop
     b3a:	e1 e2       	ldi	r30, 0x21	; 33
     b3c:	f1 e0       	ldi	r31, 0x01	; 1
     b3e:	10 82       	st	Z, r1
	TCNT5H = 0xFF;	//Counter higher 8-bit value to which OCR5xH value is compared with
     b40:	8f ef       	ldi	r24, 0xFF	; 255
     b42:	80 93 25 01 	sts	0x0125, r24
	TCNT5L = 0x01;	//Counter lower 8-bit value to which OCR5xH value is compared with
     b46:	91 e0       	ldi	r25, 0x01	; 1
     b48:	90 93 24 01 	sts	0x0124, r25
	OCR5AH = 0x00;	//Output compare register high value for Left Motor
     b4c:	10 92 29 01 	sts	0x0129, r1
	OCR5AL = 0xFF;	//Output compare register low value for Left Motor
     b50:	80 93 28 01 	sts	0x0128, r24
	OCR5BH = 0x00;	//Output compare register high value for Right Motor
     b54:	10 92 2b 01 	sts	0x012B, r1
	OCR5BL = 0xFF;	//Output compare register low value for Right Motor
     b58:	80 93 2a 01 	sts	0x012A, r24
	OCR5CH = 0x00;	//Output compare register high value for Motor C1
     b5c:	10 92 2d 01 	sts	0x012D, r1
	OCR5CL = 0xFF;	//Output compare register low value for Motor C1
     b60:	80 93 2c 01 	sts	0x012C, r24
	TCCR5A = 0xA9;	/*{COM5A1=1, COM5A0=0; COM5B1=1, COM5B0=0; COM5C1=1 COM5C0=0}
     b64:	89 ea       	ldi	r24, 0xA9	; 169
     b66:	80 93 20 01 	sts	0x0120, r24
 					  For Overriding normal port functionality to OCRnA outputs.
				  	  {WGM51=0, WGM50=1} Along With WGM52 in TCCR5B for Selecting FAST PWM 8-bit Mode*/
	
	TCCR5B = 0x0B;	//WGM12=1; CS12=0, CS11=1, CS10=1 (Prescaler=64)
     b6a:	8b e0       	ldi	r24, 0x0B	; 11
     b6c:	80 83       	st	Z, r24
}
     b6e:	08 95       	ret

00000b70 <adc_init>:

void adc_init()
{
	ADCSRA = 0x00;
     b70:	ea e7       	ldi	r30, 0x7A	; 122
     b72:	f0 e0       	ldi	r31, 0x00	; 0
     b74:	10 82       	st	Z, r1
	ADCSRB = 0x00;		//MUX5 = 0
     b76:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
     b7a:	80 e2       	ldi	r24, 0x20	; 32
     b7c:	80 93 7c 00 	sts	0x007C, r24
	ACSR = 0x80;
     b80:	80 e8       	ldi	r24, 0x80	; 128
     b82:	80 bf       	out	0x30, r24	; 48
	ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
     b84:	86 e8       	ldi	r24, 0x86	; 134
     b86:	80 83       	st	Z, r24
}
     b88:	08 95       	ret

00000b8a <ADC_Conversion>:

//Function For ADC Conversion
unsigned char ADC_Conversion(unsigned char Ch)
{
	unsigned char a;
	if(Ch>7)
     b8a:	88 30       	cpi	r24, 0x08	; 8
     b8c:	18 f0       	brcs	.+6      	; 0xb94 <ADC_Conversion+0xa>
	{
		ADCSRB = 0x08;
     b8e:	98 e0       	ldi	r25, 0x08	; 8
     b90:	90 93 7b 00 	sts	0x007B, r25
	}
	Ch = Ch & 0x07;
     b94:	87 70       	andi	r24, 0x07	; 7
	ADMUX= 0x20| Ch;
     b96:	80 62       	ori	r24, 0x20	; 32
     b98:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA = ADCSRA | 0x40;		//Set start conversion bit
     b9c:	ea e7       	ldi	r30, 0x7A	; 122
     b9e:	f0 e0       	ldi	r31, 0x00	; 0
     ba0:	80 81       	ld	r24, Z
     ba2:	80 64       	ori	r24, 0x40	; 64
     ba4:	80 83       	st	Z, r24
	while((ADCSRA&0x10)==0);	//Wait for conversion to complete
     ba6:	80 81       	ld	r24, Z
     ba8:	84 ff       	sbrs	r24, 4
     baa:	fd cf       	rjmp	.-6      	; 0xba6 <ADC_Conversion+0x1c>
	a=ADCH;
     bac:	80 91 79 00 	lds	r24, 0x0079
	ADCSRA = ADCSRA|0x10; //clear ADIF (ADC Interrupt Flag) by writing 1 to it
     bb0:	ea e7       	ldi	r30, 0x7A	; 122
     bb2:	f0 e0       	ldi	r31, 0x00	; 0
     bb4:	90 81       	ld	r25, Z
     bb6:	90 61       	ori	r25, 0x10	; 16
     bb8:	90 83       	st	Z, r25
	ADCSRB = 0x00;
     bba:	10 92 7b 00 	sts	0x007B, r1
	return a;
}
     bbe:	08 95       	ret

00000bc0 <print_sensor>:

//Function To Print Sesor Values At Desired Row And Coloumn Location on LCD
void print_sensor(char row, char coloumn,unsigned char channel)
{
     bc0:	cf 93       	push	r28
     bc2:	df 93       	push	r29
     bc4:	d8 2f       	mov	r29, r24
     bc6:	c6 2f       	mov	r28, r22
     bc8:	84 2f       	mov	r24, r20
	
	ADC_Value = ADC_Conversion(channel);
     bca:	0e 94 c5 05 	call	0xb8a	; 0xb8a <ADC_Conversion>
     bce:	48 2f       	mov	r20, r24
     bd0:	80 93 68 0a 	sts	0x0A68, r24
	lcd_print(row, coloumn, ADC_Value, 3);
     bd4:	8d 2f       	mov	r24, r29
     bd6:	6c 2f       	mov	r22, r28
     bd8:	50 e0       	ldi	r21, 0x00	; 0
     bda:	23 e0       	ldi	r18, 0x03	; 3
     bdc:	30 e0       	ldi	r19, 0x00	; 0
     bde:	0e 94 ad 01 	call	0x35a	; 0x35a <lcd_print>
}
     be2:	df 91       	pop	r29
     be4:	cf 91       	pop	r28
     be6:	08 95       	ret

00000be8 <left_position_encoder_interrupt_init>:

void left_position_encoder_interrupt_init (void) //Interrupt 4 enable
{
	cli(); //Clears the global interrupt
     be8:	f8 94       	cli
	EICRB = EICRB | 0x02; // INT4 is set to trigger with falling edge
     bea:	ea e6       	ldi	r30, 0x6A	; 106
     bec:	f0 e0       	ldi	r31, 0x00	; 0
     bee:	80 81       	ld	r24, Z
     bf0:	82 60       	ori	r24, 0x02	; 2
     bf2:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x10; // Enable Interrupt INT4 for left position encoder
     bf4:	ec 9a       	sbi	0x1d, 4	; 29
	sei();   // Enables the global interrupt
     bf6:	78 94       	sei
}
     bf8:	08 95       	ret

00000bfa <right_position_encoder_interrupt_init>:

void right_position_encoder_interrupt_init (void) //Interrupt 5 enable
{
	cli(); //Clears the global interrupt
     bfa:	f8 94       	cli
	EICRB = EICRB | 0x08; // INT5 is set to trigger with falling edge
     bfc:	ea e6       	ldi	r30, 0x6A	; 106
     bfe:	f0 e0       	ldi	r31, 0x00	; 0
     c00:	80 81       	ld	r24, Z
     c02:	88 60       	ori	r24, 0x08	; 8
     c04:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x20; // Enable Interrupt INT5 for right position encoder
     c06:	ed 9a       	sbi	0x1d, 5	; 29
	sei();   // Enables the global interrupt
     c08:	78 94       	sei
}
     c0a:	08 95       	ret

00000c0c <__vector_6>:

//ISR for right position encoder
ISR(INT5_vect)
{
     c0c:	1f 92       	push	r1
     c0e:	0f 92       	push	r0
     c10:	0f b6       	in	r0, 0x3f	; 63
     c12:	0f 92       	push	r0
     c14:	11 24       	eor	r1, r1
     c16:	8f 93       	push	r24
     c18:	9f 93       	push	r25
     c1a:	af 93       	push	r26
     c1c:	bf 93       	push	r27
	ShaftCountRight++;  //increment right shaft position count
     c1e:	80 91 de 04 	lds	r24, 0x04DE
     c22:	90 91 df 04 	lds	r25, 0x04DF
     c26:	a0 91 e0 04 	lds	r26, 0x04E0
     c2a:	b0 91 e1 04 	lds	r27, 0x04E1
     c2e:	01 96       	adiw	r24, 0x01	; 1
     c30:	a1 1d       	adc	r26, r1
     c32:	b1 1d       	adc	r27, r1
     c34:	80 93 de 04 	sts	0x04DE, r24
     c38:	90 93 df 04 	sts	0x04DF, r25
     c3c:	a0 93 e0 04 	sts	0x04E0, r26
     c40:	b0 93 e1 04 	sts	0x04E1, r27
}
     c44:	bf 91       	pop	r27
     c46:	af 91       	pop	r26
     c48:	9f 91       	pop	r25
     c4a:	8f 91       	pop	r24
     c4c:	0f 90       	pop	r0
     c4e:	0f be       	out	0x3f, r0	; 63
     c50:	0f 90       	pop	r0
     c52:	1f 90       	pop	r1
     c54:	18 95       	reti

00000c56 <__vector_5>:

//ISR for left position encoder
ISR(INT4_vect)
{
     c56:	1f 92       	push	r1
     c58:	0f 92       	push	r0
     c5a:	0f b6       	in	r0, 0x3f	; 63
     c5c:	0f 92       	push	r0
     c5e:	11 24       	eor	r1, r1
     c60:	8f 93       	push	r24
     c62:	9f 93       	push	r25
     c64:	af 93       	push	r26
     c66:	bf 93       	push	r27
	ShaftCountLeft++;  //increment left shaft position count
     c68:	80 91 e2 04 	lds	r24, 0x04E2
     c6c:	90 91 e3 04 	lds	r25, 0x04E3
     c70:	a0 91 e4 04 	lds	r26, 0x04E4
     c74:	b0 91 e5 04 	lds	r27, 0x04E5
     c78:	01 96       	adiw	r24, 0x01	; 1
     c7a:	a1 1d       	adc	r26, r1
     c7c:	b1 1d       	adc	r27, r1
     c7e:	80 93 e2 04 	sts	0x04E2, r24
     c82:	90 93 e3 04 	sts	0x04E3, r25
     c86:	a0 93 e4 04 	sts	0x04E4, r26
     c8a:	b0 93 e5 04 	sts	0x04E5, r27
}
     c8e:	bf 91       	pop	r27
     c90:	af 91       	pop	r26
     c92:	9f 91       	pop	r25
     c94:	8f 91       	pop	r24
     c96:	0f 90       	pop	r0
     c98:	0f be       	out	0x3f, r0	; 63
     c9a:	0f 90       	pop	r0
     c9c:	1f 90       	pop	r1
     c9e:	18 95       	reti

00000ca0 <velocity>:
//Function for velocity control
void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR5AL = (unsigned char)left_motor;
     ca0:	80 93 28 01 	sts	0x0128, r24
	OCR5BL = (unsigned char)right_motor;
     ca4:	60 93 2a 01 	sts	0x012A, r22
}
     ca8:	08 95       	ret

00000caa <motion_set>:
void motion_set (unsigned char Direction)
{
	unsigned char PortARestore = 0;

	Direction &= 0x0F; 		// removing upper nibbel for the protection
	PortARestore = PORTA; 		// reading the PORTA original status
     caa:	92 b1       	in	r25, 0x02	; 2
	PortARestore &= 0xF0; 		// making lower direction nibbel to 0
     cac:	90 7f       	andi	r25, 0xF0	; 240
//Function used for setting motor's direction
void motion_set (unsigned char Direction)
{
	unsigned char PortARestore = 0;

	Direction &= 0x0F; 		// removing upper nibbel for the protection
     cae:	8f 70       	andi	r24, 0x0F	; 15
	PortARestore = PORTA; 		// reading the PORTA original status
	PortARestore &= 0xF0; 		// making lower direction nibbel to 0
	PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
     cb0:	98 2b       	or	r25, r24
	PORTA = PortARestore; 		// executing the command
     cb2:	92 b9       	out	0x02, r25	; 2
}
     cb4:	08 95       	ret

00000cb6 <buzzer_on>:
void buzzer_on (void)
{
	unsigned char port_restore = 0;
	port_restore = PINC;
     cb6:	86 b1       	in	r24, 0x06	; 6
	port_restore = port_restore | 0x08;
     cb8:	88 60       	ori	r24, 0x08	; 8
	PORTC = port_restore;
     cba:	88 b9       	out	0x08, r24	; 8
}
     cbc:	08 95       	ret

00000cbe <buzzer_off>:

void buzzer_off (void)
{
	unsigned char port_restore = 0;
	port_restore = PINC;
     cbe:	86 b1       	in	r24, 0x06	; 6
	port_restore = port_restore & 0xF7;
     cc0:	87 7f       	andi	r24, 0xF7	; 247
	PORTC = port_restore;
     cc2:	88 b9       	out	0x08, r24	; 8
}
     cc4:	08 95       	ret

00000cc6 <forward>:

void forward (void) //both wheels forward
{
	motion_set(0x06);
     cc6:	86 e0       	ldi	r24, 0x06	; 6
     cc8:	0e 94 55 06 	call	0xcaa	; 0xcaa <motion_set>
}
     ccc:	08 95       	ret

00000cce <back>:

void back (void) //both wheels backward
{
	motion_set(0x09);
     cce:	89 e0       	ldi	r24, 0x09	; 9
     cd0:	0e 94 55 06 	call	0xcaa	; 0xcaa <motion_set>
}
     cd4:	08 95       	ret

00000cd6 <left>:

void left (void) //Left wheel backward, Right wheel forward
{
	motion_set(0x05);
     cd6:	85 e0       	ldi	r24, 0x05	; 5
     cd8:	0e 94 55 06 	call	0xcaa	; 0xcaa <motion_set>
}
     cdc:	08 95       	ret

00000cde <right>:

void right (void) //Left wheel forward, Right wheel backward
{
	motion_set(0x0A);
     cde:	8a e0       	ldi	r24, 0x0A	; 10
     ce0:	0e 94 55 06 	call	0xcaa	; 0xcaa <motion_set>
}
     ce4:	08 95       	ret

00000ce6 <soft_left>:

void soft_left (void) //Left wheel stationary, Right wheel forward
{
	motion_set(0x04);
     ce6:	84 e0       	ldi	r24, 0x04	; 4
     ce8:	0e 94 55 06 	call	0xcaa	; 0xcaa <motion_set>
}
     cec:	08 95       	ret

00000cee <soft_right>:

void soft_right (void) //Left wheel forward, Right wheel is stationary
{
	motion_set(0x02);
     cee:	82 e0       	ldi	r24, 0x02	; 2
     cf0:	0e 94 55 06 	call	0xcaa	; 0xcaa <motion_set>
}
     cf4:	08 95       	ret

00000cf6 <soft_left_2>:

void soft_left_2 (void) //Left wheel backward, right wheel stationary
{
	motion_set(0x01);
     cf6:	81 e0       	ldi	r24, 0x01	; 1
     cf8:	0e 94 55 06 	call	0xcaa	; 0xcaa <motion_set>
}
     cfc:	08 95       	ret

00000cfe <soft_right_2>:

void soft_right_2 (void) //Left wheel stationary, Right wheel backward
{
	motion_set(0x08);
     cfe:	88 e0       	ldi	r24, 0x08	; 8
     d00:	0e 94 55 06 	call	0xcaa	; 0xcaa <motion_set>
}
     d04:	08 95       	ret

00000d06 <stop>:

void stop (void)
{
	motion_set(0x00);
     d06:	80 e0       	ldi	r24, 0x00	; 0
     d08:	0e 94 55 06 	call	0xcaa	; 0xcaa <motion_set>
}
     d0c:	08 95       	ret

00000d0e <Sharp_GP2D12_estimation>:


unsigned int Sharp_GP2D12_estimation(unsigned char adc_reading)
{
     d0e:	0f 93       	push	r16
     d10:	1f 93       	push	r17
	float distance;
	unsigned int distanceInt;
	distance = (int)(10.00*(2799.6*(1.00/(pow(adc_reading,1.1546)))));
     d12:	68 2f       	mov	r22, r24
     d14:	70 e0       	ldi	r23, 0x00	; 0
     d16:	80 e0       	ldi	r24, 0x00	; 0
     d18:	90 e0       	ldi	r25, 0x00	; 0
     d1a:	0e 94 44 0f 	call	0x1e88	; 0x1e88 <__floatunsisf>
     d1e:	2f ee       	ldi	r18, 0xEF	; 239
     d20:	39 ec       	ldi	r19, 0xC9	; 201
     d22:	43 e9       	ldi	r20, 0x93	; 147
     d24:	5f e3       	ldi	r21, 0x3F	; 63
     d26:	0e 94 35 10 	call	0x206a	; 0x206a <pow>
     d2a:	b6 2f       	mov	r27, r22
     d2c:	a7 2f       	mov	r26, r23
     d2e:	38 2f       	mov	r19, r24
     d30:	29 2f       	mov	r18, r25
     d32:	60 e0       	ldi	r22, 0x00	; 0
     d34:	70 e0       	ldi	r23, 0x00	; 0
     d36:	80 e8       	ldi	r24, 0x80	; 128
     d38:	9f e3       	ldi	r25, 0x3F	; 63
     d3a:	42 2f       	mov	r20, r18
     d3c:	0b 2f       	mov	r16, r27
     d3e:	1a 2f       	mov	r17, r26
     d40:	23 2f       	mov	r18, r19
     d42:	34 2f       	mov	r19, r20
     d44:	a9 01       	movw	r20, r18
     d46:	98 01       	movw	r18, r16
     d48:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <__divsf3>
     d4c:	2a e9       	ldi	r18, 0x9A	; 154
     d4e:	39 ef       	ldi	r19, 0xF9	; 249
     d50:	4e e2       	ldi	r20, 0x2E	; 46
     d52:	55 e4       	ldi	r21, 0x45	; 69
     d54:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <__mulsf3>
     d58:	20 e0       	ldi	r18, 0x00	; 0
     d5a:	30 e0       	ldi	r19, 0x00	; 0
     d5c:	40 e2       	ldi	r20, 0x20	; 32
     d5e:	51 e4       	ldi	r21, 0x41	; 65
     d60:	0e 94 d2 0f 	call	0x1fa4	; 0x1fa4 <__mulsf3>
     d64:	0e 94 13 0f 	call	0x1e26	; 0x1e26 <__fixsfsi>
     d68:	88 27       	eor	r24, r24
     d6a:	77 fd       	sbrc	r23, 7
     d6c:	80 95       	com	r24
     d6e:	98 2f       	mov	r25, r24
     d70:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <__floatsisf>
	distanceInt = (int)distance;
     d74:	0e 94 13 0f 	call	0x1e26	; 0x1e26 <__fixsfsi>
	if(distanceInt>800)
	{
		distanceInt=800;
	}
	return distanceInt;
     d78:	86 2f       	mov	r24, r22
     d7a:	97 2f       	mov	r25, r23
     d7c:	23 e0       	ldi	r18, 0x03	; 3
     d7e:	81 32       	cpi	r24, 0x21	; 33
     d80:	92 07       	cpc	r25, r18
     d82:	10 f0       	brcs	.+4      	; 0xd88 <Sharp_GP2D12_estimation+0x7a>
     d84:	80 e2       	ldi	r24, 0x20	; 32
     d86:	93 e0       	ldi	r25, 0x03	; 3
}
     d88:	1f 91       	pop	r17
     d8a:	0f 91       	pop	r16
     d8c:	08 95       	ret

00000d8e <angle_rotate>:
//Function used for turning robot by specified degrees
void angle_rotate(unsigned int Degrees)
{
     d8e:	0f 93       	push	r16
     d90:	1f 93       	push	r17
     d92:	cf 93       	push	r28
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;

	ReqdShaftCount = (float) Degrees/ 4.090; // division by resolution to get shaft count
     d94:	bc 01       	movw	r22, r24
     d96:	80 e0       	ldi	r24, 0x00	; 0
     d98:	90 e0       	ldi	r25, 0x00	; 0
     d9a:	0e 94 44 0f 	call	0x1e88	; 0x1e88 <__floatunsisf>
     d9e:	28 e4       	ldi	r18, 0x48	; 72
     da0:	31 ee       	ldi	r19, 0xE1	; 225
     da2:	42 e8       	ldi	r20, 0x82	; 130
     da4:	50 e4       	ldi	r21, 0x40	; 64
     da6:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <__divsf3>
	ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
     daa:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <__fixunssfsi>
     dae:	dc 01       	movw	r26, r24
     db0:	cb 01       	movw	r24, r22
     db2:	a0 e0       	ldi	r26, 0x00	; 0
     db4:	b0 e0       	ldi	r27, 0x00	; 0
	ShaftCountRight = 0;
     db6:	10 92 de 04 	sts	0x04DE, r1
     dba:	10 92 df 04 	sts	0x04DF, r1
     dbe:	10 92 e0 04 	sts	0x04E0, r1
     dc2:	10 92 e1 04 	sts	0x04E1, r1
	ShaftCountLeft = 0;
     dc6:	10 92 e2 04 	sts	0x04E2, r1
     dca:	10 92 e3 04 	sts	0x04E3, r1
     dce:	10 92 e4 04 	sts	0x04E4, r1
     dd2:	10 92 e5 04 	sts	0x04E5, r1

	while (1)
	{
		if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
     dd6:	f1 e0       	ldi	r31, 0x01	; 1
     dd8:	c0 e0       	ldi	r28, 0x00	; 0
     dda:	40 91 de 04 	lds	r20, 0x04DE
     dde:	50 91 df 04 	lds	r21, 0x04DF
     de2:	60 91 e0 04 	lds	r22, 0x04E0
     de6:	70 91 e1 04 	lds	r23, 0x04E1
     dea:	00 91 e2 04 	lds	r16, 0x04E2
     dee:	10 91 e3 04 	lds	r17, 0x04E3
     df2:	20 91 e4 04 	lds	r18, 0x04E4
     df6:	30 91 e5 04 	lds	r19, 0x04E5
     dfa:	ef 2f       	mov	r30, r31
     dfc:	48 17       	cp	r20, r24
     dfe:	59 07       	cpc	r21, r25
     e00:	6a 07       	cpc	r22, r26
     e02:	7b 07       	cpc	r23, r27
     e04:	08 f4       	brcc	.+2      	; 0xe08 <angle_rotate+0x7a>
     e06:	ec 2f       	mov	r30, r28
     e08:	ee 23       	and	r30, r30
     e0a:	49 f4       	brne	.+18     	; 0xe1e <angle_rotate+0x90>
     e0c:	4f 2f       	mov	r20, r31
     e0e:	08 17       	cp	r16, r24
     e10:	19 07       	cpc	r17, r25
     e12:	2a 07       	cpc	r18, r26
     e14:	3b 07       	cpc	r19, r27
     e16:	08 f4       	brcc	.+2      	; 0xe1a <angle_rotate+0x8c>
     e18:	4c 2f       	mov	r20, r28
     e1a:	44 23       	and	r20, r20
     e1c:	f1 f2       	breq	.-68     	; 0xdda <angle_rotate+0x4c>
		break;
	}
	stop(); //Stop robot
     e1e:	0e 94 83 06 	call	0xd06	; 0xd06 <stop>
}
     e22:	cf 91       	pop	r28
     e24:	1f 91       	pop	r17
     e26:	0f 91       	pop	r16
     e28:	08 95       	ret

00000e2a <linear_distance_mm>:
void linear_distance_mm(unsigned int DistanceInMM)
{
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;

	ReqdShaftCount = DistanceInMM / 5.338; // division by resolution to get shaft count
     e2a:	bc 01       	movw	r22, r24
     e2c:	80 e0       	ldi	r24, 0x00	; 0
     e2e:	90 e0       	ldi	r25, 0x00	; 0
     e30:	0e 94 44 0f 	call	0x1e88	; 0x1e88 <__floatunsisf>
     e34:	25 ee       	ldi	r18, 0xE5	; 229
     e36:	30 ed       	ldi	r19, 0xD0	; 208
     e38:	4a ea       	ldi	r20, 0xAA	; 170
     e3a:	50 e4       	ldi	r21, 0x40	; 64
     e3c:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <__divsf3>
	ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
     e40:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <__fixunssfsi>
     e44:	46 2f       	mov	r20, r22
     e46:	57 2f       	mov	r21, r23
     e48:	68 2f       	mov	r22, r24
     e4a:	79 2f       	mov	r23, r25
	
	ShaftCountRight = 0;
     e4c:	10 92 de 04 	sts	0x04DE, r1
     e50:	10 92 df 04 	sts	0x04DF, r1
     e54:	10 92 e0 04 	sts	0x04E0, r1
     e58:	10 92 e1 04 	sts	0x04E1, r1
	while(1)
	{
		if(ShaftCountRight > ReqdShaftCountInt)
     e5c:	80 91 de 04 	lds	r24, 0x04DE
     e60:	90 91 df 04 	lds	r25, 0x04DF
     e64:	a0 91 e0 04 	lds	r26, 0x04E0
     e68:	b0 91 e1 04 	lds	r27, 0x04E1
     e6c:	48 17       	cp	r20, r24
     e6e:	59 07       	cpc	r21, r25
     e70:	6a 07       	cpc	r22, r26
     e72:	7b 07       	cpc	r23, r27
     e74:	98 f7       	brcc	.-26     	; 0xe5c <linear_distance_mm+0x32>
		{
			break;
		}
	}
	stop(); //Stop robot
     e76:	0e 94 83 06 	call	0xd06	; 0xd06 <stop>
}
     e7a:	08 95       	ret

00000e7c <forward_mm>:

void forward_mm(unsigned int DistanceInMM)
{
     e7c:	cf 93       	push	r28
     e7e:	df 93       	push	r29
     e80:	ec 01       	movw	r28, r24
	forward();
     e82:	0e 94 63 06 	call	0xcc6	; 0xcc6 <forward>
	linear_distance_mm(DistanceInMM);
     e86:	ce 01       	movw	r24, r28
     e88:	0e 94 15 07 	call	0xe2a	; 0xe2a <linear_distance_mm>
}
     e8c:	df 91       	pop	r29
     e8e:	cf 91       	pop	r28
     e90:	08 95       	ret

00000e92 <back_mm>:

void back_mm(unsigned int DistanceInMM)
{
     e92:	cf 93       	push	r28
     e94:	df 93       	push	r29
     e96:	ec 01       	movw	r28, r24
	back();
     e98:	0e 94 67 06 	call	0xcce	; 0xcce <back>
	linear_distance_mm(DistanceInMM);
     e9c:	ce 01       	movw	r24, r28
     e9e:	0e 94 15 07 	call	0xe2a	; 0xe2a <linear_distance_mm>
}
     ea2:	df 91       	pop	r29
     ea4:	cf 91       	pop	r28
     ea6:	08 95       	ret

00000ea8 <left_degrees>:

void left_degrees(unsigned int Degrees)
{
     ea8:	cf 93       	push	r28
     eaa:	df 93       	push	r29
     eac:	ec 01       	movw	r28, r24
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	left(); //Turn left
     eae:	0e 94 6b 06 	call	0xcd6	; 0xcd6 <left>
	angle_rotate(Degrees);
     eb2:	ce 01       	movw	r24, r28
     eb4:	0e 94 c7 06 	call	0xd8e	; 0xd8e <angle_rotate>
}
     eb8:	df 91       	pop	r29
     eba:	cf 91       	pop	r28
     ebc:	08 95       	ret

00000ebe <right_degrees>:



void right_degrees(unsigned int Degrees)
{
     ebe:	cf 93       	push	r28
     ec0:	df 93       	push	r29
     ec2:	ec 01       	movw	r28, r24
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	right(); //Turn right
     ec4:	0e 94 6f 06 	call	0xcde	; 0xcde <right>
	angle_rotate(Degrees);
     ec8:	ce 01       	movw	r24, r28
     eca:	0e 94 c7 06 	call	0xd8e	; 0xd8e <angle_rotate>
}
     ece:	df 91       	pop	r29
     ed0:	cf 91       	pop	r28
     ed2:	08 95       	ret

00000ed4 <soft_left_degrees>:


void soft_left_degrees(unsigned int Degrees)
{
     ed4:	cf 93       	push	r28
     ed6:	df 93       	push	r29
     ed8:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_left(); //Turn soft left
     eda:	0e 94 73 06 	call	0xce6	; 0xce6 <soft_left>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     ede:	ce 01       	movw	r24, r28
     ee0:	88 0f       	add	r24, r24
     ee2:	99 1f       	adc	r25, r25
     ee4:	0e 94 c7 06 	call	0xd8e	; 0xd8e <angle_rotate>
}
     ee8:	df 91       	pop	r29
     eea:	cf 91       	pop	r28
     eec:	08 95       	ret

00000eee <soft_right_degrees>:

void soft_right_degrees(unsigned int Degrees)
{
     eee:	cf 93       	push	r28
     ef0:	df 93       	push	r29
     ef2:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_right();  //Turn soft right
     ef4:	0e 94 77 06 	call	0xcee	; 0xcee <soft_right>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     ef8:	ce 01       	movw	r24, r28
     efa:	88 0f       	add	r24, r24
     efc:	99 1f       	adc	r25, r25
     efe:	0e 94 c7 06 	call	0xd8e	; 0xd8e <angle_rotate>
}
     f02:	df 91       	pop	r29
     f04:	cf 91       	pop	r28
     f06:	08 95       	ret

00000f08 <soft_left_2_degrees>:

void soft_left_2_degrees(unsigned int Degrees)
{
     f08:	cf 93       	push	r28
     f0a:	df 93       	push	r29
     f0c:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_left_2(); //Turn reverse soft left
     f0e:	0e 94 7b 06 	call	0xcf6	; 0xcf6 <soft_left_2>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     f12:	ce 01       	movw	r24, r28
     f14:	88 0f       	add	r24, r24
     f16:	99 1f       	adc	r25, r25
     f18:	0e 94 c7 06 	call	0xd8e	; 0xd8e <angle_rotate>
}
     f1c:	df 91       	pop	r29
     f1e:	cf 91       	pop	r28
     f20:	08 95       	ret

00000f22 <soft_right_2_degrees>:

void soft_right_2_degrees(unsigned int Degrees)
{
     f22:	cf 93       	push	r28
     f24:	df 93       	push	r29
     f26:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_right_2();  //Turn reverse soft right
     f28:	0e 94 7f 06 	call	0xcfe	; 0xcfe <soft_right_2>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     f2c:	ce 01       	movw	r24, r28
     f2e:	88 0f       	add	r24, r24
     f30:	99 1f       	adc	r25, r25
     f32:	0e 94 c7 06 	call	0xd8e	; 0xd8e <angle_rotate>
}
     f36:	df 91       	pop	r29
     f38:	cf 91       	pop	r28
     f3a:	08 95       	ret

00000f3c <left_count>:
*/
void left_count()
{
	while(1)
	{
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
     f3c:	82 e0       	ldi	r24, 0x02	; 2
     f3e:	0e 94 c5 05 	call	0xb8a	; 0xb8a <ADC_Conversion>
     f42:	80 93 99 04 	sts	0x0499, r24
		left(); //Turn left
     f46:	0e 94 6b 06 	call	0xcd6	; 0xcd6 <left>
		velocity(180,180);
     f4a:	84 eb       	ldi	r24, 0xB4	; 180
     f4c:	64 eb       	ldi	r22, 0xB4	; 180
     f4e:	0e 94 50 06 	call	0xca0	; 0xca0 <velocity>
		if(Center_white_line>0x15)
     f52:	80 91 99 04 	lds	r24, 0x0499
     f56:	86 31       	cpi	r24, 0x16	; 22
     f58:	88 f3       	brcs	.-30     	; 0xf3c <left_count>
		return;
	}
	
}
     f5a:	08 95       	ret

00000f5c <timer1_init>:
//prescale:256
// WGM: 7) PWM 10bit fast, TOP=0x03FF
// actual value: 52.25Hz 
void timer1_init(void)
{
 TCCR1B = 0x00; //stop
     f5c:	e1 e8       	ldi	r30, 0x81	; 129
     f5e:	f0 e0       	ldi	r31, 0x00	; 0
     f60:	10 82       	st	Z, r1
 TCNT1H = 0xFC; //Counter high value to which OCR1xH value is to be compared with
     f62:	8c ef       	ldi	r24, 0xFC	; 252
     f64:	80 93 85 00 	sts	0x0085, r24
 TCNT1L = 0x01;	//Counter low value to which OCR1xH value is to be compared with
     f68:	81 e0       	ldi	r24, 0x01	; 1
     f6a:	80 93 84 00 	sts	0x0084, r24
 OCR1AH = 0x03;	//Output compare Register high value for servo 1
     f6e:	93 e0       	ldi	r25, 0x03	; 3
     f70:	90 93 89 00 	sts	0x0089, r25
 OCR1AL = 0xFF;	//Output Compare Register low Value For servo 1
     f74:	8f ef       	ldi	r24, 0xFF	; 255
     f76:	80 93 88 00 	sts	0x0088, r24
 OCR1BH = 0x03;	//Output compare Register high value for servo 2
     f7a:	90 93 8b 00 	sts	0x008B, r25
 OCR1BL = 0xFF;	//Output Compare Register low Value For servo 2
     f7e:	80 93 8a 00 	sts	0x008A, r24
 OCR1CH = 0x03;	//Output compare Register high value for servo 3
     f82:	90 93 8d 00 	sts	0x008D, r25
 OCR1CL = 0xFF;	//Output Compare Register low Value For servo 3
     f86:	80 93 8c 00 	sts	0x008C, r24
 ICR1H  = 0x03;	
     f8a:	90 93 87 00 	sts	0x0087, r25
 ICR1L  = 0xFF;
     f8e:	80 93 86 00 	sts	0x0086, r24
 TCCR1A = 0xAB; /*{COM1A1=1, COM1A0=0; COM1B1=1, COM1B0=0; COM1C1=1 COM1C0=0}
     f92:	8b ea       	ldi	r24, 0xAB	; 171
     f94:	80 93 80 00 	sts	0x0080, r24
 					For Overriding normal port functionality to OCRnA outputs.
				  {WGM11=1, WGM10=1} Along With WGM12 in TCCR1B for Selecting FAST PWM Mode*/
 TCCR1C = 0x00;
     f98:	10 92 82 00 	sts	0x0082, r1
 TCCR1B = 0x0C; //WGM12=1; CS12=1, CS11=0, CS10=0 (Prescaler=256)
     f9c:	8c e0       	ldi	r24, 0x0C	; 12
     f9e:	80 83       	st	Z, r24
}
     fa0:	08 95       	ret

00000fa2 <servo_1>:
//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
	OCR1AH = 0x00;
     fa2:	10 92 89 00 	sts	0x0089, r1

//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
     fa6:	68 2f       	mov	r22, r24
     fa8:	70 e0       	ldi	r23, 0x00	; 0
     faa:	80 e0       	ldi	r24, 0x00	; 0
     fac:	90 e0       	ldi	r25, 0x00	; 0
     fae:	0e 94 44 0f 	call	0x1e88	; 0x1e88 <__floatunsisf>
     fb2:	2b e7       	ldi	r18, 0x7B	; 123
     fb4:	34 e1       	ldi	r19, 0x14	; 20
     fb6:	4e ee       	ldi	r20, 0xEE	; 238
     fb8:	5f e3       	ldi	r21, 0x3F	; 63
     fba:	0e 94 ab 0e 	call	0x1d56	; 0x1d56 <__divsf3>
     fbe:	20 e0       	ldi	r18, 0x00	; 0
     fc0:	30 e0       	ldi	r19, 0x00	; 0
     fc2:	4c e0       	ldi	r20, 0x0C	; 12
     fc4:	52 e4       	ldi	r21, 0x42	; 66
     fc6:	0e 94 47 0e 	call	0x1c8e	; 0x1c8e <__addsf3>
	OCR1AH = 0x00;
	OCR1AL = (unsigned char) PositionPanServo;
     fca:	0e 94 18 0f 	call	0x1e30	; 0x1e30 <__fixunssfsi>
     fce:	60 93 88 00 	sts	0x0088, r22
}
     fd2:	08 95       	ret

00000fd4 <servo_1_rest>:
Logic:		  -
Example Call: servo_1_rest();
*/
void servo_1_rest (void) //makes servo 1 free rotating
{
	servo_1(0);
     fd4:	80 e0       	ldi	r24, 0x00	; 0
     fd6:	0e 94 d1 07 	call	0xfa2	; 0xfa2 <servo_1>
}
     fda:	08 95       	ret

00000fdc <servo_1_free>:
//and make them free by giving 100% duty cycle at the PWM. This function can be used to
//reduce the power consumption of the motor if it is holding load against the gravity.

void servo_1_free (void) //makes servo 1 free rotating
{
	OCR1AH = 0x03;
     fdc:	83 e0       	ldi	r24, 0x03	; 3
     fde:	80 93 89 00 	sts	0x0089, r24
	OCR1AL = 0xFF; //Servo 1 off
     fe2:	8f ef       	ldi	r24, 0xFF	; 255
     fe4:	80 93 88 00 	sts	0x0088, r24
}
     fe8:	08 95       	ret

00000fea <right_count>:

void right_count()
{
	while(1)
	{
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
     fea:	82 e0       	ldi	r24, 0x02	; 2
     fec:	0e 94 c5 05 	call	0xb8a	; 0xb8a <ADC_Conversion>
     ff0:	80 93 99 04 	sts	0x0499, r24
		right(); //Turn right
     ff4:	0e 94 6f 06 	call	0xcde	; 0xcde <right>
		velocity(180,180);
     ff8:	84 eb       	ldi	r24, 0xB4	; 180
     ffa:	64 eb       	ldi	r22, 0xB4	; 180
     ffc:	0e 94 50 06 	call	0xca0	; 0xca0 <velocity>
		if(Center_white_line>0x15)
    1000:	80 91 99 04 	lds	r24, 0x0499
    1004:	86 31       	cpi	r24, 0x16	; 22
    1006:	88 f3       	brcs	.-30     	; 0xfea <right_count>
		return;
	}
	
}
    1008:	08 95       	ret

0000100a <align>:
Logic:		  bot looks for black line while turning right and stops as soon as it identifies the black line and do this for other direction as well
Example Call: align();
*/
int align()
{
	velocity(180,180);
    100a:	84 eb       	ldi	r24, 0xB4	; 180
    100c:	64 eb       	ldi	r22, 0xB4	; 180
    100e:	0e 94 50 06 	call	0xca0	; 0xca0 <velocity>
	right_degrees(15);
    1012:	8f e0       	ldi	r24, 0x0F	; 15
    1014:	90 e0       	ldi	r25, 0x00	; 0
    1016:	0e 94 5f 07 	call	0xebe	; 0xebe <right_degrees>
	left_count();
    101a:	0e 94 9e 07 	call	0xf3c	; 0xf3c <left_count>
	velocity(180,180);
    101e:	84 eb       	ldi	r24, 0xB4	; 180
    1020:	64 eb       	ldi	r22, 0xB4	; 180
    1022:	0e 94 50 06 	call	0xca0	; 0xca0 <velocity>
	left_degrees(15);
    1026:	8f e0       	ldi	r24, 0x0F	; 15
    1028:	90 e0       	ldi	r25, 0x00	; 0
    102a:	0e 94 54 07 	call	0xea8	; 0xea8 <left_degrees>
	right_count();
    102e:	0e 94 f5 07 	call	0xfea	; 0xfea <right_count>
	
	
}
    1032:	08 95       	ret

00001034 <makeitright>:
Output :      bot faces in the direction it need to travel in the next dijkstra's run
Logic:		  since there are four direction bot can face so sum of all previous turn tells which direction bot is facing now and accordingly turns itself in the next deisred direction
Example Call: makeitright(sum);
*/
void makeitright(int x)
{
    1034:	cf 93       	push	r28
    1036:	df 93       	push	r29
	int a=4-(x%4);
    1038:	24 e0       	ldi	r18, 0x04	; 4
    103a:	30 e0       	ldi	r19, 0x00	; 0
    103c:	b9 01       	movw	r22, r18
    103e:	0e 94 ae 11 	call	0x235c	; 0x235c <__divmodhi4>
    1042:	e9 01       	movw	r28, r18
    1044:	c8 1b       	sub	r28, r24
    1046:	d9 0b       	sbc	r29, r25
	if((a+path[0])%4==0)
    1048:	80 91 e8 04 	lds	r24, 0x04E8
    104c:	90 91 e9 04 	lds	r25, 0x04E9
    1050:	8c 0f       	add	r24, r28
    1052:	9d 1f       	adc	r25, r29
    1054:	9c 01       	movw	r18, r24
    1056:	23 70       	andi	r18, 0x03	; 3
    1058:	30 70       	andi	r19, 0x00	; 0
    105a:	21 15       	cp	r18, r1
    105c:	31 05       	cpc	r19, r1
    105e:	61 f4       	brne	.+24     	; 0x1078 <makeitright+0x44>
    1060:	8f ef       	ldi	r24, 0xFF	; 255
    1062:	9f e7       	ldi	r25, 0x7F	; 127
    1064:	a4 e0       	ldi	r26, 0x04	; 4
    1066:	81 50       	subi	r24, 0x01	; 1
    1068:	90 40       	sbci	r25, 0x00	; 0
    106a:	a0 40       	sbci	r26, 0x00	; 0
    106c:	e1 f7       	brne	.-8      	; 0x1066 <makeitright+0x32>
    106e:	00 c0       	rjmp	.+0      	; 0x1070 <makeitright+0x3c>
    1070:	00 00       	nop
	{
		_delay_ms(100);
		align();
    1072:	0e 94 05 08 	call	0x100a	; 0x100a <align>
    1076:	2d c0       	rjmp	.+90     	; 0x10d2 <makeitright+0x9e>
	}
	else if((a+path[0])%4==2)//it is back
    1078:	64 e0       	ldi	r22, 0x04	; 4
    107a:	70 e0       	ldi	r23, 0x00	; 0
    107c:	0e 94 ae 11 	call	0x235c	; 0x235c <__divmodhi4>
    1080:	82 30       	cpi	r24, 0x02	; 2
    1082:	91 05       	cpc	r25, r1
    1084:	91 f4       	brne	.+36     	; 0x10aa <makeitright+0x76>
	{
		
		right_degrees(150); //Rotate robot right by 90 degrees
    1086:	86 e9       	ldi	r24, 0x96	; 150
    1088:	90 e0       	ldi	r25, 0x00	; 0
    108a:	0e 94 5f 07 	call	0xebe	; 0xebe <right_degrees>
		right_count(); //Rotate robot right by 90 degrees
    108e:	0e 94 f5 07 	call	0xfea	; 0xfea <right_count>
    1092:	8f ef       	ldi	r24, 0xFF	; 255
    1094:	9f e7       	ldi	r25, 0x7F	; 127
    1096:	a4 e0       	ldi	r26, 0x04	; 4
    1098:	81 50       	subi	r24, 0x01	; 1
    109a:	90 40       	sbci	r25, 0x00	; 0
    109c:	a0 40       	sbci	r26, 0x00	; 0
    109e:	e1 f7       	brne	.-8      	; 0x1098 <makeitright+0x64>
    10a0:	00 c0       	rjmp	.+0      	; 0x10a2 <makeitright+0x6e>
    10a2:	00 00       	nop
		_delay_ms(100);
		align();
    10a4:	0e 94 05 08 	call	0x100a	; 0x100a <align>
    10a8:	14 c0       	rjmp	.+40     	; 0x10d2 <makeitright+0x9e>
	}
	else if((a+path[0])%4==3)//it is right
    10aa:	83 30       	cpi	r24, 0x03	; 3
    10ac:	91 05       	cpc	r25, r1
    10ae:	89 f4       	brne	.+34     	; 0x10d2 <makeitright+0x9e>
	{
		right_degrees(45); //Rotate robot right by 90 degrees
    10b0:	8d e2       	ldi	r24, 0x2D	; 45
    10b2:	90 e0       	ldi	r25, 0x00	; 0
    10b4:	0e 94 5f 07 	call	0xebe	; 0xebe <right_degrees>
		right_count(); //Rotate robot right by 90 degrees
    10b8:	0e 94 f5 07 	call	0xfea	; 0xfea <right_count>
    10bc:	8f ef       	ldi	r24, 0xFF	; 255
    10be:	9f e7       	ldi	r25, 0x7F	; 127
    10c0:	a4 e0       	ldi	r26, 0x04	; 4
    10c2:	81 50       	subi	r24, 0x01	; 1
    10c4:	90 40       	sbci	r25, 0x00	; 0
    10c6:	a0 40       	sbci	r26, 0x00	; 0
    10c8:	e1 f7       	brne	.-8      	; 0x10c2 <makeitright+0x8e>
    10ca:	00 c0       	rjmp	.+0      	; 0x10cc <makeitright+0x98>
    10cc:	00 00       	nop
		_delay_ms(100);
		align();
    10ce:	0e 94 05 08 	call	0x100a	; 0x100a <align>
	}
	if((a+path[0])%4==1)//it is left
    10d2:	80 91 e8 04 	lds	r24, 0x04E8
    10d6:	90 91 e9 04 	lds	r25, 0x04E9
    10da:	8c 0f       	add	r24, r28
    10dc:	9d 1f       	adc	r25, r29
    10de:	64 e0       	ldi	r22, 0x04	; 4
    10e0:	70 e0       	ldi	r23, 0x00	; 0
    10e2:	0e 94 ae 11 	call	0x235c	; 0x235c <__divmodhi4>
    10e6:	81 30       	cpi	r24, 0x01	; 1
    10e8:	91 05       	cpc	r25, r1
    10ea:	89 f4       	brne	.+34     	; 0x110e <makeitright+0xda>
	{
		left_degrees(45); //Rotate robot left by 90 degrees
    10ec:	8d e2       	ldi	r24, 0x2D	; 45
    10ee:	90 e0       	ldi	r25, 0x00	; 0
    10f0:	0e 94 54 07 	call	0xea8	; 0xea8 <left_degrees>
		left_count(); //Rotate robot right by 90 degrees
    10f4:	0e 94 9e 07 	call	0xf3c	; 0xf3c <left_count>
    10f8:	8f ef       	ldi	r24, 0xFF	; 255
    10fa:	9f e7       	ldi	r25, 0x7F	; 127
    10fc:	a4 e0       	ldi	r26, 0x04	; 4
    10fe:	81 50       	subi	r24, 0x01	; 1
    1100:	90 40       	sbci	r25, 0x00	; 0
    1102:	a0 40       	sbci	r26, 0x00	; 0
    1104:	e1 f7       	brne	.-8      	; 0x10fe <makeitright+0xca>
    1106:	00 c0       	rjmp	.+0      	; 0x1108 <makeitright+0xd4>
    1108:	00 00       	nop
		_delay_ms(100);
		align();
    110a:	0e 94 05 08 	call	0x100a	; 0x100a <align>
	}
	
}
    110e:	df 91       	pop	r29
    1110:	cf 91       	pop	r28
    1112:	08 95       	ret

00001114 <init_devices>:


//Function to initialize all the devices
void init_devices()
{
	cli(); //Clears the global interrupt
    1114:	f8 94       	cli
	port_init();  //Initializes all the ports
    1116:	0e 94 8c 05 	call	0xb18	; 0xb18 <port_init>
	adc_init();
    111a:	0e 94 b8 05 	call	0xb70	; 0xb70 <adc_init>
	timer5_init();
    111e:	0e 94 9d 05 	call	0xb3a	; 0xb3a <timer5_init>
	timer1_init();
    1122:	0e 94 ae 07 	call	0xf5c	; 0xf5c <timer1_init>
	//color_sensor_pin_interrupt_init();
	uart0_init(); //Initailize UART0 for serial communiaction
    1126:	0e 94 2c 05 	call	0xa58	; 0xa58 <uart0_init>
	uart2_init(); //Initailize UART1 for serial communiaction
    112a:	0e 94 3c 05 	call	0xa78	; 0xa78 <uart2_init>
	left_position_encoder_interrupt_init();
    112e:	0e 94 f4 05 	call	0xbe8	; 0xbe8 <left_position_encoder_interrupt_init>
	right_position_encoder_interrupt_init();
    1132:	0e 94 fd 05 	call	0xbfa	; 0xbfa <right_position_encoder_interrupt_init>
	sei();   // Enables the global interrupt
    1136:	78 94       	sei
}
    1138:	08 95       	ret

0000113a <travel>:
Output :      1(successful traversing), current node number(where the path was obstructed by debris)
Logic:		  bot finds the path to destination by dijkstra algo and decide the turns it need to take while traversing arena
Example Call: travel(49,85);
*/
int travel(int s,int d)
{
    113a:	6f 92       	push	r6
    113c:	7f 92       	push	r7
    113e:	8f 92       	push	r8
    1140:	9f 92       	push	r9
    1142:	af 92       	push	r10
    1144:	bf 92       	push	r11
    1146:	cf 92       	push	r12
    1148:	df 92       	push	r13
    114a:	ef 92       	push	r14
    114c:	ff 92       	push	r15
    114e:	0f 93       	push	r16
    1150:	1f 93       	push	r17
    1152:	cf 93       	push	r28
    1154:	df 93       	push	r29
    1156:	8c 01       	movw	r16, r24
	int count=0,current,j=0,flag;
	shortest_path(s,d);
    1158:	0e 94 e5 02 	call	0x5ca	; 0x5ca <shortest_path>
	makeitright(x);
    115c:	80 91 9e 04 	lds	r24, 0x049E
    1160:	90 91 9f 04 	lds	r25, 0x049F
    1164:	0e 94 1a 08 	call	0x1034	; 0x1034 <makeitright>
	if(x!=0)
    1168:	20 91 9e 04 	lds	r18, 0x049E
    116c:	30 91 9f 04 	lds	r19, 0x049F
	{
		count++;
	}
	x=path[0];
    1170:	80 91 e8 04 	lds	r24, 0x04E8
    1174:	90 91 e9 04 	lds	r25, 0x04E9
    1178:	90 93 9f 04 	sts	0x049F, r25
    117c:	80 93 9e 04 	sts	0x049E, r24
	if(s==90)
    1180:	0a 35       	cpi	r16, 0x5A	; 90
    1182:	11 05       	cpc	r17, r1
    1184:	41 f0       	breq	.+16     	; 0x1196 <travel+0x5c>
Logic:		  bot finds the path to destination by dijkstra algo and decide the turns it need to take while traversing arena
Example Call: travel(49,85);
*/
int travel(int s,int d)
{
	int count=0,current,j=0,flag;
    1186:	01 e0       	ldi	r16, 0x01	; 1
    1188:	10 e0       	ldi	r17, 0x00	; 0
    118a:	21 15       	cp	r18, r1
    118c:	31 05       	cpc	r19, r1
    118e:	59 f4       	brne	.+22     	; 0x11a6 <travel+0x6c>
    1190:	00 e0       	ldi	r16, 0x00	; 0
    1192:	10 e0       	ldi	r17, 0x00	; 0
    1194:	08 c0       	rjmp	.+16     	; 0x11a6 <travel+0x6c>
		count++;
	}
	x=path[0];
	if(s==90)
	{
		path[0]=4;
    1196:	84 e0       	ldi	r24, 0x04	; 4
    1198:	90 e0       	ldi	r25, 0x00	; 0
    119a:	90 93 e9 04 	sts	0x04E9, r25
    119e:	80 93 e8 04 	sts	0x04E8, r24
		count=1;
    11a2:	01 e0       	ldi	r16, 0x01	; 1
    11a4:	10 e0       	ldi	r17, 0x00	; 0
		}
		else if((Center_white_line>0x15 && Left_white_line>0x15 && Right_white_line>0x15)||(Center_white_line>0x15 && Left_white_line>0x15 && Right_white_line<0x15)||(Center_white_line>0x15 && Left_white_line<0x15 && Right_white_line>0x15))
		{
			flag=4;
			
			lcd_print(2,9,original[count],2);
    11a6:	0f 2e       	mov	r0, r31
    11a8:	ff e7       	ldi	r31, 0x7F	; 127
    11aa:	ef 2e       	mov	r14, r31
    11ac:	fa e0       	ldi	r31, 0x0A	; 10
    11ae:	ff 2e       	mov	r15, r31
    11b0:	f0 2d       	mov	r31, r0
			if(path[count]==1)//it is left
    11b2:	0f 2e       	mov	r0, r31
    11b4:	f8 ee       	ldi	r31, 0xE8	; 232
    11b6:	cf 2e       	mov	r12, r31
    11b8:	f4 e0       	ldi	r31, 0x04	; 4
    11ba:	df 2e       	mov	r13, r31
    11bc:	f0 2d       	mov	r31, r0
			forward();
			velocity(250,170);
		}
		else if((Center_white_line>0x15 && Left_white_line>0x15 && Right_white_line>0x15)||(Center_white_line>0x15 && Left_white_line>0x15 && Right_white_line<0x15)||(Center_white_line>0x15 && Left_white_line<0x15 && Right_white_line>0x15))
		{
			flag=4;
    11be:	aa 24       	eor	r10, r10
    11c0:	bb 24       	eor	r11, r11
    11c2:	68 94       	set
    11c4:	a2 f8       	bld	r10, 2
			forward();
			velocity(170,250);
		}
		else if(Center_white_line<0x15 && Left_white_line<0x15 && Right_white_line>0x15)//right sensed color is black
		{
			flag=3;
    11c6:	0f 2e       	mov	r0, r31
    11c8:	f3 e0       	ldi	r31, 0x03	; 3
    11ca:	6f 2e       	mov	r6, r31
    11cc:	77 24       	eor	r7, r7
    11ce:	f0 2d       	mov	r31, r0
		}
		else if(Center_white_line>0x15 && Left_white_line<0x15 && Right_white_line<0x15)//center sensed color is black
		{
			forward();
			velocity(250,250);
			flag=1;
    11d0:	88 24       	eor	r8, r8
    11d2:	99 24       	eor	r9, r9
    11d4:	83 94       	inc	r8
	
	while(1)
	{
		
		
		Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
    11d6:	83 e0       	ldi	r24, 0x03	; 3
    11d8:	0e 94 c5 05 	call	0xb8a	; 0xb8a <ADC_Conversion>
    11dc:	80 93 9a 04 	sts	0x049A, r24
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
    11e0:	82 e0       	ldi	r24, 0x02	; 2
    11e2:	0e 94 c5 05 	call	0xb8a	; 0xb8a <ADC_Conversion>
    11e6:	80 93 99 04 	sts	0x0499, r24
		Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor
    11ea:	81 e0       	ldi	r24, 0x01	; 1
    11ec:	0e 94 c5 05 	call	0xb8a	; 0xb8a <ADC_Conversion>
    11f0:	80 93 98 04 	sts	0x0498, r24
		sharp = ADC_Conversion(11);						//Stores the Analog value of front sharp connected to ADC channel 11 into variable "sharp"
    11f4:	8b e0       	ldi	r24, 0x0B	; 11
    11f6:	0e 94 c5 05 	call	0xb8a	; 0xb8a <ADC_Conversion>
    11fa:	80 93 0f 0c 	sts	0x0C0F, r24
		value = Sharp_GP2D12_estimation(sharp);				//Stores Distance calsulated in a variable "value".
    11fe:	0e 94 87 06 	call	0xd0e	; 0xd0e <Sharp_GP2D12_estimation>
    1202:	90 93 19 0c 	sts	0x0C19, r25
    1206:	80 93 18 0c 	sts	0x0C18, r24
		if(value>80 && value<130)
    120a:	81 55       	subi	r24, 0x51	; 81
    120c:	90 40       	sbci	r25, 0x00	; 0
    120e:	81 33       	cpi	r24, 0x31	; 49
    1210:	91 05       	cpc	r25, r1
    1212:	c8 f5       	brcc	.+114    	; 0x1286 <travel+0x14c>
		{
			stop();
    1214:	0e 94 83 06 	call	0xd06	; 0xd06 <stop>
    1218:	8f ef       	ldi	r24, 0xFF	; 255
    121a:	9f ef       	ldi	r25, 0xFF	; 255
    121c:	ac e2       	ldi	r26, 0x2C	; 44
    121e:	81 50       	subi	r24, 0x01	; 1
    1220:	90 40       	sbci	r25, 0x00	; 0
    1222:	a0 40       	sbci	r26, 0x00	; 0
    1224:	e1 f7       	brne	.-8      	; 0x121e <travel+0xe4>
    1226:	00 c0       	rjmp	.+0      	; 0x1228 <travel+0xee>
    1228:	00 00       	nop
			_delay_ms(1000);
			//lcd_print(1,5,original[count],2);
			rem(original[count]);
    122a:	0f 2e       	mov	r0, r31
    122c:	ff e7       	ldi	r31, 0x7F	; 127
    122e:	ef 2e       	mov	r14, r31
    1230:	fa e0       	ldi	r31, 0x0A	; 10
    1232:	ff 2e       	mov	r15, r31
    1234:	f0 2d       	mov	r31, r0
    1236:	e8 01       	movw	r28, r16
    1238:	cc 0f       	add	r28, r28
    123a:	dd 1f       	adc	r29, r29
    123c:	ce 0d       	add	r28, r14
    123e:	df 1d       	adc	r29, r15
    1240:	88 81       	ld	r24, Y
    1242:	99 81       	ldd	r25, Y+1	; 0x01
    1244:	0e 94 3a 02 	call	0x474	; 0x474 <rem>
			data=110;
			//lcd_print(1,1,data,3);
			UDR0=data;
    1248:	e6 ec       	ldi	r30, 0xC6	; 198
    124a:	f0 e0       	ldi	r31, 0x00	; 0
    124c:	8e e6       	ldi	r24, 0x6E	; 110
    124e:	80 83       	st	Z, r24
    1250:	8f ef       	ldi	r24, 0xFF	; 255
    1252:	9f e7       	ldi	r25, 0x7F	; 127
    1254:	a4 e0       	ldi	r26, 0x04	; 4
    1256:	81 50       	subi	r24, 0x01	; 1
    1258:	90 40       	sbci	r25, 0x00	; 0
    125a:	a0 40       	sbci	r26, 0x00	; 0
    125c:	e1 f7       	brne	.-8      	; 0x1256 <travel+0x11c>
    125e:	00 c0       	rjmp	.+0      	; 0x1260 <travel+0x126>
    1260:	00 00       	nop
			_delay_ms(100);
			data=original[count];
    1262:	88 81       	ld	r24, Y
    1264:	99 81       	ldd	r25, Y+1	; 0x01
    1266:	80 93 6b 0a 	sts	0x0A6B, r24
    126a:	90 93 6c 0a 	sts	0x0A6C, r25
			//lcd_print(1,1,data,3);
			UDR0=data;
    126e:	80 83       	st	Z, r24
			current=original[count-1];
    1270:	01 50       	subi	r16, 0x01	; 1
    1272:	10 40       	sbci	r17, 0x00	; 0
    1274:	00 0f       	add	r16, r16
    1276:	11 1f       	adc	r17, r17
    1278:	e0 0e       	add	r14, r16
    127a:	f1 1e       	adc	r15, r17
    127c:	d7 01       	movw	r26, r14
    127e:	8d 91       	ld	r24, X+
    1280:	9c 91       	ld	r25, X
    1282:	11 97       	sbiw	r26, 0x01	; 1
			//lcd_print(1,8,original[count-1],2);
			return current;
    1284:	11 c1       	rjmp	.+546    	; 0x14a8 <travel+0x36e>
		}
		if(Center_white_line<0x15 && Left_white_line<0x15 && Right_white_line<0x15)// all white
    1286:	80 91 99 04 	lds	r24, 0x0499
    128a:	85 31       	cpi	r24, 0x15	; 21
    128c:	88 f5       	brcc	.+98     	; 0x12f0 <travel+0x1b6>
    128e:	90 91 9a 04 	lds	r25, 0x049A
    1292:	95 31       	cpi	r25, 0x15	; 21
    1294:	68 f5       	brcc	.+90     	; 0x12f0 <travel+0x1b6>
    1296:	90 91 98 04 	lds	r25, 0x0498
    129a:	95 31       	cpi	r25, 0x15	; 21
    129c:	48 f5       	brcc	.+82     	; 0x12f0 <travel+0x1b6>
		{
			if (flag==1)
    129e:	c1 30       	cpi	r28, 0x01	; 1
    12a0:	d1 05       	cpc	r29, r1
    12a2:	39 f4       	brne	.+14     	; 0x12b2 <travel+0x178>
			{
				forward();
    12a4:	0e 94 63 06 	call	0xcc6	; 0xcc6 <forward>
				velocity(200,200);
    12a8:	88 ec       	ldi	r24, 0xC8	; 200
    12aa:	68 ec       	ldi	r22, 0xC8	; 200
    12ac:	0e 94 50 06 	call	0xca0	; 0xca0 <velocity>
    12b0:	14 c0       	rjmp	.+40     	; 0x12da <travel+0x1a0>
			}
			if (flag==2)
    12b2:	c2 30       	cpi	r28, 0x02	; 2
    12b4:	d1 05       	cpc	r29, r1
    12b6:	39 f4       	brne	.+14     	; 0x12c6 <travel+0x18c>
			{
				forward();
    12b8:	0e 94 63 06 	call	0xcc6	; 0xcc6 <forward>
				velocity(140,200);
    12bc:	8c e8       	ldi	r24, 0x8C	; 140
    12be:	68 ec       	ldi	r22, 0xC8	; 200
    12c0:	0e 94 50 06 	call	0xca0	; 0xca0 <velocity>
    12c4:	88 cf       	rjmp	.-240    	; 0x11d6 <travel+0x9c>
			}
			if (flag==3)
    12c6:	c3 30       	cpi	r28, 0x03	; 3
    12c8:	d1 05       	cpc	r29, r1
    12ca:	39 f4       	brne	.+14     	; 0x12da <travel+0x1a0>
			{
				forward();
    12cc:	0e 94 63 06 	call	0xcc6	; 0xcc6 <forward>
				velocity(200,140);
    12d0:	88 ec       	ldi	r24, 0xC8	; 200
    12d2:	6c e8       	ldi	r22, 0x8C	; 140
    12d4:	0e 94 50 06 	call	0xca0	; 0xca0 <velocity>
    12d8:	7e cf       	rjmp	.-260    	; 0x11d6 <travel+0x9c>
			}
			if(flag==4)
    12da:	c4 30       	cpi	r28, 0x04	; 4
    12dc:	d1 05       	cpc	r29, r1
    12de:	09 f0       	breq	.+2      	; 0x12e2 <travel+0x1a8>
    12e0:	7a cf       	rjmp	.-268    	; 0x11d6 <travel+0x9c>
			{
				forward();
    12e2:	0e 94 63 06 	call	0xcc6	; 0xcc6 <forward>
				velocity(200,200);
    12e6:	88 ec       	ldi	r24, 0xC8	; 200
    12e8:	68 ec       	ldi	r22, 0xC8	; 200
    12ea:	0e 94 50 06 	call	0xca0	; 0xca0 <velocity>
    12ee:	73 cf       	rjmp	.-282    	; 0x11d6 <travel+0x9c>
			}
			
		}
		else if(Center_white_line>0x15 && Left_white_line<0x15 && Right_white_line<0x15)//center sensed color is black
    12f0:	86 31       	cpi	r24, 0x16	; 22
    12f2:	80 f0       	brcs	.+32     	; 0x1314 <travel+0x1da>
    12f4:	90 91 9a 04 	lds	r25, 0x049A
    12f8:	95 31       	cpi	r25, 0x15	; 21
    12fa:	60 f4       	brcc	.+24     	; 0x1314 <travel+0x1da>
    12fc:	90 91 98 04 	lds	r25, 0x0498
    1300:	95 31       	cpi	r25, 0x15	; 21
    1302:	40 f4       	brcc	.+16     	; 0x1314 <travel+0x1da>
		{
			forward();
    1304:	0e 94 63 06 	call	0xcc6	; 0xcc6 <forward>
			velocity(250,250);
    1308:	8a ef       	ldi	r24, 0xFA	; 250
    130a:	6a ef       	ldi	r22, 0xFA	; 250
    130c:	0e 94 50 06 	call	0xca0	; 0xca0 <velocity>
			flag=1;
    1310:	e4 01       	movw	r28, r8
    1312:	61 cf       	rjmp	.-318    	; 0x11d6 <travel+0x9c>
		}
		else if(Center_white_line<0x15 && Left_white_line>0x15 && Right_white_line<0x15)//left sensed color is black
    1314:	85 31       	cpi	r24, 0x15	; 21
    1316:	f8 f4       	brcc	.+62     	; 0x1356 <travel+0x21c>
    1318:	90 91 9a 04 	lds	r25, 0x049A
    131c:	96 31       	cpi	r25, 0x16	; 22
    131e:	68 f0       	brcs	.+26     	; 0x133a <travel+0x200>
    1320:	20 91 98 04 	lds	r18, 0x0498
    1324:	25 31       	cpi	r18, 0x15	; 21
    1326:	48 f4       	brcc	.+18     	; 0x133a <travel+0x200>
		{
			flag=2;
			forward();
    1328:	0e 94 63 06 	call	0xcc6	; 0xcc6 <forward>
			velocity(170,250);
    132c:	8a ea       	ldi	r24, 0xAA	; 170
    132e:	6a ef       	ldi	r22, 0xFA	; 250
    1330:	0e 94 50 06 	call	0xca0	; 0xca0 <velocity>
			velocity(250,250);
			flag=1;
		}
		else if(Center_white_line<0x15 && Left_white_line>0x15 && Right_white_line<0x15)//left sensed color is black
		{
			flag=2;
    1334:	c2 e0       	ldi	r28, 0x02	; 2
    1336:	d0 e0       	ldi	r29, 0x00	; 0
			forward();
			velocity(170,250);
    1338:	4e cf       	rjmp	.-356    	; 0x11d6 <travel+0x9c>
		}
		else if(Center_white_line<0x15 && Left_white_line<0x15 && Right_white_line>0x15)//right sensed color is black
    133a:	95 31       	cpi	r25, 0x15	; 21
    133c:	60 f4       	brcc	.+24     	; 0x1356 <travel+0x21c>
    133e:	90 91 98 04 	lds	r25, 0x0498
    1342:	96 31       	cpi	r25, 0x16	; 22
    1344:	40 f0       	brcs	.+16     	; 0x1356 <travel+0x21c>
		{
			flag=3;
			forward();
    1346:	0e 94 63 06 	call	0xcc6	; 0xcc6 <forward>
			velocity(250,170);
    134a:	8a ef       	ldi	r24, 0xFA	; 250
    134c:	6a ea       	ldi	r22, 0xAA	; 170
    134e:	0e 94 50 06 	call	0xca0	; 0xca0 <velocity>
			forward();
			velocity(170,250);
		}
		else if(Center_white_line<0x15 && Left_white_line<0x15 && Right_white_line>0x15)//right sensed color is black
		{
			flag=3;
    1352:	e3 01       	movw	r28, r6
			forward();
			velocity(250,170);
    1354:	40 cf       	rjmp	.-384    	; 0x11d6 <travel+0x9c>
		}
		else if((Center_white_line>0x15 && Left_white_line>0x15 && Right_white_line>0x15)||(Center_white_line>0x15 && Left_white_line>0x15 && Right_white_line<0x15)||(Center_white_line>0x15 && Left_white_line<0x15 && Right_white_line>0x15))
    1356:	86 31       	cpi	r24, 0x16	; 22
    1358:	08 f4       	brcc	.+2      	; 0x135c <travel+0x222>
    135a:	3d cf       	rjmp	.-390    	; 0x11d6 <travel+0x9c>
    135c:	80 91 9a 04 	lds	r24, 0x049A
    1360:	86 31       	cpi	r24, 0x16	; 22
    1362:	20 f0       	brcs	.+8      	; 0x136c <travel+0x232>
    1364:	90 91 98 04 	lds	r25, 0x0498
    1368:	95 31       	cpi	r25, 0x15	; 21
    136a:	41 f4       	brne	.+16     	; 0x137c <travel+0x242>
    136c:	85 31       	cpi	r24, 0x15	; 21
    136e:	08 f0       	brcs	.+2      	; 0x1372 <travel+0x238>
    1370:	32 cf       	rjmp	.-412    	; 0x11d6 <travel+0x9c>
    1372:	80 91 98 04 	lds	r24, 0x0498
    1376:	86 31       	cpi	r24, 0x16	; 22
    1378:	08 f4       	brcc	.+2      	; 0x137c <travel+0x242>
    137a:	2d cf       	rjmp	.-422    	; 0x11d6 <travel+0x9c>
		{
			flag=4;
			
			lcd_print(2,9,original[count],2);
    137c:	e8 01       	movw	r28, r16
    137e:	cc 0f       	add	r28, r28
    1380:	dd 1f       	adc	r29, r29
    1382:	f7 01       	movw	r30, r14
    1384:	ec 0f       	add	r30, r28
    1386:	fd 1f       	adc	r31, r29
    1388:	40 81       	ld	r20, Z
    138a:	51 81       	ldd	r21, Z+1	; 0x01
    138c:	82 e0       	ldi	r24, 0x02	; 2
    138e:	69 e0       	ldi	r22, 0x09	; 9
    1390:	22 e0       	ldi	r18, 0x02	; 2
    1392:	30 e0       	ldi	r19, 0x00	; 0
    1394:	0e 94 ad 01 	call	0x35a	; 0x35a <lcd_print>
			if(path[count]==1)//it is left
    1398:	f6 01       	movw	r30, r12
    139a:	ec 0f       	add	r30, r28
    139c:	fd 1f       	adc	r31, r29
    139e:	80 81       	ld	r24, Z
    13a0:	91 81       	ldd	r25, Z+1	; 0x01
    13a2:	81 30       	cpi	r24, 0x01	; 1
    13a4:	91 05       	cpc	r25, r1
    13a6:	f9 f4       	brne	.+62     	; 0x13e6 <travel+0x2ac>
			{
				x+=path[count];
    13a8:	80 91 9e 04 	lds	r24, 0x049E
    13ac:	90 91 9f 04 	lds	r25, 0x049F
    13b0:	01 96       	adiw	r24, 0x01	; 1
    13b2:	90 93 9f 04 	sts	0x049F, r25
    13b6:	80 93 9e 04 	sts	0x049E, r24
				forward_mm(75); //Moves robot forward 100mm
    13ba:	8b e4       	ldi	r24, 0x4B	; 75
    13bc:	90 e0       	ldi	r25, 0x00	; 0
    13be:	0e 94 3e 07 	call	0xe7c	; 0xe7c <forward_mm>
				left_degrees(45); //Rotate robot left by 90 degrees
    13c2:	8d e2       	ldi	r24, 0x2D	; 45
    13c4:	90 e0       	ldi	r25, 0x00	; 0
    13c6:	0e 94 54 07 	call	0xea8	; 0xea8 <left_degrees>
				left_count();
    13ca:	0e 94 9e 07 	call	0xf3c	; 0xf3c <left_count>
				stop();
    13ce:	0e 94 83 06 	call	0xd06	; 0xd06 <stop>
    13d2:	8f ef       	ldi	r24, 0xFF	; 255
    13d4:	9f e7       	ldi	r25, 0x7F	; 127
    13d6:	a4 e0       	ldi	r26, 0x04	; 4
    13d8:	81 50       	subi	r24, 0x01	; 1
    13da:	90 40       	sbci	r25, 0x00	; 0
    13dc:	a0 40       	sbci	r26, 0x00	; 0
    13de:	e1 f7       	brne	.-8      	; 0x13d8 <travel+0x29e>
    13e0:	00 c0       	rjmp	.+0      	; 0x13e2 <travel+0x2a8>
    13e2:	00 00       	nop
    13e4:	5b c0       	rjmp	.+182    	; 0x149c <travel+0x362>
				_delay_ms(100);
				
				//align();
				//j++;
			}
			else if(path[count]==4)//it is straight
    13e6:	84 30       	cpi	r24, 0x04	; 4
    13e8:	91 05       	cpc	r25, r1
    13ea:	71 f4       	brne	.+28     	; 0x1408 <travel+0x2ce>
			{
				x+=path[count];
    13ec:	80 91 9e 04 	lds	r24, 0x049E
    13f0:	90 91 9f 04 	lds	r25, 0x049F
    13f4:	04 96       	adiw	r24, 0x04	; 4
    13f6:	90 93 9f 04 	sts	0x049F, r25
    13fa:	80 93 9e 04 	sts	0x049E, r24
				//j++;
				forward_mm(45); //Moves robot forward 100mm
    13fe:	8d e2       	ldi	r24, 0x2D	; 45
    1400:	90 e0       	ldi	r25, 0x00	; 0
    1402:	0e 94 3e 07 	call	0xe7c	; 0xe7c <forward_mm>
    1406:	4a c0       	rjmp	.+148    	; 0x149c <travel+0x362>
				
			}
			else if(path[count]==3)//it is right
    1408:	83 30       	cpi	r24, 0x03	; 3
    140a:	91 05       	cpc	r25, r1
    140c:	f9 f4       	brne	.+62     	; 0x144c <travel+0x312>
			{
				x+=path[count];
    140e:	80 91 9e 04 	lds	r24, 0x049E
    1412:	90 91 9f 04 	lds	r25, 0x049F
    1416:	03 96       	adiw	r24, 0x03	; 3
    1418:	90 93 9f 04 	sts	0x049F, r25
    141c:	80 93 9e 04 	sts	0x049E, r24
				forward_mm(75); //Moves robot forward 100mm
    1420:	8b e4       	ldi	r24, 0x4B	; 75
    1422:	90 e0       	ldi	r25, 0x00	; 0
    1424:	0e 94 3e 07 	call	0xe7c	; 0xe7c <forward_mm>
				right_degrees(45); //Rotate robot right by 90 degrees
    1428:	8d e2       	ldi	r24, 0x2D	; 45
    142a:	90 e0       	ldi	r25, 0x00	; 0
    142c:	0e 94 5f 07 	call	0xebe	; 0xebe <right_degrees>
				right_count();
    1430:	0e 94 f5 07 	call	0xfea	; 0xfea <right_count>
				stop();
    1434:	0e 94 83 06 	call	0xd06	; 0xd06 <stop>
    1438:	8f ef       	ldi	r24, 0xFF	; 255
    143a:	9f e7       	ldi	r25, 0x7F	; 127
    143c:	a4 e0       	ldi	r26, 0x04	; 4
    143e:	81 50       	subi	r24, 0x01	; 1
    1440:	90 40       	sbci	r25, 0x00	; 0
    1442:	a0 40       	sbci	r26, 0x00	; 0
    1444:	e1 f7       	brne	.-8      	; 0x143e <travel+0x304>
    1446:	00 c0       	rjmp	.+0      	; 0x1448 <travel+0x30e>
    1448:	00 00       	nop
    144a:	28 c0       	rjmp	.+80     	; 0x149c <travel+0x362>
				_delay_ms(100);
				//_delay_ms(100);
				//align();
			}
			else if(path[count]==2)//it is back
    144c:	82 30       	cpi	r24, 0x02	; 2
    144e:	91 05       	cpc	r25, r1
    1450:	e9 f4       	brne	.+58     	; 0x148c <travel+0x352>
			{
				x+=path[count];
    1452:	80 91 9e 04 	lds	r24, 0x049E
    1456:	90 91 9f 04 	lds	r25, 0x049F
    145a:	02 96       	adiw	r24, 0x02	; 2
    145c:	90 93 9f 04 	sts	0x049F, r25
    1460:	80 93 9e 04 	sts	0x049E, r24
				forward_mm(75); //Moves robot forward 100mm
    1464:	8b e4       	ldi	r24, 0x4B	; 75
    1466:	90 e0       	ldi	r25, 0x00	; 0
    1468:	0e 94 3e 07 	call	0xe7c	; 0xe7c <forward_mm>
				right_degrees(150); //Rotate robot right by 90 degrees
    146c:	86 e9       	ldi	r24, 0x96	; 150
    146e:	90 e0       	ldi	r25, 0x00	; 0
    1470:	0e 94 5f 07 	call	0xebe	; 0xebe <right_degrees>
				right_count();
    1474:	0e 94 f5 07 	call	0xfea	; 0xfea <right_count>
    1478:	8f ef       	ldi	r24, 0xFF	; 255
    147a:	9f e7       	ldi	r25, 0x7F	; 127
    147c:	a4 e0       	ldi	r26, 0x04	; 4
    147e:	81 50       	subi	r24, 0x01	; 1
    1480:	90 40       	sbci	r25, 0x00	; 0
    1482:	a0 40       	sbci	r26, 0x00	; 0
    1484:	e1 f7       	brne	.-8      	; 0x147e <travel+0x344>
    1486:	00 c0       	rjmp	.+0      	; 0x1488 <travel+0x34e>
    1488:	00 00       	nop
    148a:	08 c0       	rjmp	.+16     	; 0x149c <travel+0x362>
				_delay_ms(100);
				//align();
			}
			else if(count==tot-1)//it is right
    148c:	80 91 e6 04 	lds	r24, 0x04E6
    1490:	90 91 e7 04 	lds	r25, 0x04E7
    1494:	01 97       	sbiw	r24, 0x01	; 1
    1496:	08 17       	cp	r16, r24
    1498:	19 07       	cpc	r17, r25
    149a:	21 f0       	breq	.+8      	; 0x14a4 <travel+0x36a>
			{
				return 1;
			}
			count++;
    149c:	0f 5f       	subi	r16, 0xFF	; 255
    149e:	1f 4f       	sbci	r17, 0xFF	; 255
			forward();
			velocity(250,170);
		}
		else if((Center_white_line>0x15 && Left_white_line>0x15 && Right_white_line>0x15)||(Center_white_line>0x15 && Left_white_line>0x15 && Right_white_line<0x15)||(Center_white_line>0x15 && Left_white_line<0x15 && Right_white_line>0x15))
		{
			flag=4;
    14a0:	e5 01       	movw	r28, r10
    14a2:	99 ce       	rjmp	.-718    	; 0x11d6 <travel+0x9c>
				_delay_ms(100);
				//align();
			}
			else if(count==tot-1)//it is right
			{
				return 1;
    14a4:	81 e0       	ldi	r24, 0x01	; 1
    14a6:	90 e0       	ldi	r25, 0x00	; 0
			}
			count++;
		}
		//return 1;
	}
}
    14a8:	df 91       	pop	r29
    14aa:	cf 91       	pop	r28
    14ac:	1f 91       	pop	r17
    14ae:	0f 91       	pop	r16
    14b0:	ff 90       	pop	r15
    14b2:	ef 90       	pop	r14
    14b4:	df 90       	pop	r13
    14b6:	cf 90       	pop	r12
    14b8:	bf 90       	pop	r11
    14ba:	af 90       	pop	r10
    14bc:	9f 90       	pop	r9
    14be:	8f 90       	pop	r8
    14c0:	7f 90       	pop	r7
    14c2:	6f 90       	pop	r6
    14c4:	08 95       	ret

000014c6 <main>:
Output :      none
Logic:		  driver function to provide necessary medical services and call helper function appropriately
Example Call: -
*/
int main(void)
{
    14c6:	2f 92       	push	r2
    14c8:	3f 92       	push	r3
    14ca:	4f 92       	push	r4
    14cc:	5f 92       	push	r5
    14ce:	6f 92       	push	r6
    14d0:	7f 92       	push	r7
    14d2:	8f 92       	push	r8
    14d4:	9f 92       	push	r9
    14d6:	af 92       	push	r10
    14d8:	bf 92       	push	r11
    14da:	cf 92       	push	r12
    14dc:	df 92       	push	r13
    14de:	ef 92       	push	r14
    14e0:	ff 92       	push	r15
    14e2:	0f 93       	push	r16
    14e4:	1f 93       	push	r17
    14e6:	cf 93       	push	r28
    14e8:	df 93       	push	r29
    14ea:	00 d0       	rcall	.+0      	; 0x14ec <main+0x26>
    14ec:	0f 92       	push	r0
    14ee:	cd b7       	in	r28, 0x3d	; 61
    14f0:	de b7       	in	r29, 0x3e	; 62
	init_devices();
    14f2:	0e 94 8a 08 	call	0x1114	; 0x1114 <init_devices>
	lcd_set_4bit();
    14f6:	0e 94 d6 00 	call	0x1ac	; 0x1ac <lcd_set_4bit>
	lcd_init();
    14fa:	0e 94 3e 01 	call	0x27c	; 0x27c <lcd_init>
	servo_1_rest();			//resetting servo 1 to rest position
    14fe:	0e 94 ea 07 	call	0xfd4	; 0xfd4 <servo_1_rest>
	//_delay_ms(1000);
	led_off();
    1502:	0e 94 56 05 	call	0xaac	; 0xaac <led_off>
	unsigned int x=0,j=1,i=0,a[2],cur=45;
	data=200;
    1506:	88 ec       	ldi	r24, 0xC8	; 200
    1508:	90 e0       	ldi	r25, 0x00	; 0
    150a:	90 93 6c 0a 	sts	0x0A6C, r25
    150e:	80 93 6b 0a 	sts	0x0A6B, r24
	UDR0=data;				//sending flag 200 to search bot in start so that search can start it task while rescue waits for it find survivors
    1512:	88 ec       	ldi	r24, 0xC8	; 200
    1514:	80 93 c6 00 	sts	0x00C6, r24
    1518:	8f ef       	ldi	r24, 0xFF	; 255
    151a:	9f e7       	ldi	r25, 0x7F	; 127
    151c:	a4 e0       	ldi	r26, 0x04	; 4
    151e:	81 50       	subi	r24, 0x01	; 1
    1520:	90 40       	sbci	r25, 0x00	; 0
    1522:	a0 40       	sbci	r26, 0x00	; 0
    1524:	e1 f7       	brne	.-8      	; 0x151e <main+0x58>
    1526:	00 c0       	rjmp	.+0      	; 0x1528 <main+0x62>
    1528:	00 00       	nop
	_delay_ms(100);
	index=0;
    152a:	10 92 a1 04 	sts	0x04A1, r1
    152e:	10 92 a0 04 	sts	0x04A0, r1
	lcd_set_4bit();
	lcd_init();
	servo_1_rest();			//resetting servo 1 to rest position
	//_delay_ms(1000);
	led_off();
	unsigned int x=0,j=1,i=0,a[2],cur=45;
    1532:	0f 2e       	mov	r0, r31
    1534:	fd e2       	ldi	r31, 0x2D	; 45
    1536:	cf 2e       	mov	r12, r31
    1538:	dd 24       	eor	r13, r13
    153a:	f0 2d       	mov	r31, r0
			}
			dest=rec;					// destination ( location )of the survivors
			while(rec==dest){
				_delay_ms(10);
			}
			val[1]=rec;					// turn bot need to take to provide medical procedure
    153c:	0f 2e       	mov	r0, r31
    153e:	f4 ea       	ldi	r31, 0xA4	; 164
    1540:	af 2e       	mov	r10, r31
    1542:	f4 e0       	ldi	r31, 0x04	; 4
    1544:	bf 2e       	mov	r11, r31
    1546:	f0 2d       	mov	r31, r0
			while(rec==val[1]){
				_delay_ms(10);
			}
			val[2]=rec;					// type of first survivor if any
    1548:	0f 2e       	mov	r0, r31
    154a:	f6 ea       	ldi	r31, 0xA6	; 166
    154c:	8f 2e       	mov	r8, r31
    154e:	f4 e0       	ldi	r31, 0x04	; 4
    1550:	9f 2e       	mov	r9, r31
    1552:	f0 2d       	mov	r31, r0
			while(rec==val[2]){
				_delay_ms(10);
			}
			val[3]=rec;					// turn bot need to take to provide medical procedure
    1554:	0f 2e       	mov	r0, r31
    1556:	f8 ea       	ldi	r31, 0xA8	; 168
    1558:	6f 2e       	mov	r6, r31
    155a:	f4 e0       	ldi	r31, 0x04	; 4
    155c:	7f 2e       	mov	r7, r31
    155e:	f0 2d       	mov	r31, r0
			while(rec==val[3]){
				_delay_ms(10);
			}
			val[4]=rec;					// type of second survivor
    1560:	0f 2e       	mov	r0, r31
    1562:	fa ea       	ldi	r31, 0xAA	; 170
    1564:	4f 2e       	mov	r4, r31
    1566:	f4 e0       	ldi	r31, 0x04	; 4
    1568:	5f 2e       	mov	r5, r31
    156a:	f0 2d       	mov	r31, r0
			UDR0=data;
			_delay_ms(1000);
			rem1(cur);					// temporary node to remove where search bot is resting
			for(int i=1;i<=4;i++)
			{
				if(val[i]==92)			//red procedure begins
    156c:	02 ea       	ldi	r16, 0xA2	; 162
    156e:	14 e0       	ldi	r17, 0x04	; 4
		{
			data=250;                 //search need to stop now
			UDR0=data;
			_delay_ms(1000);
			rem1(cur);					// temporary node to remove where search bot is resting
			for(int i=1;i<=4;i++)
    1570:	33 24       	eor	r3, r3
    1572:	33 94       	inc	r3
    1574:	22 24       	eor	r2, r2
	_delay_ms(100);
	index=0;
	j=0;
	while(1)
	{
		if(rec==110)        //flag 110 is to make bot understands the next node it is going to get is blocked hence can be removed from arena
    1576:	80 91 16 0c 	lds	r24, 0x0C16
    157a:	90 91 17 0c 	lds	r25, 0x0C17
    157e:	8e 36       	cpi	r24, 0x6E	; 110
    1580:	91 05       	cpc	r25, r1
    1582:	91 f4       	brne	.+36     	; 0x15a8 <main+0xe2>
    1584:	af ef       	ldi	r26, 0xFF	; 255
    1586:	bf e8       	ldi	r27, 0x8F	; 143
    1588:	11 97       	sbiw	r26, 0x01	; 1
    158a:	f1 f7       	brne	.-4      	; 0x1588 <main+0xc2>
    158c:	00 c0       	rjmp	.+0      	; 0x158e <main+0xc8>
    158e:	00 00       	nop
		{
			while(rec==110)
    1590:	80 91 16 0c 	lds	r24, 0x0C16
    1594:	90 91 17 0c 	lds	r25, 0x0C17
    1598:	8e 36       	cpi	r24, 0x6E	; 110
    159a:	91 05       	cpc	r25, r1
    159c:	99 f3       	breq	.-26     	; 0x1584 <main+0xbe>
			{
				_delay_ms(10);
			}
			if(rec<=90)
    159e:	8b 35       	cpi	r24, 0x5B	; 91
    15a0:	91 05       	cpc	r25, r1
    15a2:	14 f4       	brge	.+4      	; 0x15a8 <main+0xe2>
			{
				rem(rec);
    15a4:	0e 94 3a 02 	call	0x474	; 0x474 <rem>
			}
		}
		if(rec==150)        //flag 150 to understand that search is about to send the info of the survivors it identified in its run of the arena
    15a8:	80 91 16 0c 	lds	r24, 0x0C16
    15ac:	90 91 17 0c 	lds	r25, 0x0C17
    15b0:	86 39       	cpi	r24, 0x96	; 150
    15b2:	91 05       	cpc	r25, r1
    15b4:	09 f0       	breq	.+2      	; 0x15b8 <main+0xf2>
    15b6:	d4 c0       	rjmp	.+424    	; 0x1760 <main+0x29a>
		{
			data=250;					//search must stop now as rescue is about to start
    15b8:	ea ef       	ldi	r30, 0xFA	; 250
    15ba:	f0 e0       	ldi	r31, 0x00	; 0
    15bc:	f0 93 6c 0a 	sts	0x0A6C, r31
    15c0:	e0 93 6b 0a 	sts	0x0A6B, r30
			UDR0=data;
    15c4:	8a ef       	ldi	r24, 0xFA	; 250
    15c6:	80 93 c6 00 	sts	0x00C6, r24
    15ca:	8f ef       	ldi	r24, 0xFF	; 255
    15cc:	9f ef       	ldi	r25, 0xFF	; 255
    15ce:	ac e2       	ldi	r26, 0x2C	; 44
    15d0:	81 50       	subi	r24, 0x01	; 1
    15d2:	90 40       	sbci	r25, 0x00	; 0
    15d4:	a0 40       	sbci	r26, 0x00	; 0
    15d6:	e1 f7       	brne	.-8      	; 0x15d0 <main+0x10a>
    15d8:	00 c0       	rjmp	.+0      	; 0x15da <main+0x114>
    15da:	00 00       	nop
			_delay_ms(1000);
			while(rec==150){
    15dc:	80 91 16 0c 	lds	r24, 0x0C16
    15e0:	90 91 17 0c 	lds	r25, 0x0C17
    15e4:	86 39       	cpi	r24, 0x96	; 150
    15e6:	91 05       	cpc	r25, r1
    15e8:	69 f4       	brne	.+26     	; 0x1604 <main+0x13e>
    15ea:	af ef       	ldi	r26, 0xFF	; 255
    15ec:	bf e8       	ldi	r27, 0x8F	; 143
    15ee:	11 97       	sbiw	r26, 0x01	; 1
    15f0:	f1 f7       	brne	.-4      	; 0x15ee <main+0x128>
    15f2:	00 c0       	rjmp	.+0      	; 0x15f4 <main+0x12e>
    15f4:	00 00       	nop
    15f6:	80 91 16 0c 	lds	r24, 0x0C16
    15fa:	90 91 17 0c 	lds	r25, 0x0C17
    15fe:	86 39       	cpi	r24, 0x96	; 150
    1600:	91 05       	cpc	r25, r1
    1602:	99 f3       	breq	.-26     	; 0x15ea <main+0x124>
				_delay_ms(10);
			}
			via=rec;                    // via is the pre-destination to orient the rescue bot in the right direction to provide medical procedure to the survivors 
    1604:	90 93 11 0c 	sts	0x0C11, r25
    1608:	80 93 10 0c 	sts	0x0C10, r24
			while(rec==via){
    160c:	20 91 16 0c 	lds	r18, 0x0C16
    1610:	30 91 17 0c 	lds	r19, 0x0C17
    1614:	28 17       	cp	r18, r24
    1616:	39 07       	cpc	r19, r25
    1618:	89 f4       	brne	.+34     	; 0x163c <main+0x176>
    161a:	ef ef       	ldi	r30, 0xFF	; 255
    161c:	ff e8       	ldi	r31, 0x8F	; 143
    161e:	31 97       	sbiw	r30, 0x01	; 1
    1620:	f1 f7       	brne	.-4      	; 0x161e <main+0x158>
    1622:	00 c0       	rjmp	.+0      	; 0x1624 <main+0x15e>
    1624:	00 00       	nop
    1626:	20 91 16 0c 	lds	r18, 0x0C16
    162a:	30 91 17 0c 	lds	r19, 0x0C17
    162e:	80 91 10 0c 	lds	r24, 0x0C10
    1632:	90 91 11 0c 	lds	r25, 0x0C11
    1636:	28 17       	cp	r18, r24
    1638:	39 07       	cpc	r19, r25
    163a:	79 f3       	breq	.-34     	; 0x161a <main+0x154>
				_delay_ms(10);
			}
			dest=rec;					// destination ( location )of the survivors
    163c:	30 93 79 06 	sts	0x0679, r19
    1640:	20 93 78 06 	sts	0x0678, r18
			while(rec==dest){
    1644:	80 91 16 0c 	lds	r24, 0x0C16
    1648:	90 91 17 0c 	lds	r25, 0x0C17
    164c:	82 17       	cp	r24, r18
    164e:	93 07       	cpc	r25, r19
    1650:	89 f4       	brne	.+34     	; 0x1674 <main+0x1ae>
    1652:	8f ef       	ldi	r24, 0xFF	; 255
    1654:	9f e8       	ldi	r25, 0x8F	; 143
    1656:	01 97       	sbiw	r24, 0x01	; 1
    1658:	f1 f7       	brne	.-4      	; 0x1656 <main+0x190>
    165a:	00 c0       	rjmp	.+0      	; 0x165c <main+0x196>
    165c:	00 00       	nop
    165e:	80 91 16 0c 	lds	r24, 0x0C16
    1662:	90 91 17 0c 	lds	r25, 0x0C17
    1666:	20 91 78 06 	lds	r18, 0x0678
    166a:	30 91 79 06 	lds	r19, 0x0679
    166e:	82 17       	cp	r24, r18
    1670:	93 07       	cpc	r25, r19
    1672:	79 f3       	breq	.-34     	; 0x1652 <main+0x18c>
				_delay_ms(10);
			}
			val[1]=rec;					// turn bot need to take to provide medical procedure
    1674:	d5 01       	movw	r26, r10
    1676:	11 96       	adiw	r26, 0x01	; 1
    1678:	9c 93       	st	X, r25
    167a:	8e 93       	st	-X, r24
			while(rec==val[1]){
    167c:	80 91 16 0c 	lds	r24, 0x0C16
    1680:	90 91 17 0c 	lds	r25, 0x0C17
    1684:	2d 91       	ld	r18, X+
    1686:	3c 91       	ld	r19, X
    1688:	11 97       	sbiw	r26, 0x01	; 1
    168a:	82 17       	cp	r24, r18
    168c:	93 07       	cpc	r25, r19
    168e:	89 f4       	brne	.+34     	; 0x16b2 <main+0x1ec>
    1690:	ef ef       	ldi	r30, 0xFF	; 255
    1692:	ff e8       	ldi	r31, 0x8F	; 143
    1694:	31 97       	sbiw	r30, 0x01	; 1
    1696:	f1 f7       	brne	.-4      	; 0x1694 <main+0x1ce>
    1698:	00 c0       	rjmp	.+0      	; 0x169a <main+0x1d4>
    169a:	00 00       	nop
    169c:	80 91 16 0c 	lds	r24, 0x0C16
    16a0:	90 91 17 0c 	lds	r25, 0x0C17
    16a4:	d5 01       	movw	r26, r10
    16a6:	2d 91       	ld	r18, X+
    16a8:	3c 91       	ld	r19, X
    16aa:	11 97       	sbiw	r26, 0x01	; 1
    16ac:	82 17       	cp	r24, r18
    16ae:	93 07       	cpc	r25, r19
    16b0:	79 f3       	breq	.-34     	; 0x1690 <main+0x1ca>
				_delay_ms(10);
			}
			val[2]=rec;					// type of first survivor if any
    16b2:	f4 01       	movw	r30, r8
    16b4:	91 83       	std	Z+1, r25	; 0x01
    16b6:	80 83       	st	Z, r24
			while(rec==val[2]){
    16b8:	80 91 16 0c 	lds	r24, 0x0C16
    16bc:	90 91 17 0c 	lds	r25, 0x0C17
    16c0:	20 81       	ld	r18, Z
    16c2:	31 81       	ldd	r19, Z+1	; 0x01
    16c4:	82 17       	cp	r24, r18
    16c6:	93 07       	cpc	r25, r19
    16c8:	89 f4       	brne	.+34     	; 0x16ec <main+0x226>
    16ca:	8f ef       	ldi	r24, 0xFF	; 255
    16cc:	9f e8       	ldi	r25, 0x8F	; 143
    16ce:	01 97       	sbiw	r24, 0x01	; 1
    16d0:	f1 f7       	brne	.-4      	; 0x16ce <main+0x208>
    16d2:	00 c0       	rjmp	.+0      	; 0x16d4 <main+0x20e>
    16d4:	00 00       	nop
    16d6:	80 91 16 0c 	lds	r24, 0x0C16
    16da:	90 91 17 0c 	lds	r25, 0x0C17
    16de:	d4 01       	movw	r26, r8
    16e0:	2d 91       	ld	r18, X+
    16e2:	3c 91       	ld	r19, X
    16e4:	11 97       	sbiw	r26, 0x01	; 1
    16e6:	82 17       	cp	r24, r18
    16e8:	93 07       	cpc	r25, r19
    16ea:	79 f3       	breq	.-34     	; 0x16ca <main+0x204>
				_delay_ms(10);
			}
			val[3]=rec;					// turn bot need to take to provide medical procedure
    16ec:	f3 01       	movw	r30, r6
    16ee:	91 83       	std	Z+1, r25	; 0x01
    16f0:	80 83       	st	Z, r24
			while(rec==val[3]){
    16f2:	80 91 16 0c 	lds	r24, 0x0C16
    16f6:	90 91 17 0c 	lds	r25, 0x0C17
    16fa:	20 81       	ld	r18, Z
    16fc:	31 81       	ldd	r19, Z+1	; 0x01
    16fe:	82 17       	cp	r24, r18
    1700:	93 07       	cpc	r25, r19
    1702:	89 f4       	brne	.+34     	; 0x1726 <main+0x260>
    1704:	8f ef       	ldi	r24, 0xFF	; 255
    1706:	9f e8       	ldi	r25, 0x8F	; 143
    1708:	01 97       	sbiw	r24, 0x01	; 1
    170a:	f1 f7       	brne	.-4      	; 0x1708 <main+0x242>
    170c:	00 c0       	rjmp	.+0      	; 0x170e <main+0x248>
    170e:	00 00       	nop
    1710:	80 91 16 0c 	lds	r24, 0x0C16
    1714:	90 91 17 0c 	lds	r25, 0x0C17
    1718:	d3 01       	movw	r26, r6
    171a:	2d 91       	ld	r18, X+
    171c:	3c 91       	ld	r19, X
    171e:	11 97       	sbiw	r26, 0x01	; 1
    1720:	82 17       	cp	r24, r18
    1722:	93 07       	cpc	r25, r19
    1724:	79 f3       	breq	.-34     	; 0x1704 <main+0x23e>
				_delay_ms(10);
			}
			val[4]=rec;					// type of second survivor
    1726:	f2 01       	movw	r30, r4
    1728:	91 83       	std	Z+1, r25	; 0x01
    172a:	80 83       	st	Z, r24
			while(rec==val[4]){
    172c:	c0 90 16 0c 	lds	r12, 0x0C16
    1730:	d0 90 17 0c 	lds	r13, 0x0C17
    1734:	80 81       	ld	r24, Z
    1736:	91 81       	ldd	r25, Z+1	; 0x01
    1738:	c8 16       	cp	r12, r24
    173a:	d9 06       	cpc	r13, r25
    173c:	89 f4       	brne	.+34     	; 0x1760 <main+0x29a>
    173e:	8f ef       	ldi	r24, 0xFF	; 255
    1740:	9f e8       	ldi	r25, 0x8F	; 143
    1742:	01 97       	sbiw	r24, 0x01	; 1
    1744:	f1 f7       	brne	.-4      	; 0x1742 <main+0x27c>
    1746:	00 c0       	rjmp	.+0      	; 0x1748 <main+0x282>
    1748:	00 00       	nop
    174a:	c0 90 16 0c 	lds	r12, 0x0C16
    174e:	d0 90 17 0c 	lds	r13, 0x0C17
    1752:	d2 01       	movw	r26, r4
    1754:	8d 91       	ld	r24, X+
    1756:	9c 91       	ld	r25, X
    1758:	11 97       	sbiw	r26, 0x01	; 1
    175a:	c8 16       	cp	r12, r24
    175c:	d9 06       	cpc	r13, r25
    175e:	79 f3       	breq	.-34     	; 0x173e <main+0x278>
				_delay_ms(10);
			}
			cur=rec;					// place where search is standing for rescue to avoid that node
		}			
		if(rec==200) //start traversing
    1760:	80 91 16 0c 	lds	r24, 0x0C16
    1764:	90 91 17 0c 	lds	r25, 0x0C17
    1768:	88 3c       	cpi	r24, 0xC8	; 200
    176a:	91 05       	cpc	r25, r1
    176c:	09 f0       	breq	.+2      	; 0x1770 <main+0x2aa>
    176e:	03 cf       	rjmp	.-506    	; 0x1576 <main+0xb0>
		{
			data=250;                 //search need to stop now
    1770:	ea ef       	ldi	r30, 0xFA	; 250
    1772:	f0 e0       	ldi	r31, 0x00	; 0
    1774:	f0 93 6c 0a 	sts	0x0A6C, r31
    1778:	e0 93 6b 0a 	sts	0x0A6B, r30
			UDR0=data;
    177c:	8a ef       	ldi	r24, 0xFA	; 250
    177e:	80 93 c6 00 	sts	0x00C6, r24
    1782:	8f ef       	ldi	r24, 0xFF	; 255
    1784:	9f ef       	ldi	r25, 0xFF	; 255
    1786:	ac e2       	ldi	r26, 0x2C	; 44
    1788:	81 50       	subi	r24, 0x01	; 1
    178a:	90 40       	sbci	r25, 0x00	; 0
    178c:	a0 40       	sbci	r26, 0x00	; 0
    178e:	e1 f7       	brne	.-8      	; 0x1788 <main+0x2c2>
    1790:	00 c0       	rjmp	.+0      	; 0x1792 <main+0x2cc>
    1792:	00 00       	nop
			_delay_ms(1000);
			rem1(cur);					// temporary node to remove where search bot is resting
    1794:	c9 82       	std	Y+1, r12	; 0x01
    1796:	da 82       	std	Y+2, r13	; 0x02
    1798:	8c 2d       	mov	r24, r12
    179a:	9d 2d       	mov	r25, r13
    179c:	0e 94 56 02 	call	0x4ac	; 0x4ac <rem1>
			for(int i=1;i<=4;i++)
    17a0:	a1 e0       	ldi	r26, 0x01	; 1
    17a2:	b0 e0       	ldi	r27, 0x00	; 0
    17a4:	bc 83       	std	Y+4, r27	; 0x04
    17a6:	ab 83       	std	Y+3, r26	; 0x03
			{
				if(val[i]==92)			//red procedure begins
    17a8:	8b 81       	ldd	r24, Y+3	; 0x03
    17aa:	9c 81       	ldd	r25, Y+4	; 0x04
    17ac:	88 0f       	add	r24, r24
    17ae:	99 1f       	adc	r25, r25
    17b0:	80 0f       	add	r24, r16
    17b2:	91 1f       	adc	r25, r17
    17b4:	fc 01       	movw	r30, r24
    17b6:	80 81       	ld	r24, Z
    17b8:	91 81       	ldd	r25, Z+1	; 0x01
    17ba:	8c 35       	cpi	r24, 0x5C	; 92
    17bc:	91 05       	cpc	r25, r1
    17be:	09 f0       	breq	.+2      	; 0x17c2 <main+0x2fc>
    17c0:	27 c1       	rjmp	.+590    	; 0x1a10 <main+0x54a>
				{
					red_on();
    17c2:	0e 94 52 05 	call	0xaa4	; 0xaa4 <red_on>
					//lcd_string("RED");
					while(current!=1)
    17c6:	80 91 00 02 	lds	r24, 0x0200
    17ca:	90 91 01 02 	lds	r25, 0x0201
    17ce:	81 30       	cpi	r24, 0x01	; 1
    17d0:	91 05       	cpc	r25, r1
    17d2:	69 f0       	breq	.+26     	; 0x17ee <main+0x328>
					{
						current=travel(current,via);
    17d4:	60 91 10 0c 	lds	r22, 0x0C10
    17d8:	70 91 11 0c 	lds	r23, 0x0C11
    17dc:	0e 94 9d 08 	call	0x113a	; 0x113a <travel>
    17e0:	90 93 01 02 	sts	0x0201, r25
    17e4:	80 93 00 02 	sts	0x0200, r24
			{
				if(val[i]==92)			//red procedure begins
				{
					red_on();
					//lcd_string("RED");
					while(current!=1)
    17e8:	81 30       	cpi	r24, 0x01	; 1
    17ea:	91 05       	cpc	r25, r1
    17ec:	99 f7       	brne	.-26     	; 0x17d4 <main+0x30e>
					{
						current=travel(current,via);
					}
					current=via;
    17ee:	80 91 10 0c 	lds	r24, 0x0C10
    17f2:	90 91 11 0c 	lds	r25, 0x0C11
    17f6:	90 93 01 02 	sts	0x0201, r25
    17fa:	80 93 00 02 	sts	0x0200, r24
					forward_mm(100);
    17fe:	84 e6       	ldi	r24, 0x64	; 100
    1800:	90 e0       	ldi	r25, 0x00	; 0
    1802:	0e 94 3e 07 	call	0xe7c	; 0xe7c <forward_mm>
    1806:	8f ef       	ldi	r24, 0xFF	; 255
    1808:	9f ef       	ldi	r25, 0xFF	; 255
    180a:	ac e2       	ldi	r26, 0x2C	; 44
    180c:	81 50       	subi	r24, 0x01	; 1
    180e:	90 40       	sbci	r25, 0x00	; 0
    1810:	a0 40       	sbci	r26, 0x00	; 0
    1812:	e1 f7       	brne	.-8      	; 0x180c <main+0x346>
    1814:	00 c0       	rjmp	.+0      	; 0x1816 <main+0x350>
    1816:	00 00       	nop
					_delay_ms(1000);
					
					while(current!=1)
    1818:	80 91 00 02 	lds	r24, 0x0200
    181c:	90 91 01 02 	lds	r25, 0x0201
    1820:	81 30       	cpi	r24, 0x01	; 1
    1822:	91 05       	cpc	r25, r1
    1824:	69 f0       	breq	.+26     	; 0x1840 <main+0x37a>
					{
						
						current=travel(current,dest);
    1826:	60 91 78 06 	lds	r22, 0x0678
    182a:	70 91 79 06 	lds	r23, 0x0679
    182e:	0e 94 9d 08 	call	0x113a	; 0x113a <travel>
    1832:	90 93 01 02 	sts	0x0201, r25
    1836:	80 93 00 02 	sts	0x0200, r24
					}
					current=via;
					forward_mm(100);
					_delay_ms(1000);
					
					while(current!=1)
    183a:	81 30       	cpi	r24, 0x01	; 1
    183c:	91 05       	cpc	r25, r1
    183e:	99 f7       	brne	.-26     	; 0x1826 <main+0x360>
					{
						
						current=travel(current,dest);
					}
					forward_mm(100);
    1840:	84 e6       	ldi	r24, 0x64	; 100
    1842:	90 e0       	ldi	r25, 0x00	; 0
    1844:	0e 94 3e 07 	call	0xe7c	; 0xe7c <forward_mm>
    1848:	8f ef       	ldi	r24, 0xFF	; 255
    184a:	9f ef       	ldi	r25, 0xFF	; 255
    184c:	ac e2       	ldi	r26, 0x2C	; 44
    184e:	81 50       	subi	r24, 0x01	; 1
    1850:	90 40       	sbci	r25, 0x00	; 0
    1852:	a0 40       	sbci	r26, 0x00	; 0
    1854:	e1 f7       	brne	.-8      	; 0x184e <main+0x388>
    1856:	00 c0       	rjmp	.+0      	; 0x1858 <main+0x392>
    1858:	00 00       	nop
					_delay_ms(1000);
					current=dest;
    185a:	80 91 78 06 	lds	r24, 0x0678
    185e:	90 91 79 06 	lds	r25, 0x0679
    1862:	90 93 01 02 	sts	0x0201, r25
    1866:	80 93 00 02 	sts	0x0200, r24
					if(val[i-1]==101)
    186a:	eb 80       	ldd	r14, Y+3	; 0x03
    186c:	fc 80       	ldd	r15, Y+4	; 0x04
    186e:	08 94       	sec
    1870:	e1 08       	sbc	r14, r1
    1872:	f1 08       	sbc	r15, r1
    1874:	c7 01       	movw	r24, r14
    1876:	88 0f       	add	r24, r24
    1878:	99 1f       	adc	r25, r25
    187a:	80 0f       	add	r24, r16
    187c:	91 1f       	adc	r25, r17
    187e:	dc 01       	movw	r26, r24
    1880:	8d 91       	ld	r24, X+
    1882:	9c 91       	ld	r25, X
    1884:	11 97       	sbiw	r26, 0x01	; 1
    1886:	85 36       	cpi	r24, 0x65	; 101
    1888:	91 05       	cpc	r25, r1
    188a:	f9 f4       	brne	.+62     	; 0x18ca <main+0x404>
					{
					right_degrees(90);
    188c:	8a e5       	ldi	r24, 0x5A	; 90
    188e:	90 e0       	ldi	r25, 0x00	; 0
    1890:	0e 94 5f 07 	call	0xebe	; 0xebe <right_degrees>
    1894:	8f ef       	ldi	r24, 0xFF	; 255
    1896:	9f ef       	ldi	r25, 0xFF	; 255
    1898:	ac e2       	ldi	r26, 0x2C	; 44
    189a:	81 50       	subi	r24, 0x01	; 1
    189c:	90 40       	sbci	r25, 0x00	; 0
    189e:	a0 40       	sbci	r26, 0x00	; 0
    18a0:	e1 f7       	brne	.-8      	; 0x189a <main+0x3d4>
    18a2:	00 c0       	rjmp	.+0      	; 0x18a4 <main+0x3de>
    18a4:	00 00       	nop
					_delay_ms(1000);
					buzzer_on();
    18a6:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <buzzer_on>
    18aa:	8f ef       	ldi	r24, 0xFF	; 255
    18ac:	9f ef       	ldi	r25, 0xFF	; 255
    18ae:	ac e2       	ldi	r26, 0x2C	; 44
    18b0:	81 50       	subi	r24, 0x01	; 1
    18b2:	90 40       	sbci	r25, 0x00	; 0
    18b4:	a0 40       	sbci	r26, 0x00	; 0
    18b6:	e1 f7       	brne	.-8      	; 0x18b0 <main+0x3ea>
    18b8:	00 c0       	rjmp	.+0      	; 0x18ba <main+0x3f4>
    18ba:	00 00       	nop
					_delay_ms(1000);
					buzzer_off();
    18bc:	0e 94 5f 06 	call	0xcbe	; 0xcbe <buzzer_off>
					
					left_count();
    18c0:	0e 94 9e 07 	call	0xf3c	; 0xf3c <left_count>
					stop();
    18c4:	0e 94 83 06 	call	0xd06	; 0xd06 <stop>
    18c8:	1e c0       	rjmp	.+60     	; 0x1906 <main+0x440>
					}						
					else {
					left_degrees(90);
    18ca:	8a e5       	ldi	r24, 0x5A	; 90
    18cc:	90 e0       	ldi	r25, 0x00	; 0
    18ce:	0e 94 54 07 	call	0xea8	; 0xea8 <left_degrees>
    18d2:	8f ef       	ldi	r24, 0xFF	; 255
    18d4:	9f ef       	ldi	r25, 0xFF	; 255
    18d6:	ac e2       	ldi	r26, 0x2C	; 44
    18d8:	81 50       	subi	r24, 0x01	; 1
    18da:	90 40       	sbci	r25, 0x00	; 0
    18dc:	a0 40       	sbci	r26, 0x00	; 0
    18de:	e1 f7       	brne	.-8      	; 0x18d8 <main+0x412>
    18e0:	00 c0       	rjmp	.+0      	; 0x18e2 <main+0x41c>
    18e2:	00 00       	nop
					_delay_ms(1000);
					buzzer_on();
    18e4:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <buzzer_on>
    18e8:	8f ef       	ldi	r24, 0xFF	; 255
    18ea:	9f ef       	ldi	r25, 0xFF	; 255
    18ec:	ac e2       	ldi	r26, 0x2C	; 44
    18ee:	81 50       	subi	r24, 0x01	; 1
    18f0:	90 40       	sbci	r25, 0x00	; 0
    18f2:	a0 40       	sbci	r26, 0x00	; 0
    18f4:	e1 f7       	brne	.-8      	; 0x18ee <main+0x428>
    18f6:	00 c0       	rjmp	.+0      	; 0x18f8 <main+0x432>
    18f8:	00 00       	nop
					_delay_ms(1000);
					buzzer_off();
    18fa:	0e 94 5f 06 	call	0xcbe	; 0xcbe <buzzer_off>
					right_count();
    18fe:	0e 94 f5 07 	call	0xfea	; 0xfea <right_count>
					stop();
    1902:	0e 94 83 06 	call	0xd06	; 0xd06 <stop>
					}					
					while(current!=1)
    1906:	80 91 00 02 	lds	r24, 0x0200
    190a:	90 91 01 02 	lds	r25, 0x0201
    190e:	81 30       	cpi	r24, 0x01	; 1
    1910:	91 05       	cpc	r25, r1
    1912:	59 f0       	breq	.+22     	; 0x192a <main+0x464>
					{
						current=travel(current,86);
    1914:	66 e5       	ldi	r22, 0x56	; 86
    1916:	70 e0       	ldi	r23, 0x00	; 0
    1918:	0e 94 9d 08 	call	0x113a	; 0x113a <travel>
    191c:	90 93 01 02 	sts	0x0201, r25
    1920:	80 93 00 02 	sts	0x0200, r24
					_delay_ms(1000);
					buzzer_off();
					right_count();
					stop();
					}					
					while(current!=1)
    1924:	81 30       	cpi	r24, 0x01	; 1
    1926:	91 05       	cpc	r25, r1
    1928:	a9 f7       	brne	.-22     	; 0x1914 <main+0x44e>
					{
						current=travel(current,86);
					}
					current=86;
    192a:	86 e5       	ldi	r24, 0x56	; 86
    192c:	90 e0       	ldi	r25, 0x00	; 0
    192e:	90 93 01 02 	sts	0x0201, r25
    1932:	80 93 00 02 	sts	0x0200, r24
					forward_mm(75);
    1936:	8b e4       	ldi	r24, 0x4B	; 75
    1938:	90 e0       	ldi	r25, 0x00	; 0
    193a:	0e 94 3e 07 	call	0xe7c	; 0xe7c <forward_mm>
    193e:	8f ef       	ldi	r24, 0xFF	; 255
    1940:	9f ef       	ldi	r25, 0xFF	; 255
    1942:	ac e2       	ldi	r26, 0x2C	; 44
    1944:	81 50       	subi	r24, 0x01	; 1
    1946:	90 40       	sbci	r25, 0x00	; 0
    1948:	a0 40       	sbci	r26, 0x00	; 0
    194a:	e1 f7       	brne	.-8      	; 0x1944 <main+0x47e>
    194c:	00 c0       	rjmp	.+0      	; 0x194e <main+0x488>
    194e:	00 00       	nop
					_delay_ms(1000);
					while(current!=1)
    1950:	80 91 00 02 	lds	r24, 0x0200
    1954:	90 91 01 02 	lds	r25, 0x0201
    1958:	81 30       	cpi	r24, 0x01	; 1
    195a:	91 05       	cpc	r25, r1
    195c:	59 f0       	breq	.+22     	; 0x1974 <main+0x4ae>
					{
						current=travel(current,85);
    195e:	65 e5       	ldi	r22, 0x55	; 85
    1960:	70 e0       	ldi	r23, 0x00	; 0
    1962:	0e 94 9d 08 	call	0x113a	; 0x113a <travel>
    1966:	90 93 01 02 	sts	0x0201, r25
    196a:	80 93 00 02 	sts	0x0200, r24
						current=travel(current,86);
					}
					current=86;
					forward_mm(75);
					_delay_ms(1000);
					while(current!=1)
    196e:	81 30       	cpi	r24, 0x01	; 1
    1970:	91 05       	cpc	r25, r1
    1972:	a9 f7       	brne	.-22     	; 0x195e <main+0x498>
					{
						current=travel(current,85);
					}
					current=85;
    1974:	85 e5       	ldi	r24, 0x55	; 85
    1976:	90 e0       	ldi	r25, 0x00	; 0
    1978:	90 93 01 02 	sts	0x0201, r25
    197c:	80 93 00 02 	sts	0x0200, r24
					forward_mm(75);
    1980:	8b e4       	ldi	r24, 0x4B	; 75
    1982:	90 e0       	ldi	r25, 0x00	; 0
    1984:	0e 94 3e 07 	call	0xe7c	; 0xe7c <forward_mm>
    1988:	8f ef       	ldi	r24, 0xFF	; 255
    198a:	9f ef       	ldi	r25, 0xFF	; 255
    198c:	ac e2       	ldi	r26, 0x2C	; 44
    198e:	81 50       	subi	r24, 0x01	; 1
    1990:	90 40       	sbci	r25, 0x00	; 0
    1992:	a0 40       	sbci	r26, 0x00	; 0
    1994:	e1 f7       	brne	.-8      	; 0x198e <main+0x4c8>
    1996:	00 c0       	rjmp	.+0      	; 0x1998 <main+0x4d2>
    1998:	00 00       	nop
					_delay_ms(1000);
					right_degrees(90);
    199a:	8a e5       	ldi	r24, 0x5A	; 90
    199c:	90 e0       	ldi	r25, 0x00	; 0
    199e:	0e 94 5f 07 	call	0xebe	; 0xebe <right_degrees>
    19a2:	8f ef       	ldi	r24, 0xFF	; 255
    19a4:	9f ef       	ldi	r25, 0xFF	; 255
    19a6:	ac e2       	ldi	r26, 0x2C	; 44
    19a8:	81 50       	subi	r24, 0x01	; 1
    19aa:	90 40       	sbci	r25, 0x00	; 0
    19ac:	a0 40       	sbci	r26, 0x00	; 0
    19ae:	e1 f7       	brne	.-8      	; 0x19a8 <main+0x4e2>
    19b0:	00 c0       	rjmp	.+0      	; 0x19b2 <main+0x4ec>
    19b2:	00 00       	nop
					_delay_ms(1000);
					stop();
    19b4:	0e 94 83 06 	call	0xd06	; 0xd06 <stop>
					
					buzzer_on();
    19b8:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <buzzer_on>
    19bc:	8f ef       	ldi	r24, 0xFF	; 255
    19be:	9f ef       	ldi	r25, 0xFF	; 255
    19c0:	ac e2       	ldi	r26, 0x2C	; 44
    19c2:	81 50       	subi	r24, 0x01	; 1
    19c4:	90 40       	sbci	r25, 0x00	; 0
    19c6:	a0 40       	sbci	r26, 0x00	; 0
    19c8:	e1 f7       	brne	.-8      	; 0x19c2 <main+0x4fc>
    19ca:	00 c0       	rjmp	.+0      	; 0x19cc <main+0x506>
    19cc:	00 00       	nop
					_delay_ms(1000);
					buzzer_off();
    19ce:	0e 94 5f 06 	call	0xcbe	; 0xcbe <buzzer_off>
					left_degrees(45);
    19d2:	8d e2       	ldi	r24, 0x2D	; 45
    19d4:	90 e0       	ldi	r25, 0x00	; 0
    19d6:	0e 94 54 07 	call	0xea8	; 0xea8 <left_degrees>
					//_delay_ms(1000);
					left_count();
    19da:	0e 94 9e 07 	call	0xf3c	; 0xf3c <left_count>
					stop();
    19de:	0e 94 83 06 	call	0xd06	; 0xd06 <stop>
					led_off();
    19e2:	0e 94 56 05 	call	0xaac	; 0xaac <led_off>
					val[i]=0;
    19e6:	8b 81       	ldd	r24, Y+3	; 0x03
    19e8:	9c 81       	ldd	r25, Y+4	; 0x04
    19ea:	88 0f       	add	r24, r24
    19ec:	99 1f       	adc	r25, r25
    19ee:	80 0f       	add	r24, r16
    19f0:	91 1f       	adc	r25, r17
    19f2:	dc 01       	movw	r26, r24
    19f4:	11 96       	adiw	r26, 0x01	; 1
    19f6:	1c 92       	st	X, r1
    19f8:	1e 92       	st	-X, r1
					val[i-1]=0;
    19fa:	c7 01       	movw	r24, r14
    19fc:	88 0f       	add	r24, r24
    19fe:	99 1f       	adc	r25, r25
    1a00:	80 0f       	add	r24, r16
    1a02:	91 1f       	adc	r25, r17
    1a04:	fc 01       	movw	r30, r24
    1a06:	11 82       	std	Z+1, r1	; 0x01
    1a08:	10 82       	st	Z, r1
		{
			data=250;                 //search need to stop now
			UDR0=data;
			_delay_ms(1000);
			rem1(cur);					// temporary node to remove where search bot is resting
			for(int i=1;i<=4;i++)
    1a0a:	3b 82       	std	Y+3, r3	; 0x03
    1a0c:	2c 82       	std	Y+4, r2	; 0x04
    1a0e:	cc ce       	rjmp	.-616    	; 0x17a8 <main+0x2e2>
    1a10:	8b 81       	ldd	r24, Y+3	; 0x03
    1a12:	9c 81       	ldd	r25, Y+4	; 0x04
    1a14:	01 96       	adiw	r24, 0x01	; 1
    1a16:	9c 83       	std	Y+4, r25	; 0x04
    1a18:	8b 83       	std	Y+3, r24	; 0x03
    1a1a:	85 30       	cpi	r24, 0x05	; 5
    1a1c:	91 05       	cpc	r25, r1
    1a1e:	0c f4       	brge	.+2      	; 0x1a22 <main+0x55c>
    1a20:	c3 ce       	rjmp	.-634    	; 0x17a8 <main+0x2e2>
    1a22:	a1 e0       	ldi	r26, 0x01	; 1
    1a24:	b0 e0       	ldi	r27, 0x00	; 0
    1a26:	bc 83       	std	Y+4, r27	; 0x04
    1a28:	ab 83       	std	Y+3, r26	; 0x03
			
			//red procedure ends
			for(int i=1;i<=4;i++)
			{
				//lcd_print(2,12,i,3);
				if(val[i]==93)  //green procedure starts
    1a2a:	8b 81       	ldd	r24, Y+3	; 0x03
    1a2c:	9c 81       	ldd	r25, Y+4	; 0x04
    1a2e:	88 0f       	add	r24, r24
    1a30:	99 1f       	adc	r25, r25
    1a32:	80 0f       	add	r24, r16
    1a34:	91 1f       	adc	r25, r17
    1a36:	fc 01       	movw	r30, r24
    1a38:	80 81       	ld	r24, Z
    1a3a:	91 81       	ldd	r25, Z+1	; 0x01
    1a3c:	8d 35       	cpi	r24, 0x5D	; 93
    1a3e:	91 05       	cpc	r25, r1
    1a40:	09 f0       	breq	.+2      	; 0x1a44 <main+0x57e>
    1a42:	d5 c0       	rjmp	.+426    	; 0x1bee <main+0x728>
				{
					green_on();
    1a44:	0e 94 5d 05 	call	0xaba	; 0xaba <green_on>
					while(current!=1)
    1a48:	80 91 00 02 	lds	r24, 0x0200
    1a4c:	90 91 01 02 	lds	r25, 0x0201
    1a50:	81 30       	cpi	r24, 0x01	; 1
    1a52:	91 05       	cpc	r25, r1
    1a54:	69 f0       	breq	.+26     	; 0x1a70 <main+0x5aa>
					{
					
						current=travel(current,via);
    1a56:	60 91 10 0c 	lds	r22, 0x0C10
    1a5a:	70 91 11 0c 	lds	r23, 0x0C11
    1a5e:	0e 94 9d 08 	call	0x113a	; 0x113a <travel>
    1a62:	90 93 01 02 	sts	0x0201, r25
    1a66:	80 93 00 02 	sts	0x0200, r24
			{
				//lcd_print(2,12,i,3);
				if(val[i]==93)  //green procedure starts
				{
					green_on();
					while(current!=1)
    1a6a:	81 30       	cpi	r24, 0x01	; 1
    1a6c:	91 05       	cpc	r25, r1
    1a6e:	99 f7       	brne	.-26     	; 0x1a56 <main+0x590>
					{
					
						current=travel(current,via);
					}
					current=via;
    1a70:	80 91 10 0c 	lds	r24, 0x0C10
    1a74:	90 91 11 0c 	lds	r25, 0x0C11
    1a78:	90 93 01 02 	sts	0x0201, r25
    1a7c:	80 93 00 02 	sts	0x0200, r24
					forward_mm(100);
    1a80:	84 e6       	ldi	r24, 0x64	; 100
    1a82:	90 e0       	ldi	r25, 0x00	; 0
    1a84:	0e 94 3e 07 	call	0xe7c	; 0xe7c <forward_mm>
    1a88:	8f ef       	ldi	r24, 0xFF	; 255
    1a8a:	9f ef       	ldi	r25, 0xFF	; 255
    1a8c:	ac e2       	ldi	r26, 0x2C	; 44
    1a8e:	81 50       	subi	r24, 0x01	; 1
    1a90:	90 40       	sbci	r25, 0x00	; 0
    1a92:	a0 40       	sbci	r26, 0x00	; 0
    1a94:	e1 f7       	brne	.-8      	; 0x1a8e <main+0x5c8>
    1a96:	00 c0       	rjmp	.+0      	; 0x1a98 <main+0x5d2>
    1a98:	00 00       	nop
					_delay_ms(1000);
				
					while(current!=1)
    1a9a:	80 91 00 02 	lds	r24, 0x0200
    1a9e:	90 91 01 02 	lds	r25, 0x0201
    1aa2:	81 30       	cpi	r24, 0x01	; 1
    1aa4:	91 05       	cpc	r25, r1
    1aa6:	69 f0       	breq	.+26     	; 0x1ac2 <main+0x5fc>
					{
					
						current=travel(current,dest);
    1aa8:	60 91 78 06 	lds	r22, 0x0678
    1aac:	70 91 79 06 	lds	r23, 0x0679
    1ab0:	0e 94 9d 08 	call	0x113a	; 0x113a <travel>
    1ab4:	90 93 01 02 	sts	0x0201, r25
    1ab8:	80 93 00 02 	sts	0x0200, r24
					}
					current=via;
					forward_mm(100);
					_delay_ms(1000);
				
					while(current!=1)
    1abc:	81 30       	cpi	r24, 0x01	; 1
    1abe:	91 05       	cpc	r25, r1
    1ac0:	99 f7       	brne	.-26     	; 0x1aa8 <main+0x5e2>
					{
					
						current=travel(current,dest);
					}
					current=dest;
    1ac2:	80 91 78 06 	lds	r24, 0x0678
    1ac6:	90 91 79 06 	lds	r25, 0x0679
    1aca:	90 93 01 02 	sts	0x0201, r25
    1ace:	80 93 00 02 	sts	0x0200, r24
					forward_mm(100);
    1ad2:	84 e6       	ldi	r24, 0x64	; 100
    1ad4:	90 e0       	ldi	r25, 0x00	; 0
    1ad6:	0e 94 3e 07 	call	0xe7c	; 0xe7c <forward_mm>
    1ada:	8f ef       	ldi	r24, 0xFF	; 255
    1adc:	9f ef       	ldi	r25, 0xFF	; 255
    1ade:	ac e2       	ldi	r26, 0x2C	; 44
    1ae0:	81 50       	subi	r24, 0x01	; 1
    1ae2:	90 40       	sbci	r25, 0x00	; 0
    1ae4:	a0 40       	sbci	r26, 0x00	; 0
    1ae6:	e1 f7       	brne	.-8      	; 0x1ae0 <main+0x61a>
    1ae8:	00 c0       	rjmp	.+0      	; 0x1aea <main+0x624>
    1aea:	00 00       	nop
					_delay_ms(1000);
				
					if(val[i-1]==101)
    1aec:	eb 80       	ldd	r14, Y+3	; 0x03
    1aee:	fc 80       	ldd	r15, Y+4	; 0x04
    1af0:	08 94       	sec
    1af2:	e1 08       	sbc	r14, r1
    1af4:	f1 08       	sbc	r15, r1
    1af6:	c7 01       	movw	r24, r14
    1af8:	88 0f       	add	r24, r24
    1afa:	99 1f       	adc	r25, r25
    1afc:	80 0f       	add	r24, r16
    1afe:	91 1f       	adc	r25, r17
    1b00:	dc 01       	movw	r26, r24
    1b02:	8d 91       	ld	r24, X+
    1b04:	9c 91       	ld	r25, X
    1b06:	11 97       	sbiw	r26, 0x01	; 1
    1b08:	85 36       	cpi	r24, 0x65	; 101
    1b0a:	91 05       	cpc	r25, r1
    1b0c:	69 f5       	brne	.+90     	; 0x1b68 <main+0x6a2>
					{
						right_degrees(90);
    1b0e:	8a e5       	ldi	r24, 0x5A	; 90
    1b10:	90 e0       	ldi	r25, 0x00	; 0
    1b12:	0e 94 5f 07 	call	0xebe	; 0xebe <right_degrees>
    1b16:	8f ef       	ldi	r24, 0xFF	; 255
    1b18:	9f ef       	ldi	r25, 0xFF	; 255
    1b1a:	ac e2       	ldi	r26, 0x2C	; 44
    1b1c:	81 50       	subi	r24, 0x01	; 1
    1b1e:	90 40       	sbci	r25, 0x00	; 0
    1b20:	a0 40       	sbci	r26, 0x00	; 0
    1b22:	e1 f7       	brne	.-8      	; 0x1b1c <main+0x656>
    1b24:	00 c0       	rjmp	.+0      	; 0x1b26 <main+0x660>
    1b26:	00 00       	nop
						_delay_ms(1000);
						servo_1(75);
    1b28:	8b e4       	ldi	r24, 0x4B	; 75
    1b2a:	0e 94 d1 07 	call	0xfa2	; 0xfa2 <servo_1>
    1b2e:	8f ef       	ldi	r24, 0xFF	; 255
    1b30:	9f ef       	ldi	r25, 0xFF	; 255
    1b32:	ac e2       	ldi	r26, 0x2C	; 44
    1b34:	81 50       	subi	r24, 0x01	; 1
    1b36:	90 40       	sbci	r25, 0x00	; 0
    1b38:	a0 40       	sbci	r26, 0x00	; 0
    1b3a:	e1 f7       	brne	.-8      	; 0x1b34 <main+0x66e>
    1b3c:	00 c0       	rjmp	.+0      	; 0x1b3e <main+0x678>
    1b3e:	00 00       	nop
						_delay_ms(1000);
						servo_1_rest();
    1b40:	0e 94 ea 07 	call	0xfd4	; 0xfd4 <servo_1_rest>
						buzzer_on();
    1b44:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <buzzer_on>
    1b48:	8f ef       	ldi	r24, 0xFF	; 255
    1b4a:	9f ef       	ldi	r25, 0xFF	; 255
    1b4c:	ac e2       	ldi	r26, 0x2C	; 44
    1b4e:	81 50       	subi	r24, 0x01	; 1
    1b50:	90 40       	sbci	r25, 0x00	; 0
    1b52:	a0 40       	sbci	r26, 0x00	; 0
    1b54:	e1 f7       	brne	.-8      	; 0x1b4e <main+0x688>
    1b56:	00 c0       	rjmp	.+0      	; 0x1b58 <main+0x692>
    1b58:	00 00       	nop
						_delay_ms(1000);
						buzzer_off();
    1b5a:	0e 94 5f 06 	call	0xcbe	; 0xcbe <buzzer_off>
						left_count();
    1b5e:	0e 94 9e 07 	call	0xf3c	; 0xf3c <left_count>
						stop();
    1b62:	0e 94 83 06 	call	0xd06	; 0xd06 <stop>
    1b66:	2c c0       	rjmp	.+88     	; 0x1bc0 <main+0x6fa>
					}
					else {
						left_degrees(90);
    1b68:	8a e5       	ldi	r24, 0x5A	; 90
    1b6a:	90 e0       	ldi	r25, 0x00	; 0
    1b6c:	0e 94 54 07 	call	0xea8	; 0xea8 <left_degrees>
    1b70:	8f ef       	ldi	r24, 0xFF	; 255
    1b72:	9f ef       	ldi	r25, 0xFF	; 255
    1b74:	ac e2       	ldi	r26, 0x2C	; 44
    1b76:	81 50       	subi	r24, 0x01	; 1
    1b78:	90 40       	sbci	r25, 0x00	; 0
    1b7a:	a0 40       	sbci	r26, 0x00	; 0
    1b7c:	e1 f7       	brne	.-8      	; 0x1b76 <main+0x6b0>
    1b7e:	00 c0       	rjmp	.+0      	; 0x1b80 <main+0x6ba>
    1b80:	00 00       	nop
						_delay_ms(1000);
						
						servo_1(75);
    1b82:	8b e4       	ldi	r24, 0x4B	; 75
    1b84:	0e 94 d1 07 	call	0xfa2	; 0xfa2 <servo_1>
    1b88:	8f ef       	ldi	r24, 0xFF	; 255
    1b8a:	9f ef       	ldi	r25, 0xFF	; 255
    1b8c:	ac e2       	ldi	r26, 0x2C	; 44
    1b8e:	81 50       	subi	r24, 0x01	; 1
    1b90:	90 40       	sbci	r25, 0x00	; 0
    1b92:	a0 40       	sbci	r26, 0x00	; 0
    1b94:	e1 f7       	brne	.-8      	; 0x1b8e <main+0x6c8>
    1b96:	00 c0       	rjmp	.+0      	; 0x1b98 <main+0x6d2>
    1b98:	00 00       	nop
						_delay_ms(1000);
						servo_1_rest();
    1b9a:	0e 94 ea 07 	call	0xfd4	; 0xfd4 <servo_1_rest>
						buzzer_on();
    1b9e:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <buzzer_on>
    1ba2:	8f ef       	ldi	r24, 0xFF	; 255
    1ba4:	9f ef       	ldi	r25, 0xFF	; 255
    1ba6:	ac e2       	ldi	r26, 0x2C	; 44
    1ba8:	81 50       	subi	r24, 0x01	; 1
    1baa:	90 40       	sbci	r25, 0x00	; 0
    1bac:	a0 40       	sbci	r26, 0x00	; 0
    1bae:	e1 f7       	brne	.-8      	; 0x1ba8 <main+0x6e2>
    1bb0:	00 c0       	rjmp	.+0      	; 0x1bb2 <main+0x6ec>
    1bb2:	00 00       	nop
						_delay_ms(1000);
						buzzer_off();
    1bb4:	0e 94 5f 06 	call	0xcbe	; 0xcbe <buzzer_off>
						right_count();
    1bb8:	0e 94 f5 07 	call	0xfea	; 0xfea <right_count>
						stop();
    1bbc:	0e 94 83 06 	call	0xd06	; 0xd06 <stop>
					}
					led_off();
    1bc0:	0e 94 56 05 	call	0xaac	; 0xaac <led_off>
					val[i]=0;
    1bc4:	8b 81       	ldd	r24, Y+3	; 0x03
    1bc6:	9c 81       	ldd	r25, Y+4	; 0x04
    1bc8:	88 0f       	add	r24, r24
    1bca:	99 1f       	adc	r25, r25
    1bcc:	80 0f       	add	r24, r16
    1bce:	91 1f       	adc	r25, r17
    1bd0:	dc 01       	movw	r26, r24
    1bd2:	11 96       	adiw	r26, 0x01	; 1
    1bd4:	1c 92       	st	X, r1
    1bd6:	1e 92       	st	-X, r1
					val[i-1]=0;
    1bd8:	c7 01       	movw	r24, r14
    1bda:	88 0f       	add	r24, r24
    1bdc:	99 1f       	adc	r25, r25
    1bde:	80 0f       	add	r24, r16
    1be0:	91 1f       	adc	r25, r17
    1be2:	fc 01       	movw	r30, r24
    1be4:	11 82       	std	Z+1, r1	; 0x01
    1be6:	10 82       	st	Z, r1
				}
				
			}
			
			//red procedure ends
			for(int i=1;i<=4;i++)
    1be8:	3b 82       	std	Y+3, r3	; 0x03
    1bea:	2c 82       	std	Y+4, r2	; 0x04
    1bec:	1e cf       	rjmp	.-452    	; 0x1a2a <main+0x564>
    1bee:	8b 81       	ldd	r24, Y+3	; 0x03
    1bf0:	9c 81       	ldd	r25, Y+4	; 0x04
    1bf2:	01 96       	adiw	r24, 0x01	; 1
    1bf4:	9c 83       	std	Y+4, r25	; 0x04
    1bf6:	8b 83       	std	Y+3, r24	; 0x03
    1bf8:	85 30       	cpi	r24, 0x05	; 5
    1bfa:	91 05       	cpc	r25, r1
    1bfc:	0c f4       	brge	.+2      	; 0x1c00 <main+0x73a>
    1bfe:	15 cf       	rjmp	.-470    	; 0x1a2a <main+0x564>
					val[i-1]=0;
					i=0;
				}
			}
			//green procedure ends
			add(cur);
    1c00:	89 81       	ldd	r24, Y+1	; 0x01
    1c02:	9a 81       	ldd	r25, Y+2	; 0x02
    1c04:	0e 94 b5 02 	call	0x56a	; 0x56a <add>
			//rec=375;
			data=200;     //search can start now
    1c08:	88 ec       	ldi	r24, 0xC8	; 200
    1c0a:	90 e0       	ldi	r25, 0x00	; 0
    1c0c:	90 93 6c 0a 	sts	0x0A6C, r25
    1c10:	80 93 6b 0a 	sts	0x0A6B, r24
			UDR0=data;
    1c14:	88 ec       	ldi	r24, 0xC8	; 200
    1c16:	80 93 c6 00 	sts	0x00C6, r24
    1c1a:	8f ef       	ldi	r24, 0xFF	; 255
    1c1c:	9f ef       	ldi	r25, 0xFF	; 255
    1c1e:	a6 e8       	ldi	r26, 0x86	; 134
    1c20:	81 50       	subi	r24, 0x01	; 1
    1c22:	90 40       	sbci	r25, 0x00	; 0
    1c24:	a0 40       	sbci	r26, 0x00	; 0
    1c26:	e1 f7       	brne	.-8      	; 0x1c20 <main+0x75a>
    1c28:	00 c0       	rjmp	.+0      	; 0x1c2a <main+0x764>
    1c2a:	00 00       	nop
			_delay_ms(3000);
			
			if(z==149)			//every survivor is served 
    1c2c:	80 91 9c 04 	lds	r24, 0x049C
    1c30:	90 91 9d 04 	lds	r25, 0x049D
    1c34:	85 39       	cpi	r24, 0x95	; 149
    1c36:	91 05       	cpc	r25, r1
    1c38:	09 f0       	breq	.+2      	; 0x1c3c <main+0x776>
    1c3a:	9d cc       	rjmp	.-1734   	; 0x1576 <main+0xb0>
			{
				buzzer_on();
    1c3c:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <buzzer_on>
    1c40:	8f ef       	ldi	r24, 0xFF	; 255
    1c42:	9f ef       	ldi	r25, 0xFF	; 255
    1c44:	a6 e7       	ldi	r26, 0x76	; 118
    1c46:	b1 e0       	ldi	r27, 0x01	; 1
    1c48:	81 50       	subi	r24, 0x01	; 1
    1c4a:	90 40       	sbci	r25, 0x00	; 0
    1c4c:	a0 40       	sbci	r26, 0x00	; 0
    1c4e:	b0 40       	sbci	r27, 0x00	; 0
    1c50:	d9 f7       	brne	.-10     	; 0x1c48 <main+0x782>
    1c52:	00 c0       	rjmp	.+0      	; 0x1c54 <main+0x78e>
    1c54:	00 00       	nop
				_delay_ms(10000);
				buzzer_off();
    1c56:	0e 94 5f 06 	call	0xcbe	; 0xcbe <buzzer_off>
			
		}
		
	}
	
}
    1c5a:	80 e0       	ldi	r24, 0x00	; 0
    1c5c:	90 e0       	ldi	r25, 0x00	; 0
    1c5e:	0f 90       	pop	r0
    1c60:	0f 90       	pop	r0
    1c62:	0f 90       	pop	r0
    1c64:	0f 90       	pop	r0
    1c66:	df 91       	pop	r29
    1c68:	cf 91       	pop	r28
    1c6a:	1f 91       	pop	r17
    1c6c:	0f 91       	pop	r16
    1c6e:	ff 90       	pop	r15
    1c70:	ef 90       	pop	r14
    1c72:	df 90       	pop	r13
    1c74:	cf 90       	pop	r12
    1c76:	bf 90       	pop	r11
    1c78:	af 90       	pop	r10
    1c7a:	9f 90       	pop	r9
    1c7c:	8f 90       	pop	r8
    1c7e:	7f 90       	pop	r7
    1c80:	6f 90       	pop	r6
    1c82:	5f 90       	pop	r5
    1c84:	4f 90       	pop	r4
    1c86:	3f 90       	pop	r3
    1c88:	2f 90       	pop	r2
    1c8a:	08 95       	ret

00001c8c <__subsf3>:
    1c8c:	50 58       	subi	r21, 0x80	; 128

00001c8e <__addsf3>:
    1c8e:	bb 27       	eor	r27, r27
    1c90:	aa 27       	eor	r26, r26
    1c92:	0e d0       	rcall	.+28     	; 0x1cb0 <__addsf3x>
    1c94:	4d c1       	rjmp	.+666    	; 0x1f30 <__fp_round>
    1c96:	3e d1       	rcall	.+636    	; 0x1f14 <__fp_pscA>
    1c98:	30 f0       	brcs	.+12     	; 0x1ca6 <__addsf3+0x18>
    1c9a:	43 d1       	rcall	.+646    	; 0x1f22 <__fp_pscB>
    1c9c:	20 f0       	brcs	.+8      	; 0x1ca6 <__addsf3+0x18>
    1c9e:	31 f4       	brne	.+12     	; 0x1cac <__addsf3+0x1e>
    1ca0:	9f 3f       	cpi	r25, 0xFF	; 255
    1ca2:	11 f4       	brne	.+4      	; 0x1ca8 <__addsf3+0x1a>
    1ca4:	1e f4       	brtc	.+6      	; 0x1cac <__addsf3+0x1e>
    1ca6:	33 c1       	rjmp	.+614    	; 0x1f0e <__fp_nan>
    1ca8:	0e f4       	brtc	.+2      	; 0x1cac <__addsf3+0x1e>
    1caa:	e0 95       	com	r30
    1cac:	e7 fb       	bst	r30, 7
    1cae:	29 c1       	rjmp	.+594    	; 0x1f02 <__fp_inf>

00001cb0 <__addsf3x>:
    1cb0:	e9 2f       	mov	r30, r25
    1cb2:	4f d1       	rcall	.+670    	; 0x1f52 <__fp_split3>
    1cb4:	80 f3       	brcs	.-32     	; 0x1c96 <__addsf3+0x8>
    1cb6:	ba 17       	cp	r27, r26
    1cb8:	62 07       	cpc	r22, r18
    1cba:	73 07       	cpc	r23, r19
    1cbc:	84 07       	cpc	r24, r20
    1cbe:	95 07       	cpc	r25, r21
    1cc0:	18 f0       	brcs	.+6      	; 0x1cc8 <__addsf3x+0x18>
    1cc2:	71 f4       	brne	.+28     	; 0x1ce0 <__addsf3x+0x30>
    1cc4:	9e f5       	brtc	.+102    	; 0x1d2c <__addsf3x+0x7c>
    1cc6:	67 c1       	rjmp	.+718    	; 0x1f96 <__fp_zero>
    1cc8:	0e f4       	brtc	.+2      	; 0x1ccc <__addsf3x+0x1c>
    1cca:	e0 95       	com	r30
    1ccc:	0b 2e       	mov	r0, r27
    1cce:	ba 2f       	mov	r27, r26
    1cd0:	a0 2d       	mov	r26, r0
    1cd2:	0b 01       	movw	r0, r22
    1cd4:	b9 01       	movw	r22, r18
    1cd6:	90 01       	movw	r18, r0
    1cd8:	0c 01       	movw	r0, r24
    1cda:	ca 01       	movw	r24, r20
    1cdc:	a0 01       	movw	r20, r0
    1cde:	11 24       	eor	r1, r1
    1ce0:	ff 27       	eor	r31, r31
    1ce2:	59 1b       	sub	r21, r25
    1ce4:	99 f0       	breq	.+38     	; 0x1d0c <__addsf3x+0x5c>
    1ce6:	59 3f       	cpi	r21, 0xF9	; 249
    1ce8:	50 f4       	brcc	.+20     	; 0x1cfe <__addsf3x+0x4e>
    1cea:	50 3e       	cpi	r21, 0xE0	; 224
    1cec:	68 f1       	brcs	.+90     	; 0x1d48 <__addsf3x+0x98>
    1cee:	1a 16       	cp	r1, r26
    1cf0:	f0 40       	sbci	r31, 0x00	; 0
    1cf2:	a2 2f       	mov	r26, r18
    1cf4:	23 2f       	mov	r18, r19
    1cf6:	34 2f       	mov	r19, r20
    1cf8:	44 27       	eor	r20, r20
    1cfa:	58 5f       	subi	r21, 0xF8	; 248
    1cfc:	f3 cf       	rjmp	.-26     	; 0x1ce4 <__addsf3x+0x34>
    1cfe:	46 95       	lsr	r20
    1d00:	37 95       	ror	r19
    1d02:	27 95       	ror	r18
    1d04:	a7 95       	ror	r26
    1d06:	f0 40       	sbci	r31, 0x00	; 0
    1d08:	53 95       	inc	r21
    1d0a:	c9 f7       	brne	.-14     	; 0x1cfe <__addsf3x+0x4e>
    1d0c:	7e f4       	brtc	.+30     	; 0x1d2c <__addsf3x+0x7c>
    1d0e:	1f 16       	cp	r1, r31
    1d10:	ba 0b       	sbc	r27, r26
    1d12:	62 0b       	sbc	r22, r18
    1d14:	73 0b       	sbc	r23, r19
    1d16:	84 0b       	sbc	r24, r20
    1d18:	ba f0       	brmi	.+46     	; 0x1d48 <__addsf3x+0x98>
    1d1a:	91 50       	subi	r25, 0x01	; 1
    1d1c:	a1 f0       	breq	.+40     	; 0x1d46 <__addsf3x+0x96>
    1d1e:	ff 0f       	add	r31, r31
    1d20:	bb 1f       	adc	r27, r27
    1d22:	66 1f       	adc	r22, r22
    1d24:	77 1f       	adc	r23, r23
    1d26:	88 1f       	adc	r24, r24
    1d28:	c2 f7       	brpl	.-16     	; 0x1d1a <__addsf3x+0x6a>
    1d2a:	0e c0       	rjmp	.+28     	; 0x1d48 <__addsf3x+0x98>
    1d2c:	ba 0f       	add	r27, r26
    1d2e:	62 1f       	adc	r22, r18
    1d30:	73 1f       	adc	r23, r19
    1d32:	84 1f       	adc	r24, r20
    1d34:	48 f4       	brcc	.+18     	; 0x1d48 <__addsf3x+0x98>
    1d36:	87 95       	ror	r24
    1d38:	77 95       	ror	r23
    1d3a:	67 95       	ror	r22
    1d3c:	b7 95       	ror	r27
    1d3e:	f7 95       	ror	r31
    1d40:	9e 3f       	cpi	r25, 0xFE	; 254
    1d42:	08 f0       	brcs	.+2      	; 0x1d46 <__addsf3x+0x96>
    1d44:	b3 cf       	rjmp	.-154    	; 0x1cac <__addsf3+0x1e>
    1d46:	93 95       	inc	r25
    1d48:	88 0f       	add	r24, r24
    1d4a:	08 f0       	brcs	.+2      	; 0x1d4e <__addsf3x+0x9e>
    1d4c:	99 27       	eor	r25, r25
    1d4e:	ee 0f       	add	r30, r30
    1d50:	97 95       	ror	r25
    1d52:	87 95       	ror	r24
    1d54:	08 95       	ret

00001d56 <__divsf3>:
    1d56:	0c d0       	rcall	.+24     	; 0x1d70 <__divsf3x>
    1d58:	eb c0       	rjmp	.+470    	; 0x1f30 <__fp_round>
    1d5a:	e3 d0       	rcall	.+454    	; 0x1f22 <__fp_pscB>
    1d5c:	40 f0       	brcs	.+16     	; 0x1d6e <__divsf3+0x18>
    1d5e:	da d0       	rcall	.+436    	; 0x1f14 <__fp_pscA>
    1d60:	30 f0       	brcs	.+12     	; 0x1d6e <__divsf3+0x18>
    1d62:	21 f4       	brne	.+8      	; 0x1d6c <__divsf3+0x16>
    1d64:	5f 3f       	cpi	r21, 0xFF	; 255
    1d66:	19 f0       	breq	.+6      	; 0x1d6e <__divsf3+0x18>
    1d68:	cc c0       	rjmp	.+408    	; 0x1f02 <__fp_inf>
    1d6a:	51 11       	cpse	r21, r1
    1d6c:	15 c1       	rjmp	.+554    	; 0x1f98 <__fp_szero>
    1d6e:	cf c0       	rjmp	.+414    	; 0x1f0e <__fp_nan>

00001d70 <__divsf3x>:
    1d70:	f0 d0       	rcall	.+480    	; 0x1f52 <__fp_split3>
    1d72:	98 f3       	brcs	.-26     	; 0x1d5a <__divsf3+0x4>

00001d74 <__divsf3_pse>:
    1d74:	99 23       	and	r25, r25
    1d76:	c9 f3       	breq	.-14     	; 0x1d6a <__divsf3+0x14>
    1d78:	55 23       	and	r21, r21
    1d7a:	b1 f3       	breq	.-20     	; 0x1d68 <__divsf3+0x12>
    1d7c:	95 1b       	sub	r25, r21
    1d7e:	55 0b       	sbc	r21, r21
    1d80:	bb 27       	eor	r27, r27
    1d82:	aa 27       	eor	r26, r26
    1d84:	62 17       	cp	r22, r18
    1d86:	73 07       	cpc	r23, r19
    1d88:	84 07       	cpc	r24, r20
    1d8a:	38 f0       	brcs	.+14     	; 0x1d9a <__divsf3_pse+0x26>
    1d8c:	9f 5f       	subi	r25, 0xFF	; 255
    1d8e:	5f 4f       	sbci	r21, 0xFF	; 255
    1d90:	22 0f       	add	r18, r18
    1d92:	33 1f       	adc	r19, r19
    1d94:	44 1f       	adc	r20, r20
    1d96:	aa 1f       	adc	r26, r26
    1d98:	a9 f3       	breq	.-22     	; 0x1d84 <__divsf3_pse+0x10>
    1d9a:	33 d0       	rcall	.+102    	; 0x1e02 <__divsf3_pse+0x8e>
    1d9c:	0e 2e       	mov	r0, r30
    1d9e:	3a f0       	brmi	.+14     	; 0x1dae <__divsf3_pse+0x3a>
    1da0:	e0 e8       	ldi	r30, 0x80	; 128
    1da2:	30 d0       	rcall	.+96     	; 0x1e04 <__divsf3_pse+0x90>
    1da4:	91 50       	subi	r25, 0x01	; 1
    1da6:	50 40       	sbci	r21, 0x00	; 0
    1da8:	e6 95       	lsr	r30
    1daa:	00 1c       	adc	r0, r0
    1dac:	ca f7       	brpl	.-14     	; 0x1da0 <__divsf3_pse+0x2c>
    1dae:	29 d0       	rcall	.+82     	; 0x1e02 <__divsf3_pse+0x8e>
    1db0:	fe 2f       	mov	r31, r30
    1db2:	27 d0       	rcall	.+78     	; 0x1e02 <__divsf3_pse+0x8e>
    1db4:	66 0f       	add	r22, r22
    1db6:	77 1f       	adc	r23, r23
    1db8:	88 1f       	adc	r24, r24
    1dba:	bb 1f       	adc	r27, r27
    1dbc:	26 17       	cp	r18, r22
    1dbe:	37 07       	cpc	r19, r23
    1dc0:	48 07       	cpc	r20, r24
    1dc2:	ab 07       	cpc	r26, r27
    1dc4:	b0 e8       	ldi	r27, 0x80	; 128
    1dc6:	09 f0       	breq	.+2      	; 0x1dca <__divsf3_pse+0x56>
    1dc8:	bb 0b       	sbc	r27, r27
    1dca:	80 2d       	mov	r24, r0
    1dcc:	bf 01       	movw	r22, r30
    1dce:	ff 27       	eor	r31, r31
    1dd0:	93 58       	subi	r25, 0x83	; 131
    1dd2:	5f 4f       	sbci	r21, 0xFF	; 255
    1dd4:	2a f0       	brmi	.+10     	; 0x1de0 <__divsf3_pse+0x6c>
    1dd6:	9e 3f       	cpi	r25, 0xFE	; 254
    1dd8:	51 05       	cpc	r21, r1
    1dda:	68 f0       	brcs	.+26     	; 0x1df6 <__divsf3_pse+0x82>
    1ddc:	92 c0       	rjmp	.+292    	; 0x1f02 <__fp_inf>
    1dde:	dc c0       	rjmp	.+440    	; 0x1f98 <__fp_szero>
    1de0:	5f 3f       	cpi	r21, 0xFF	; 255
    1de2:	ec f3       	brlt	.-6      	; 0x1dde <__divsf3_pse+0x6a>
    1de4:	98 3e       	cpi	r25, 0xE8	; 232
    1de6:	dc f3       	brlt	.-10     	; 0x1dde <__divsf3_pse+0x6a>
    1de8:	86 95       	lsr	r24
    1dea:	77 95       	ror	r23
    1dec:	67 95       	ror	r22
    1dee:	b7 95       	ror	r27
    1df0:	f7 95       	ror	r31
    1df2:	9f 5f       	subi	r25, 0xFF	; 255
    1df4:	c9 f7       	brne	.-14     	; 0x1de8 <__divsf3_pse+0x74>
    1df6:	88 0f       	add	r24, r24
    1df8:	91 1d       	adc	r25, r1
    1dfa:	96 95       	lsr	r25
    1dfc:	87 95       	ror	r24
    1dfe:	97 f9       	bld	r25, 7
    1e00:	08 95       	ret
    1e02:	e1 e0       	ldi	r30, 0x01	; 1
    1e04:	66 0f       	add	r22, r22
    1e06:	77 1f       	adc	r23, r23
    1e08:	88 1f       	adc	r24, r24
    1e0a:	bb 1f       	adc	r27, r27
    1e0c:	62 17       	cp	r22, r18
    1e0e:	73 07       	cpc	r23, r19
    1e10:	84 07       	cpc	r24, r20
    1e12:	ba 07       	cpc	r27, r26
    1e14:	20 f0       	brcs	.+8      	; 0x1e1e <__divsf3_pse+0xaa>
    1e16:	62 1b       	sub	r22, r18
    1e18:	73 0b       	sbc	r23, r19
    1e1a:	84 0b       	sbc	r24, r20
    1e1c:	ba 0b       	sbc	r27, r26
    1e1e:	ee 1f       	adc	r30, r30
    1e20:	88 f7       	brcc	.-30     	; 0x1e04 <__divsf3_pse+0x90>
    1e22:	e0 95       	com	r30
    1e24:	08 95       	ret

00001e26 <__fixsfsi>:
    1e26:	04 d0       	rcall	.+8      	; 0x1e30 <__fixunssfsi>
    1e28:	68 94       	set
    1e2a:	b1 11       	cpse	r27, r1
    1e2c:	b5 c0       	rjmp	.+362    	; 0x1f98 <__fp_szero>
    1e2e:	08 95       	ret

00001e30 <__fixunssfsi>:
    1e30:	98 d0       	rcall	.+304    	; 0x1f62 <__fp_splitA>
    1e32:	88 f0       	brcs	.+34     	; 0x1e56 <__fixunssfsi+0x26>
    1e34:	9f 57       	subi	r25, 0x7F	; 127
    1e36:	90 f0       	brcs	.+36     	; 0x1e5c <__fixunssfsi+0x2c>
    1e38:	b9 2f       	mov	r27, r25
    1e3a:	99 27       	eor	r25, r25
    1e3c:	b7 51       	subi	r27, 0x17	; 23
    1e3e:	a0 f0       	brcs	.+40     	; 0x1e68 <__fixunssfsi+0x38>
    1e40:	d1 f0       	breq	.+52     	; 0x1e76 <__fixunssfsi+0x46>
    1e42:	66 0f       	add	r22, r22
    1e44:	77 1f       	adc	r23, r23
    1e46:	88 1f       	adc	r24, r24
    1e48:	99 1f       	adc	r25, r25
    1e4a:	1a f0       	brmi	.+6      	; 0x1e52 <__fixunssfsi+0x22>
    1e4c:	ba 95       	dec	r27
    1e4e:	c9 f7       	brne	.-14     	; 0x1e42 <__fixunssfsi+0x12>
    1e50:	12 c0       	rjmp	.+36     	; 0x1e76 <__fixunssfsi+0x46>
    1e52:	b1 30       	cpi	r27, 0x01	; 1
    1e54:	81 f0       	breq	.+32     	; 0x1e76 <__fixunssfsi+0x46>
    1e56:	9f d0       	rcall	.+318    	; 0x1f96 <__fp_zero>
    1e58:	b1 e0       	ldi	r27, 0x01	; 1
    1e5a:	08 95       	ret
    1e5c:	9c c0       	rjmp	.+312    	; 0x1f96 <__fp_zero>
    1e5e:	67 2f       	mov	r22, r23
    1e60:	78 2f       	mov	r23, r24
    1e62:	88 27       	eor	r24, r24
    1e64:	b8 5f       	subi	r27, 0xF8	; 248
    1e66:	39 f0       	breq	.+14     	; 0x1e76 <__fixunssfsi+0x46>
    1e68:	b9 3f       	cpi	r27, 0xF9	; 249
    1e6a:	cc f3       	brlt	.-14     	; 0x1e5e <__fixunssfsi+0x2e>
    1e6c:	86 95       	lsr	r24
    1e6e:	77 95       	ror	r23
    1e70:	67 95       	ror	r22
    1e72:	b3 95       	inc	r27
    1e74:	d9 f7       	brne	.-10     	; 0x1e6c <__fixunssfsi+0x3c>
    1e76:	3e f4       	brtc	.+14     	; 0x1e86 <__fixunssfsi+0x56>
    1e78:	90 95       	com	r25
    1e7a:	80 95       	com	r24
    1e7c:	70 95       	com	r23
    1e7e:	61 95       	neg	r22
    1e80:	7f 4f       	sbci	r23, 0xFF	; 255
    1e82:	8f 4f       	sbci	r24, 0xFF	; 255
    1e84:	9f 4f       	sbci	r25, 0xFF	; 255
    1e86:	08 95       	ret

00001e88 <__floatunsisf>:
    1e88:	e8 94       	clt
    1e8a:	09 c0       	rjmp	.+18     	; 0x1e9e <__floatsisf+0x12>

00001e8c <__floatsisf>:
    1e8c:	97 fb       	bst	r25, 7
    1e8e:	3e f4       	brtc	.+14     	; 0x1e9e <__floatsisf+0x12>
    1e90:	90 95       	com	r25
    1e92:	80 95       	com	r24
    1e94:	70 95       	com	r23
    1e96:	61 95       	neg	r22
    1e98:	7f 4f       	sbci	r23, 0xFF	; 255
    1e9a:	8f 4f       	sbci	r24, 0xFF	; 255
    1e9c:	9f 4f       	sbci	r25, 0xFF	; 255
    1e9e:	99 23       	and	r25, r25
    1ea0:	a9 f0       	breq	.+42     	; 0x1ecc <__floatsisf+0x40>
    1ea2:	f9 2f       	mov	r31, r25
    1ea4:	96 e9       	ldi	r25, 0x96	; 150
    1ea6:	bb 27       	eor	r27, r27
    1ea8:	93 95       	inc	r25
    1eaa:	f6 95       	lsr	r31
    1eac:	87 95       	ror	r24
    1eae:	77 95       	ror	r23
    1eb0:	67 95       	ror	r22
    1eb2:	b7 95       	ror	r27
    1eb4:	f1 11       	cpse	r31, r1
    1eb6:	f8 cf       	rjmp	.-16     	; 0x1ea8 <__floatsisf+0x1c>
    1eb8:	fa f4       	brpl	.+62     	; 0x1ef8 <__floatsisf+0x6c>
    1eba:	bb 0f       	add	r27, r27
    1ebc:	11 f4       	brne	.+4      	; 0x1ec2 <__floatsisf+0x36>
    1ebe:	60 ff       	sbrs	r22, 0
    1ec0:	1b c0       	rjmp	.+54     	; 0x1ef8 <__floatsisf+0x6c>
    1ec2:	6f 5f       	subi	r22, 0xFF	; 255
    1ec4:	7f 4f       	sbci	r23, 0xFF	; 255
    1ec6:	8f 4f       	sbci	r24, 0xFF	; 255
    1ec8:	9f 4f       	sbci	r25, 0xFF	; 255
    1eca:	16 c0       	rjmp	.+44     	; 0x1ef8 <__floatsisf+0x6c>
    1ecc:	88 23       	and	r24, r24
    1ece:	11 f0       	breq	.+4      	; 0x1ed4 <__floatsisf+0x48>
    1ed0:	96 e9       	ldi	r25, 0x96	; 150
    1ed2:	11 c0       	rjmp	.+34     	; 0x1ef6 <__floatsisf+0x6a>
    1ed4:	77 23       	and	r23, r23
    1ed6:	21 f0       	breq	.+8      	; 0x1ee0 <__floatsisf+0x54>
    1ed8:	9e e8       	ldi	r25, 0x8E	; 142
    1eda:	87 2f       	mov	r24, r23
    1edc:	76 2f       	mov	r23, r22
    1ede:	05 c0       	rjmp	.+10     	; 0x1eea <__floatsisf+0x5e>
    1ee0:	66 23       	and	r22, r22
    1ee2:	71 f0       	breq	.+28     	; 0x1f00 <__floatsisf+0x74>
    1ee4:	96 e8       	ldi	r25, 0x86	; 134
    1ee6:	86 2f       	mov	r24, r22
    1ee8:	70 e0       	ldi	r23, 0x00	; 0
    1eea:	60 e0       	ldi	r22, 0x00	; 0
    1eec:	2a f0       	brmi	.+10     	; 0x1ef8 <__floatsisf+0x6c>
    1eee:	9a 95       	dec	r25
    1ef0:	66 0f       	add	r22, r22
    1ef2:	77 1f       	adc	r23, r23
    1ef4:	88 1f       	adc	r24, r24
    1ef6:	da f7       	brpl	.-10     	; 0x1eee <__floatsisf+0x62>
    1ef8:	88 0f       	add	r24, r24
    1efa:	96 95       	lsr	r25
    1efc:	87 95       	ror	r24
    1efe:	97 f9       	bld	r25, 7
    1f00:	08 95       	ret

00001f02 <__fp_inf>:
    1f02:	97 f9       	bld	r25, 7
    1f04:	9f 67       	ori	r25, 0x7F	; 127
    1f06:	80 e8       	ldi	r24, 0x80	; 128
    1f08:	70 e0       	ldi	r23, 0x00	; 0
    1f0a:	60 e0       	ldi	r22, 0x00	; 0
    1f0c:	08 95       	ret

00001f0e <__fp_nan>:
    1f0e:	9f ef       	ldi	r25, 0xFF	; 255
    1f10:	80 ec       	ldi	r24, 0xC0	; 192
    1f12:	08 95       	ret

00001f14 <__fp_pscA>:
    1f14:	00 24       	eor	r0, r0
    1f16:	0a 94       	dec	r0
    1f18:	16 16       	cp	r1, r22
    1f1a:	17 06       	cpc	r1, r23
    1f1c:	18 06       	cpc	r1, r24
    1f1e:	09 06       	cpc	r0, r25
    1f20:	08 95       	ret

00001f22 <__fp_pscB>:
    1f22:	00 24       	eor	r0, r0
    1f24:	0a 94       	dec	r0
    1f26:	12 16       	cp	r1, r18
    1f28:	13 06       	cpc	r1, r19
    1f2a:	14 06       	cpc	r1, r20
    1f2c:	05 06       	cpc	r0, r21
    1f2e:	08 95       	ret

00001f30 <__fp_round>:
    1f30:	09 2e       	mov	r0, r25
    1f32:	03 94       	inc	r0
    1f34:	00 0c       	add	r0, r0
    1f36:	11 f4       	brne	.+4      	; 0x1f3c <__fp_round+0xc>
    1f38:	88 23       	and	r24, r24
    1f3a:	52 f0       	brmi	.+20     	; 0x1f50 <__fp_round+0x20>
    1f3c:	bb 0f       	add	r27, r27
    1f3e:	40 f4       	brcc	.+16     	; 0x1f50 <__fp_round+0x20>
    1f40:	bf 2b       	or	r27, r31
    1f42:	11 f4       	brne	.+4      	; 0x1f48 <__fp_round+0x18>
    1f44:	60 ff       	sbrs	r22, 0
    1f46:	04 c0       	rjmp	.+8      	; 0x1f50 <__fp_round+0x20>
    1f48:	6f 5f       	subi	r22, 0xFF	; 255
    1f4a:	7f 4f       	sbci	r23, 0xFF	; 255
    1f4c:	8f 4f       	sbci	r24, 0xFF	; 255
    1f4e:	9f 4f       	sbci	r25, 0xFF	; 255
    1f50:	08 95       	ret

00001f52 <__fp_split3>:
    1f52:	57 fd       	sbrc	r21, 7
    1f54:	90 58       	subi	r25, 0x80	; 128
    1f56:	44 0f       	add	r20, r20
    1f58:	55 1f       	adc	r21, r21
    1f5a:	59 f0       	breq	.+22     	; 0x1f72 <__fp_splitA+0x10>
    1f5c:	5f 3f       	cpi	r21, 0xFF	; 255
    1f5e:	71 f0       	breq	.+28     	; 0x1f7c <__fp_splitA+0x1a>
    1f60:	47 95       	ror	r20

00001f62 <__fp_splitA>:
    1f62:	88 0f       	add	r24, r24
    1f64:	97 fb       	bst	r25, 7
    1f66:	99 1f       	adc	r25, r25
    1f68:	61 f0       	breq	.+24     	; 0x1f82 <__fp_splitA+0x20>
    1f6a:	9f 3f       	cpi	r25, 0xFF	; 255
    1f6c:	79 f0       	breq	.+30     	; 0x1f8c <__fp_splitA+0x2a>
    1f6e:	87 95       	ror	r24
    1f70:	08 95       	ret
    1f72:	12 16       	cp	r1, r18
    1f74:	13 06       	cpc	r1, r19
    1f76:	14 06       	cpc	r1, r20
    1f78:	55 1f       	adc	r21, r21
    1f7a:	f2 cf       	rjmp	.-28     	; 0x1f60 <__fp_split3+0xe>
    1f7c:	46 95       	lsr	r20
    1f7e:	f1 df       	rcall	.-30     	; 0x1f62 <__fp_splitA>
    1f80:	08 c0       	rjmp	.+16     	; 0x1f92 <__fp_splitA+0x30>
    1f82:	16 16       	cp	r1, r22
    1f84:	17 06       	cpc	r1, r23
    1f86:	18 06       	cpc	r1, r24
    1f88:	99 1f       	adc	r25, r25
    1f8a:	f1 cf       	rjmp	.-30     	; 0x1f6e <__fp_splitA+0xc>
    1f8c:	86 95       	lsr	r24
    1f8e:	71 05       	cpc	r23, r1
    1f90:	61 05       	cpc	r22, r1
    1f92:	08 94       	sec
    1f94:	08 95       	ret

00001f96 <__fp_zero>:
    1f96:	e8 94       	clt

00001f98 <__fp_szero>:
    1f98:	bb 27       	eor	r27, r27
    1f9a:	66 27       	eor	r22, r22
    1f9c:	77 27       	eor	r23, r23
    1f9e:	cb 01       	movw	r24, r22
    1fa0:	97 f9       	bld	r25, 7
    1fa2:	08 95       	ret

00001fa4 <__mulsf3>:
    1fa4:	0b d0       	rcall	.+22     	; 0x1fbc <__mulsf3x>
    1fa6:	c4 cf       	rjmp	.-120    	; 0x1f30 <__fp_round>
    1fa8:	b5 df       	rcall	.-150    	; 0x1f14 <__fp_pscA>
    1faa:	28 f0       	brcs	.+10     	; 0x1fb6 <__mulsf3+0x12>
    1fac:	ba df       	rcall	.-140    	; 0x1f22 <__fp_pscB>
    1fae:	18 f0       	brcs	.+6      	; 0x1fb6 <__mulsf3+0x12>
    1fb0:	95 23       	and	r25, r21
    1fb2:	09 f0       	breq	.+2      	; 0x1fb6 <__mulsf3+0x12>
    1fb4:	a6 cf       	rjmp	.-180    	; 0x1f02 <__fp_inf>
    1fb6:	ab cf       	rjmp	.-170    	; 0x1f0e <__fp_nan>
    1fb8:	11 24       	eor	r1, r1
    1fba:	ee cf       	rjmp	.-36     	; 0x1f98 <__fp_szero>

00001fbc <__mulsf3x>:
    1fbc:	ca df       	rcall	.-108    	; 0x1f52 <__fp_split3>
    1fbe:	a0 f3       	brcs	.-24     	; 0x1fa8 <__mulsf3+0x4>

00001fc0 <__mulsf3_pse>:
    1fc0:	95 9f       	mul	r25, r21
    1fc2:	d1 f3       	breq	.-12     	; 0x1fb8 <__mulsf3+0x14>
    1fc4:	95 0f       	add	r25, r21
    1fc6:	50 e0       	ldi	r21, 0x00	; 0
    1fc8:	55 1f       	adc	r21, r21
    1fca:	62 9f       	mul	r22, r18
    1fcc:	f0 01       	movw	r30, r0
    1fce:	72 9f       	mul	r23, r18
    1fd0:	bb 27       	eor	r27, r27
    1fd2:	f0 0d       	add	r31, r0
    1fd4:	b1 1d       	adc	r27, r1
    1fd6:	63 9f       	mul	r22, r19
    1fd8:	aa 27       	eor	r26, r26
    1fda:	f0 0d       	add	r31, r0
    1fdc:	b1 1d       	adc	r27, r1
    1fde:	aa 1f       	adc	r26, r26
    1fe0:	64 9f       	mul	r22, r20
    1fe2:	66 27       	eor	r22, r22
    1fe4:	b0 0d       	add	r27, r0
    1fe6:	a1 1d       	adc	r26, r1
    1fe8:	66 1f       	adc	r22, r22
    1fea:	82 9f       	mul	r24, r18
    1fec:	22 27       	eor	r18, r18
    1fee:	b0 0d       	add	r27, r0
    1ff0:	a1 1d       	adc	r26, r1
    1ff2:	62 1f       	adc	r22, r18
    1ff4:	73 9f       	mul	r23, r19
    1ff6:	b0 0d       	add	r27, r0
    1ff8:	a1 1d       	adc	r26, r1
    1ffa:	62 1f       	adc	r22, r18
    1ffc:	83 9f       	mul	r24, r19
    1ffe:	a0 0d       	add	r26, r0
    2000:	61 1d       	adc	r22, r1
    2002:	22 1f       	adc	r18, r18
    2004:	74 9f       	mul	r23, r20
    2006:	33 27       	eor	r19, r19
    2008:	a0 0d       	add	r26, r0
    200a:	61 1d       	adc	r22, r1
    200c:	23 1f       	adc	r18, r19
    200e:	84 9f       	mul	r24, r20
    2010:	60 0d       	add	r22, r0
    2012:	21 1d       	adc	r18, r1
    2014:	82 2f       	mov	r24, r18
    2016:	76 2f       	mov	r23, r22
    2018:	6a 2f       	mov	r22, r26
    201a:	11 24       	eor	r1, r1
    201c:	9f 57       	subi	r25, 0x7F	; 127
    201e:	50 40       	sbci	r21, 0x00	; 0
    2020:	8a f0       	brmi	.+34     	; 0x2044 <__mulsf3_pse+0x84>
    2022:	e1 f0       	breq	.+56     	; 0x205c <__mulsf3_pse+0x9c>
    2024:	88 23       	and	r24, r24
    2026:	4a f0       	brmi	.+18     	; 0x203a <__mulsf3_pse+0x7a>
    2028:	ee 0f       	add	r30, r30
    202a:	ff 1f       	adc	r31, r31
    202c:	bb 1f       	adc	r27, r27
    202e:	66 1f       	adc	r22, r22
    2030:	77 1f       	adc	r23, r23
    2032:	88 1f       	adc	r24, r24
    2034:	91 50       	subi	r25, 0x01	; 1
    2036:	50 40       	sbci	r21, 0x00	; 0
    2038:	a9 f7       	brne	.-22     	; 0x2024 <__mulsf3_pse+0x64>
    203a:	9e 3f       	cpi	r25, 0xFE	; 254
    203c:	51 05       	cpc	r21, r1
    203e:	70 f0       	brcs	.+28     	; 0x205c <__mulsf3_pse+0x9c>
    2040:	60 cf       	rjmp	.-320    	; 0x1f02 <__fp_inf>
    2042:	aa cf       	rjmp	.-172    	; 0x1f98 <__fp_szero>
    2044:	5f 3f       	cpi	r21, 0xFF	; 255
    2046:	ec f3       	brlt	.-6      	; 0x2042 <__mulsf3_pse+0x82>
    2048:	98 3e       	cpi	r25, 0xE8	; 232
    204a:	dc f3       	brlt	.-10     	; 0x2042 <__mulsf3_pse+0x82>
    204c:	86 95       	lsr	r24
    204e:	77 95       	ror	r23
    2050:	67 95       	ror	r22
    2052:	b7 95       	ror	r27
    2054:	f7 95       	ror	r31
    2056:	e7 95       	ror	r30
    2058:	9f 5f       	subi	r25, 0xFF	; 255
    205a:	c1 f7       	brne	.-16     	; 0x204c <__mulsf3_pse+0x8c>
    205c:	fe 2b       	or	r31, r30
    205e:	88 0f       	add	r24, r24
    2060:	91 1d       	adc	r25, r1
    2062:	96 95       	lsr	r25
    2064:	87 95       	ror	r24
    2066:	97 f9       	bld	r25, 7
    2068:	08 95       	ret

0000206a <pow>:
    206a:	fa 01       	movw	r30, r20
    206c:	ee 0f       	add	r30, r30
    206e:	ff 1f       	adc	r31, r31
    2070:	30 96       	adiw	r30, 0x00	; 0
    2072:	21 05       	cpc	r18, r1
    2074:	31 05       	cpc	r19, r1
    2076:	99 f1       	breq	.+102    	; 0x20de <pow+0x74>
    2078:	61 15       	cp	r22, r1
    207a:	71 05       	cpc	r23, r1
    207c:	61 f4       	brne	.+24     	; 0x2096 <pow+0x2c>
    207e:	80 38       	cpi	r24, 0x80	; 128
    2080:	bf e3       	ldi	r27, 0x3F	; 63
    2082:	9b 07       	cpc	r25, r27
    2084:	49 f1       	breq	.+82     	; 0x20d8 <pow+0x6e>
    2086:	68 94       	set
    2088:	90 38       	cpi	r25, 0x80	; 128
    208a:	81 05       	cpc	r24, r1
    208c:	61 f0       	breq	.+24     	; 0x20a6 <pow+0x3c>
    208e:	80 38       	cpi	r24, 0x80	; 128
    2090:	bf ef       	ldi	r27, 0xFF	; 255
    2092:	9b 07       	cpc	r25, r27
    2094:	41 f0       	breq	.+16     	; 0x20a6 <pow+0x3c>
    2096:	99 23       	and	r25, r25
    2098:	42 f5       	brpl	.+80     	; 0x20ea <pow+0x80>
    209a:	ff 3f       	cpi	r31, 0xFF	; 255
    209c:	e1 05       	cpc	r30, r1
    209e:	31 05       	cpc	r19, r1
    20a0:	21 05       	cpc	r18, r1
    20a2:	11 f1       	breq	.+68     	; 0x20e8 <pow+0x7e>
    20a4:	e8 94       	clt
    20a6:	08 94       	sec
    20a8:	e7 95       	ror	r30
    20aa:	d9 01       	movw	r26, r18
    20ac:	aa 23       	and	r26, r26
    20ae:	29 f4       	brne	.+10     	; 0x20ba <pow+0x50>
    20b0:	ab 2f       	mov	r26, r27
    20b2:	be 2f       	mov	r27, r30
    20b4:	f8 5f       	subi	r31, 0xF8	; 248
    20b6:	d0 f3       	brcs	.-12     	; 0x20ac <pow+0x42>
    20b8:	10 c0       	rjmp	.+32     	; 0x20da <pow+0x70>
    20ba:	ff 5f       	subi	r31, 0xFF	; 255
    20bc:	70 f4       	brcc	.+28     	; 0x20da <pow+0x70>
    20be:	a6 95       	lsr	r26
    20c0:	e0 f7       	brcc	.-8      	; 0x20ba <pow+0x50>
    20c2:	f7 39       	cpi	r31, 0x97	; 151
    20c4:	50 f0       	brcs	.+20     	; 0x20da <pow+0x70>
    20c6:	19 f0       	breq	.+6      	; 0x20ce <pow+0x64>
    20c8:	ff 3a       	cpi	r31, 0xAF	; 175
    20ca:	38 f4       	brcc	.+14     	; 0x20da <pow+0x70>
    20cc:	9f 77       	andi	r25, 0x7F	; 127
    20ce:	9f 93       	push	r25
    20d0:	0c d0       	rcall	.+24     	; 0x20ea <pow+0x80>
    20d2:	0f 90       	pop	r0
    20d4:	07 fc       	sbrc	r0, 7
    20d6:	90 58       	subi	r25, 0x80	; 128
    20d8:	08 95       	ret
    20da:	3e f0       	brts	.+14     	; 0x20ea <pow+0x80>
    20dc:	18 cf       	rjmp	.-464    	; 0x1f0e <__fp_nan>
    20de:	60 e0       	ldi	r22, 0x00	; 0
    20e0:	70 e0       	ldi	r23, 0x00	; 0
    20e2:	80 e8       	ldi	r24, 0x80	; 128
    20e4:	9f e3       	ldi	r25, 0x3F	; 63
    20e6:	08 95       	ret
    20e8:	4f e7       	ldi	r20, 0x7F	; 127
    20ea:	9f 77       	andi	r25, 0x7F	; 127
    20ec:	5f 93       	push	r21
    20ee:	4f 93       	push	r20
    20f0:	3f 93       	push	r19
    20f2:	2f 93       	push	r18
    20f4:	9e d0       	rcall	.+316    	; 0x2232 <log>
    20f6:	2f 91       	pop	r18
    20f8:	3f 91       	pop	r19
    20fa:	4f 91       	pop	r20
    20fc:	5f 91       	pop	r21
    20fe:	52 df       	rcall	.-348    	; 0x1fa4 <__mulsf3>
    2100:	05 c0       	rjmp	.+10     	; 0x210c <exp>
    2102:	19 f4       	brne	.+6      	; 0x210a <pow+0xa0>
    2104:	0e f0       	brts	.+2      	; 0x2108 <pow+0x9e>
    2106:	fd ce       	rjmp	.-518    	; 0x1f02 <__fp_inf>
    2108:	46 cf       	rjmp	.-372    	; 0x1f96 <__fp_zero>
    210a:	01 cf       	rjmp	.-510    	; 0x1f0e <__fp_nan>

0000210c <exp>:
    210c:	2a df       	rcall	.-428    	; 0x1f62 <__fp_splitA>
    210e:	c8 f3       	brcs	.-14     	; 0x2102 <pow+0x98>
    2110:	96 38       	cpi	r25, 0x86	; 134
    2112:	c0 f7       	brcc	.-16     	; 0x2104 <pow+0x9a>
    2114:	07 f8       	bld	r0, 7
    2116:	0f 92       	push	r0
    2118:	e8 94       	clt
    211a:	2b e3       	ldi	r18, 0x3B	; 59
    211c:	3a ea       	ldi	r19, 0xAA	; 170
    211e:	48 eb       	ldi	r20, 0xB8	; 184
    2120:	5f e7       	ldi	r21, 0x7F	; 127
    2122:	4e df       	rcall	.-356    	; 0x1fc0 <__mulsf3_pse>
    2124:	0f 92       	push	r0
    2126:	0f 92       	push	r0
    2128:	0f 92       	push	r0
    212a:	4d b7       	in	r20, 0x3d	; 61
    212c:	5e b7       	in	r21, 0x3e	; 62
    212e:	0f 92       	push	r0
    2130:	c0 d0       	rcall	.+384    	; 0x22b2 <modf>
    2132:	e4 ee       	ldi	r30, 0xE4	; 228
    2134:	f0 e0       	ldi	r31, 0x00	; 0
    2136:	16 d0       	rcall	.+44     	; 0x2164 <__fp_powser>
    2138:	4f 91       	pop	r20
    213a:	5f 91       	pop	r21
    213c:	ef 91       	pop	r30
    213e:	ff 91       	pop	r31
    2140:	e5 95       	asr	r30
    2142:	ee 1f       	adc	r30, r30
    2144:	ff 1f       	adc	r31, r31
    2146:	49 f0       	breq	.+18     	; 0x215a <exp+0x4e>
    2148:	fe 57       	subi	r31, 0x7E	; 126
    214a:	e0 68       	ori	r30, 0x80	; 128
    214c:	44 27       	eor	r20, r20
    214e:	ee 0f       	add	r30, r30
    2150:	44 1f       	adc	r20, r20
    2152:	fa 95       	dec	r31
    2154:	e1 f7       	brne	.-8      	; 0x214e <exp+0x42>
    2156:	41 95       	neg	r20
    2158:	55 0b       	sbc	r21, r21
    215a:	32 d0       	rcall	.+100    	; 0x21c0 <ldexp>
    215c:	0f 90       	pop	r0
    215e:	07 fe       	sbrs	r0, 7
    2160:	26 c0       	rjmp	.+76     	; 0x21ae <inverse>
    2162:	08 95       	ret

00002164 <__fp_powser>:
    2164:	df 93       	push	r29
    2166:	cf 93       	push	r28
    2168:	1f 93       	push	r17
    216a:	0f 93       	push	r16
    216c:	ff 92       	push	r15
    216e:	ef 92       	push	r14
    2170:	df 92       	push	r13
    2172:	7b 01       	movw	r14, r22
    2174:	8c 01       	movw	r16, r24
    2176:	68 94       	set
    2178:	05 c0       	rjmp	.+10     	; 0x2184 <__fp_powser+0x20>
    217a:	da 2e       	mov	r13, r26
    217c:	ef 01       	movw	r28, r30
    217e:	1e df       	rcall	.-452    	; 0x1fbc <__mulsf3x>
    2180:	fe 01       	movw	r30, r28
    2182:	e8 94       	clt
    2184:	a5 91       	lpm	r26, Z+
    2186:	25 91       	lpm	r18, Z+
    2188:	35 91       	lpm	r19, Z+
    218a:	45 91       	lpm	r20, Z+
    218c:	55 91       	lpm	r21, Z+
    218e:	ae f3       	brts	.-22     	; 0x217a <__fp_powser+0x16>
    2190:	ef 01       	movw	r28, r30
    2192:	8e dd       	rcall	.-1252   	; 0x1cb0 <__addsf3x>
    2194:	fe 01       	movw	r30, r28
    2196:	97 01       	movw	r18, r14
    2198:	a8 01       	movw	r20, r16
    219a:	da 94       	dec	r13
    219c:	79 f7       	brne	.-34     	; 0x217c <__fp_powser+0x18>
    219e:	df 90       	pop	r13
    21a0:	ef 90       	pop	r14
    21a2:	ff 90       	pop	r15
    21a4:	0f 91       	pop	r16
    21a6:	1f 91       	pop	r17
    21a8:	cf 91       	pop	r28
    21aa:	df 91       	pop	r29
    21ac:	08 95       	ret

000021ae <inverse>:
    21ae:	9b 01       	movw	r18, r22
    21b0:	ac 01       	movw	r20, r24
    21b2:	60 e0       	ldi	r22, 0x00	; 0
    21b4:	70 e0       	ldi	r23, 0x00	; 0
    21b6:	80 e8       	ldi	r24, 0x80	; 128
    21b8:	9f e3       	ldi	r25, 0x3F	; 63
    21ba:	cd cd       	rjmp	.-1126   	; 0x1d56 <__divsf3>
    21bc:	a2 ce       	rjmp	.-700    	; 0x1f02 <__fp_inf>
    21be:	ac c0       	rjmp	.+344    	; 0x2318 <__fp_mpack>

000021c0 <ldexp>:
    21c0:	d0 de       	rcall	.-608    	; 0x1f62 <__fp_splitA>
    21c2:	e8 f3       	brcs	.-6      	; 0x21be <inverse+0x10>
    21c4:	99 23       	and	r25, r25
    21c6:	d9 f3       	breq	.-10     	; 0x21be <inverse+0x10>
    21c8:	94 0f       	add	r25, r20
    21ca:	51 1d       	adc	r21, r1
    21cc:	bb f3       	brvs	.-18     	; 0x21bc <inverse+0xe>
    21ce:	91 50       	subi	r25, 0x01	; 1
    21d0:	50 40       	sbci	r21, 0x00	; 0
    21d2:	94 f0       	brlt	.+36     	; 0x21f8 <ldexp+0x38>
    21d4:	59 f0       	breq	.+22     	; 0x21ec <ldexp+0x2c>
    21d6:	88 23       	and	r24, r24
    21d8:	32 f0       	brmi	.+12     	; 0x21e6 <ldexp+0x26>
    21da:	66 0f       	add	r22, r22
    21dc:	77 1f       	adc	r23, r23
    21de:	88 1f       	adc	r24, r24
    21e0:	91 50       	subi	r25, 0x01	; 1
    21e2:	50 40       	sbci	r21, 0x00	; 0
    21e4:	c1 f7       	brne	.-16     	; 0x21d6 <ldexp+0x16>
    21e6:	9e 3f       	cpi	r25, 0xFE	; 254
    21e8:	51 05       	cpc	r21, r1
    21ea:	44 f7       	brge	.-48     	; 0x21bc <inverse+0xe>
    21ec:	88 0f       	add	r24, r24
    21ee:	91 1d       	adc	r25, r1
    21f0:	96 95       	lsr	r25
    21f2:	87 95       	ror	r24
    21f4:	97 f9       	bld	r25, 7
    21f6:	08 95       	ret
    21f8:	5f 3f       	cpi	r21, 0xFF	; 255
    21fa:	ac f0       	brlt	.+42     	; 0x2226 <__stack+0x27>
    21fc:	98 3e       	cpi	r25, 0xE8	; 232
    21fe:	9c f0       	brlt	.+38     	; 0x2226 <__stack+0x27>
    2200:	bb 27       	eor	r27, r27
    2202:	86 95       	lsr	r24
    2204:	77 95       	ror	r23
    2206:	67 95       	ror	r22
    2208:	b7 95       	ror	r27
    220a:	08 f4       	brcc	.+2      	; 0x220e <__stack+0xf>
    220c:	b1 60       	ori	r27, 0x01	; 1
    220e:	93 95       	inc	r25
    2210:	c1 f7       	brne	.-16     	; 0x2202 <__stack+0x3>
    2212:	bb 0f       	add	r27, r27
    2214:	58 f7       	brcc	.-42     	; 0x21ec <ldexp+0x2c>
    2216:	11 f4       	brne	.+4      	; 0x221c <__stack+0x1d>
    2218:	60 ff       	sbrs	r22, 0
    221a:	e8 cf       	rjmp	.-48     	; 0x21ec <ldexp+0x2c>
    221c:	6f 5f       	subi	r22, 0xFF	; 255
    221e:	7f 4f       	sbci	r23, 0xFF	; 255
    2220:	8f 4f       	sbci	r24, 0xFF	; 255
    2222:	9f 4f       	sbci	r25, 0xFF	; 255
    2224:	e3 cf       	rjmp	.-58     	; 0x21ec <ldexp+0x2c>
    2226:	b8 ce       	rjmp	.-656    	; 0x1f98 <__fp_szero>
    2228:	0e f0       	brts	.+2      	; 0x222c <__stack+0x2d>
    222a:	76 c0       	rjmp	.+236    	; 0x2318 <__fp_mpack>
    222c:	70 ce       	rjmp	.-800    	; 0x1f0e <__fp_nan>
    222e:	68 94       	set
    2230:	68 ce       	rjmp	.-816    	; 0x1f02 <__fp_inf>

00002232 <log>:
    2232:	97 de       	rcall	.-722    	; 0x1f62 <__fp_splitA>
    2234:	c8 f3       	brcs	.-14     	; 0x2228 <__stack+0x29>
    2236:	99 23       	and	r25, r25
    2238:	d1 f3       	breq	.-12     	; 0x222e <__stack+0x2f>
    223a:	c6 f3       	brts	.-16     	; 0x222c <__stack+0x2d>
    223c:	df 93       	push	r29
    223e:	cf 93       	push	r28
    2240:	1f 93       	push	r17
    2242:	0f 93       	push	r16
    2244:	ff 92       	push	r15
    2246:	c9 2f       	mov	r28, r25
    2248:	dd 27       	eor	r29, r29
    224a:	88 23       	and	r24, r24
    224c:	2a f0       	brmi	.+10     	; 0x2258 <log+0x26>
    224e:	21 97       	sbiw	r28, 0x01	; 1
    2250:	66 0f       	add	r22, r22
    2252:	77 1f       	adc	r23, r23
    2254:	88 1f       	adc	r24, r24
    2256:	da f7       	brpl	.-10     	; 0x224e <log+0x1c>
    2258:	20 e0       	ldi	r18, 0x00	; 0
    225a:	30 e0       	ldi	r19, 0x00	; 0
    225c:	40 e8       	ldi	r20, 0x80	; 128
    225e:	5f eb       	ldi	r21, 0xBF	; 191
    2260:	9f e3       	ldi	r25, 0x3F	; 63
    2262:	88 39       	cpi	r24, 0x98	; 152
    2264:	20 f0       	brcs	.+8      	; 0x226e <log+0x3c>
    2266:	80 3e       	cpi	r24, 0xE0	; 224
    2268:	30 f0       	brcs	.+12     	; 0x2276 <log+0x44>
    226a:	21 96       	adiw	r28, 0x01	; 1
    226c:	8f 77       	andi	r24, 0x7F	; 127
    226e:	0f dd       	rcall	.-1506   	; 0x1c8e <__addsf3>
    2270:	ec e0       	ldi	r30, 0x0C	; 12
    2272:	f1 e0       	ldi	r31, 0x01	; 1
    2274:	03 c0       	rjmp	.+6      	; 0x227c <log+0x4a>
    2276:	0b dd       	rcall	.-1514   	; 0x1c8e <__addsf3>
    2278:	e9 e3       	ldi	r30, 0x39	; 57
    227a:	f1 e0       	ldi	r31, 0x01	; 1
    227c:	73 df       	rcall	.-282    	; 0x2164 <__fp_powser>
    227e:	8b 01       	movw	r16, r22
    2280:	be 01       	movw	r22, r28
    2282:	ec 01       	movw	r28, r24
    2284:	fb 2e       	mov	r15, r27
    2286:	6f 57       	subi	r22, 0x7F	; 127
    2288:	71 09       	sbc	r23, r1
    228a:	75 95       	asr	r23
    228c:	77 1f       	adc	r23, r23
    228e:	88 0b       	sbc	r24, r24
    2290:	99 0b       	sbc	r25, r25
    2292:	fc dd       	rcall	.-1032   	; 0x1e8c <__floatsisf>
    2294:	28 e1       	ldi	r18, 0x18	; 24
    2296:	32 e7       	ldi	r19, 0x72	; 114
    2298:	41 e3       	ldi	r20, 0x31	; 49
    229a:	5f e3       	ldi	r21, 0x3F	; 63
    229c:	8f de       	rcall	.-738    	; 0x1fbc <__mulsf3x>
    229e:	af 2d       	mov	r26, r15
    22a0:	98 01       	movw	r18, r16
    22a2:	ae 01       	movw	r20, r28
    22a4:	ff 90       	pop	r15
    22a6:	0f 91       	pop	r16
    22a8:	1f 91       	pop	r17
    22aa:	cf 91       	pop	r28
    22ac:	df 91       	pop	r29
    22ae:	00 dd       	rcall	.-1536   	; 0x1cb0 <__addsf3x>
    22b0:	3f ce       	rjmp	.-898    	; 0x1f30 <__fp_round>

000022b2 <modf>:
    22b2:	fa 01       	movw	r30, r20
    22b4:	dc 01       	movw	r26, r24
    22b6:	aa 0f       	add	r26, r26
    22b8:	bb 1f       	adc	r27, r27
    22ba:	9b 01       	movw	r18, r22
    22bc:	ac 01       	movw	r20, r24
    22be:	bf 57       	subi	r27, 0x7F	; 127
    22c0:	28 f4       	brcc	.+10     	; 0x22cc <modf+0x1a>
    22c2:	22 27       	eor	r18, r18
    22c4:	33 27       	eor	r19, r19
    22c6:	44 27       	eor	r20, r20
    22c8:	50 78       	andi	r21, 0x80	; 128
    22ca:	1f c0       	rjmp	.+62     	; 0x230a <modf+0x58>
    22cc:	b7 51       	subi	r27, 0x17	; 23
    22ce:	88 f4       	brcc	.+34     	; 0x22f2 <modf+0x40>
    22d0:	ab 2f       	mov	r26, r27
    22d2:	00 24       	eor	r0, r0
    22d4:	46 95       	lsr	r20
    22d6:	37 95       	ror	r19
    22d8:	27 95       	ror	r18
    22da:	01 1c       	adc	r0, r1
    22dc:	a3 95       	inc	r26
    22de:	d2 f3       	brmi	.-12     	; 0x22d4 <modf+0x22>
    22e0:	00 20       	and	r0, r0
    22e2:	69 f0       	breq	.+26     	; 0x22fe <modf+0x4c>
    22e4:	22 0f       	add	r18, r18
    22e6:	33 1f       	adc	r19, r19
    22e8:	44 1f       	adc	r20, r20
    22ea:	b3 95       	inc	r27
    22ec:	da f3       	brmi	.-10     	; 0x22e4 <modf+0x32>
    22ee:	0d d0       	rcall	.+26     	; 0x230a <modf+0x58>
    22f0:	cd cc       	rjmp	.-1638   	; 0x1c8c <__subsf3>
    22f2:	61 30       	cpi	r22, 0x01	; 1
    22f4:	71 05       	cpc	r23, r1
    22f6:	a0 e8       	ldi	r26, 0x80	; 128
    22f8:	8a 07       	cpc	r24, r26
    22fa:	b9 46       	sbci	r27, 0x69	; 105
    22fc:	30 f4       	brcc	.+12     	; 0x230a <modf+0x58>
    22fe:	9b 01       	movw	r18, r22
    2300:	ac 01       	movw	r20, r24
    2302:	66 27       	eor	r22, r22
    2304:	77 27       	eor	r23, r23
    2306:	88 27       	eor	r24, r24
    2308:	90 78       	andi	r25, 0x80	; 128
    230a:	30 96       	adiw	r30, 0x00	; 0
    230c:	21 f0       	breq	.+8      	; 0x2316 <modf+0x64>
    230e:	20 83       	st	Z, r18
    2310:	31 83       	std	Z+1, r19	; 0x01
    2312:	42 83       	std	Z+2, r20	; 0x02
    2314:	53 83       	std	Z+3, r21	; 0x03
    2316:	08 95       	ret

00002318 <__fp_mpack>:
    2318:	9f 3f       	cpi	r25, 0xFF	; 255
    231a:	31 f0       	breq	.+12     	; 0x2328 <__fp_mpack_finite+0xc>

0000231c <__fp_mpack_finite>:
    231c:	91 50       	subi	r25, 0x01	; 1
    231e:	20 f4       	brcc	.+8      	; 0x2328 <__fp_mpack_finite+0xc>
    2320:	87 95       	ror	r24
    2322:	77 95       	ror	r23
    2324:	67 95       	ror	r22
    2326:	b7 95       	ror	r27
    2328:	88 0f       	add	r24, r24
    232a:	91 1d       	adc	r25, r1
    232c:	96 95       	lsr	r25
    232e:	87 95       	ror	r24
    2330:	97 f9       	bld	r25, 7
    2332:	08 95       	ret

00002334 <__udivmodhi4>:
    2334:	aa 1b       	sub	r26, r26
    2336:	bb 1b       	sub	r27, r27
    2338:	51 e1       	ldi	r21, 0x11	; 17
    233a:	07 c0       	rjmp	.+14     	; 0x234a <__udivmodhi4_ep>

0000233c <__udivmodhi4_loop>:
    233c:	aa 1f       	adc	r26, r26
    233e:	bb 1f       	adc	r27, r27
    2340:	a6 17       	cp	r26, r22
    2342:	b7 07       	cpc	r27, r23
    2344:	10 f0       	brcs	.+4      	; 0x234a <__udivmodhi4_ep>
    2346:	a6 1b       	sub	r26, r22
    2348:	b7 0b       	sbc	r27, r23

0000234a <__udivmodhi4_ep>:
    234a:	88 1f       	adc	r24, r24
    234c:	99 1f       	adc	r25, r25
    234e:	5a 95       	dec	r21
    2350:	a9 f7       	brne	.-22     	; 0x233c <__udivmodhi4_loop>
    2352:	80 95       	com	r24
    2354:	90 95       	com	r25
    2356:	bc 01       	movw	r22, r24
    2358:	cd 01       	movw	r24, r26
    235a:	08 95       	ret

0000235c <__divmodhi4>:
    235c:	97 fb       	bst	r25, 7
    235e:	09 2e       	mov	r0, r25
    2360:	07 26       	eor	r0, r23
    2362:	0a d0       	rcall	.+20     	; 0x2378 <__divmodhi4_neg1>
    2364:	77 fd       	sbrc	r23, 7
    2366:	04 d0       	rcall	.+8      	; 0x2370 <__divmodhi4_neg2>
    2368:	e5 df       	rcall	.-54     	; 0x2334 <__udivmodhi4>
    236a:	06 d0       	rcall	.+12     	; 0x2378 <__divmodhi4_neg1>
    236c:	00 20       	and	r0, r0
    236e:	1a f4       	brpl	.+6      	; 0x2376 <__divmodhi4_exit>

00002370 <__divmodhi4_neg2>:
    2370:	70 95       	com	r23
    2372:	61 95       	neg	r22
    2374:	7f 4f       	sbci	r23, 0xFF	; 255

00002376 <__divmodhi4_exit>:
    2376:	08 95       	ret

00002378 <__divmodhi4_neg1>:
    2378:	f6 f7       	brtc	.-4      	; 0x2376 <__divmodhi4_exit>
    237a:	90 95       	com	r25
    237c:	81 95       	neg	r24
    237e:	9f 4f       	sbci	r25, 0xFF	; 255
    2380:	08 95       	ret

00002382 <_exit>:
    2382:	f8 94       	cli

00002384 <__stop_program>:
    2384:	ff cf       	rjmp	.-2      	; 0x2384 <__stop_program>
