
forthewin.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000332  00800200  00002532  000025c6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002532  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000753  00800532  00800532  000028f8  2**0
                  ALLOC
  3 .stab         000033fc  00000000  00000000  000028f8  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000009aa  00000000  00000000  00005cf4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000000c0  00000000  00000000  000066a0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000021c5  00000000  00000000  00006760  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000419  00000000  00000000  00008925  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000b53  00000000  00000000  00008d3e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000780  00000000  00000000  00009894  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000cbb  00000000  00000000  0000a014  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000181c  00000000  00000000  0000accf  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000068  00000000  00000000  0000c4eb  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 b3 00 	jmp	0x166	; 0x166 <__ctors_end>
       4:	0c 94 ae 05 	jmp	0xb5c	; 0xb5c <__vector_1>
       8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
       c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      10:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      14:	0c 94 79 06 	jmp	0xcf2	; 0xcf2 <__vector_5>
      18:	0c 94 54 06 	jmp	0xca8	; 0xca8 <__vector_6>
      1c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      20:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      24:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      28:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      2c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      30:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      34:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      38:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      3c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      40:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      44:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      48:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      4c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      50:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      54:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      58:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      5c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      60:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      64:	0c 94 2e 05 	jmp	0xa5c	; 0xa5c <__vector_25>
      68:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      6c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      70:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      74:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      78:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      7c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      80:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      84:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      88:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      8c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      90:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      94:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      98:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      9c:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      a8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      ac:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      b8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      bc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      c8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      cc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d4:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      d8:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      dc:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      e0:	0c 94 d4 00 	jmp	0x1a8	; 0x1a8 <__bad_interrupt>
      e4:	07 63       	ori	r16, 0x37	; 55
      e6:	42 36       	cpi	r20, 0x62	; 98
      e8:	b7 9b       	sbis	0x16, 7	; 22
      ea:	d8 a7       	lds	r29, 0x78
      ec:	1a 39       	cpi	r17, 0x9A	; 154
      ee:	68 56       	subi	r22, 0x68	; 104
      f0:	18 ae       	sts	0xb8, r17
      f2:	ba ab       	sts	0x5a, r27
      f4:	55 8c       	ldd	r5, Z+29	; 0x1d
      f6:	1d 3c       	cpi	r17, 0xCD	; 205
      f8:	b7 cc       	rjmp	.-1682   	; 0xfffffa68 <__eeprom_end+0xff7efa68>
      fa:	57 63       	ori	r21, 0x37	; 55
      fc:	bd 6d       	ori	r27, 0xDD	; 221
      fe:	ed fd       	.word	0xfded	; ????
     100:	75 3e       	cpi	r23, 0xE5	; 229
     102:	f6 17       	cp	r31, r22
     104:	72 31       	cpi	r23, 0x12	; 18
     106:	bf 00       	.word	0x00bf	; ????
     108:	00 00       	nop
     10a:	80 3f       	cpi	r24, 0xF0	; 240
     10c:	08 00       	.word	0x0008	; ????
     10e:	00 00       	nop
     110:	be 92       	st	-X, r11
     112:	24 49       	sbci	r18, 0x94	; 148
     114:	12 3e       	cpi	r17, 0xE2	; 226
     116:	ab aa       	sts	0x9b, r26
     118:	aa 2a       	or	r10, r26
     11a:	be cd       	rjmp	.-1156   	; 0xfffffc98 <__eeprom_end+0xff7efc98>
     11c:	cc cc       	rjmp	.-1640   	; 0xfffffab6 <__eeprom_end+0xff7efab6>
     11e:	4c 3e       	cpi	r20, 0xEC	; 236
     120:	00 00       	nop
     122:	00 80       	ld	r0, Z
     124:	be ab       	sts	0x5e, r27
     126:	aa aa       	sts	0x9a, r26
     128:	aa 3e       	cpi	r26, 0xEA	; 234
     12a:	00 00       	nop
     12c:	00 00       	nop
     12e:	bf 00       	.word	0x00bf	; ????
     130:	00 00       	nop
     132:	80 3f       	cpi	r24, 0xF0	; 240
     134:	00 00       	nop
     136:	00 00       	nop
     138:	00 08       	sbc	r0, r0
     13a:	41 78       	andi	r20, 0x81	; 129
     13c:	d3 bb       	out	0x13, r29	; 19
     13e:	43 87       	std	Z+11, r20	; 0x0b
     140:	d1 13       	cpse	r29, r17
     142:	3d 19       	sub	r19, r13
     144:	0e 3c       	cpi	r16, 0xCE	; 206
     146:	c3 bd       	out	0x23, r28	; 35
     148:	42 82       	std	Z+2, r4	; 0x02
     14a:	ad 2b       	or	r26, r29
     14c:	3e 68       	ori	r19, 0x8E	; 142
     14e:	ec 82       	std	Y+4, r14	; 0x04
     150:	76 be       	out	0x36, r7	; 54
     152:	d9 8f       	std	Y+25, r29	; 0x19
     154:	e1 a9       	sts	0x41, r30
     156:	3e 4c       	sbci	r19, 0xCE	; 206
     158:	80 ef       	ldi	r24, 0xF0	; 240
     15a:	ff be       	out	0x3f, r15	; 63
     15c:	01 c4       	rjmp	.+2050   	; 0x960 <_Z5colorv+0x4a>
     15e:	ff 7f       	andi	r31, 0xFF	; 255
     160:	3f 00       	.word	0x003f	; ????
     162:	00 00       	nop
	...

00000166 <__ctors_end>:
     166:	11 24       	eor	r1, r1
     168:	1f be       	out	0x3f, r1	; 63
     16a:	cf ef       	ldi	r28, 0xFF	; 255
     16c:	d1 e2       	ldi	r29, 0x21	; 33
     16e:	de bf       	out	0x3e, r29	; 62
     170:	cd bf       	out	0x3d, r28	; 61
     172:	00 e0       	ldi	r16, 0x00	; 0
     174:	0c bf       	out	0x3c, r16	; 60

00000176 <__do_copy_data>:
     176:	15 e0       	ldi	r17, 0x05	; 5
     178:	a0 e0       	ldi	r26, 0x00	; 0
     17a:	b2 e0       	ldi	r27, 0x02	; 2
     17c:	e2 e3       	ldi	r30, 0x32	; 50
     17e:	f5 e2       	ldi	r31, 0x25	; 37
     180:	00 e0       	ldi	r16, 0x00	; 0
     182:	0b bf       	out	0x3b, r16	; 59
     184:	02 c0       	rjmp	.+4      	; 0x18a <__do_copy_data+0x14>
     186:	07 90       	elpm	r0, Z+
     188:	0d 92       	st	X+, r0
     18a:	a2 33       	cpi	r26, 0x32	; 50
     18c:	b1 07       	cpc	r27, r17
     18e:	d9 f7       	brne	.-10     	; 0x186 <__do_copy_data+0x10>

00000190 <__do_clear_bss>:
     190:	1c e0       	ldi	r17, 0x0C	; 12
     192:	a2 e3       	ldi	r26, 0x32	; 50
     194:	b5 e0       	ldi	r27, 0x05	; 5
     196:	01 c0       	rjmp	.+2      	; 0x19a <.do_clear_bss_start>

00000198 <.do_clear_bss_loop>:
     198:	1d 92       	st	X+, r1

0000019a <.do_clear_bss_start>:
     19a:	a5 38       	cpi	r26, 0x85	; 133
     19c:	b1 07       	cpc	r27, r17
     19e:	e1 f7       	brne	.-8      	; 0x198 <.do_clear_bss_loop>
     1a0:	0e 94 fa 0a 	call	0x15f4	; 0x15f4 <main>
     1a4:	0c 94 97 12 	jmp	0x252e	; 0x252e <_exit>

000001a8 <__bad_interrupt>:
     1a8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001ac <_Z12lcd_set_4bitv>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     1ac:	86 e6       	ldi	r24, 0x66	; 102
     1ae:	9e e0       	ldi	r25, 0x0E	; 14
     1b0:	01 97       	sbiw	r24, 0x01	; 1
     1b2:	f1 f7       	brne	.-4      	; 0x1b0 <_Z12lcd_set_4bitv+0x4>
     1b4:	00 00       	nop
//Function to Reset LCD
void lcd_set_4bit()
{
	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     1b6:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     1b8:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     1ba:	80 e3       	ldi	r24, 0x30	; 48
     1bc:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     1be:	42 9a       	sbi	0x08, 2	; 8
     1c0:	ef ef       	ldi	r30, 0xFF	; 255
     1c2:	f7 e4       	ldi	r31, 0x47	; 71
     1c4:	31 97       	sbiw	r30, 0x01	; 1
     1c6:	f1 f7       	brne	.-4      	; 0x1c4 <_Z12lcd_set_4bitv+0x18>
     1c8:	00 c0       	rjmp	.+0      	; 0x1ca <_Z12lcd_set_4bitv+0x1e>
     1ca:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     1cc:	42 98       	cbi	0x08, 2	; 8
     1ce:	e6 e6       	ldi	r30, 0x66	; 102
     1d0:	fe e0       	ldi	r31, 0x0E	; 14
     1d2:	31 97       	sbiw	r30, 0x01	; 1
     1d4:	f1 f7       	brne	.-4      	; 0x1d2 <_Z12lcd_set_4bitv+0x26>
     1d6:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     1d8:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     1da:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     1dc:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     1de:	42 9a       	sbi	0x08, 2	; 8
     1e0:	ef ef       	ldi	r30, 0xFF	; 255
     1e2:	f7 e4       	ldi	r31, 0x47	; 71
     1e4:	31 97       	sbiw	r30, 0x01	; 1
     1e6:	f1 f7       	brne	.-4      	; 0x1e4 <_Z12lcd_set_4bitv+0x38>
     1e8:	00 c0       	rjmp	.+0      	; 0x1ea <_Z12lcd_set_4bitv+0x3e>
     1ea:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     1ec:	42 98       	cbi	0x08, 2	; 8
     1ee:	e6 e6       	ldi	r30, 0x66	; 102
     1f0:	fe e0       	ldi	r31, 0x0E	; 14
     1f2:	31 97       	sbiw	r30, 0x01	; 1
     1f4:	f1 f7       	brne	.-4      	; 0x1f2 <_Z12lcd_set_4bitv+0x46>
     1f6:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     1f8:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     1fa:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     1fc:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     1fe:	42 9a       	sbi	0x08, 2	; 8
     200:	8f ef       	ldi	r24, 0xFF	; 255
     202:	97 e4       	ldi	r25, 0x47	; 71
     204:	01 97       	sbiw	r24, 0x01	; 1
     206:	f1 f7       	brne	.-4      	; 0x204 <_Z12lcd_set_4bitv+0x58>
     208:	00 c0       	rjmp	.+0      	; 0x20a <_Z12lcd_set_4bitv+0x5e>
     20a:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     20c:	42 98       	cbi	0x08, 2	; 8
     20e:	e6 e6       	ldi	r30, 0x66	; 102
     210:	fe e0       	ldi	r31, 0x0E	; 14
     212:	31 97       	sbiw	r30, 0x01	; 1
     214:	f1 f7       	brne	.-4      	; 0x212 <_Z12lcd_set_4bitv+0x66>
     216:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     218:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     21a:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x20;				//Sending 2 to initialise LCD 4-bit mode
     21c:	80 e2       	ldi	r24, 0x20	; 32
     21e:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     220:	42 9a       	sbi	0x08, 2	; 8
     222:	8f ef       	ldi	r24, 0xFF	; 255
     224:	97 e4       	ldi	r25, 0x47	; 71
     226:	01 97       	sbiw	r24, 0x01	; 1
     228:	f1 f7       	brne	.-4      	; 0x226 <_Z12lcd_set_4bitv+0x7a>
     22a:	00 c0       	rjmp	.+0      	; 0x22c <_Z12lcd_set_4bitv+0x80>
     22c:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     22e:	42 98       	cbi	0x08, 2	; 8

	
}
     230:	08 95       	ret

00000232 <_Z14lcd_wr_commandh>:
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
	lcd_port &= 0x0F;
     232:	98 b1       	in	r25, 0x08	; 8
     234:	9f 70       	andi	r25, 0x0F	; 15
     236:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     238:	98 b1       	in	r25, 0x08	; 8
//Function to Write Command on LCD
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
     23a:	28 2f       	mov	r18, r24
     23c:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     23e:	92 2b       	or	r25, r18
     240:	98 b9       	out	0x08, r25	; 8
	cbit(lcd_port,RS);
     242:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     244:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     246:	42 9a       	sbi	0x08, 2	; 8
     248:	ef ef       	ldi	r30, 0xFF	; 255
     24a:	f7 e4       	ldi	r31, 0x47	; 71
     24c:	31 97       	sbiw	r30, 0x01	; 1
     24e:	f1 f7       	brne	.-4      	; 0x24c <_Z14lcd_wr_commandh+0x1a>
     250:	00 c0       	rjmp	.+0      	; 0x252 <_Z14lcd_wr_commandh+0x20>
     252:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     254:	42 98       	cbi	0x08, 2	; 8
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
	lcd_port &= 0x0F;
     256:	98 b1       	in	r25, 0x08	; 8
     258:	9f 70       	andi	r25, 0x0F	; 15
     25a:	98 b9       	out	0x08, r25	; 8
	lcd_port |= cmd;
     25c:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
     25e:	82 95       	swap	r24
     260:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= cmd;
     262:	89 2b       	or	r24, r25
     264:	88 b9       	out	0x08, r24	; 8
	cbit(lcd_port,RS);
     266:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     268:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     26a:	42 9a       	sbi	0x08, 2	; 8
     26c:	8f ef       	ldi	r24, 0xFF	; 255
     26e:	97 e4       	ldi	r25, 0x47	; 71
     270:	01 97       	sbiw	r24, 0x01	; 1
     272:	f1 f7       	brne	.-4      	; 0x270 <_Z14lcd_wr_commandh+0x3e>
     274:	00 c0       	rjmp	.+0      	; 0x276 <_Z14lcd_wr_commandh+0x44>
     276:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     278:	42 98       	cbi	0x08, 2	; 8
}
     27a:	08 95       	ret

0000027c <_Z8lcd_initv>:
}

//Function to Initialize LCD
void lcd_init()
{
	lcd_set_4bit();
     27c:	0e 94 d6 00 	call	0x1ac	; 0x1ac <_Z12lcd_set_4bitv>
     280:	86 e6       	ldi	r24, 0x66	; 102
     282:	9e e0       	ldi	r25, 0x0E	; 14
     284:	01 97       	sbiw	r24, 0x01	; 1
     286:	f1 f7       	brne	.-4      	; 0x284 <_Z8lcd_initv+0x8>
     288:	00 00       	nop
	_delay_ms(1);

	lcd_wr_command(0x28);			//LCD 4-bit mode and 2 lines.
     28a:	88 e2       	ldi	r24, 0x28	; 40
     28c:	0e 94 19 01 	call	0x232	; 0x232 <_Z14lcd_wr_commandh>
	lcd_wr_command(0x01);
     290:	81 e0       	ldi	r24, 0x01	; 1
     292:	0e 94 19 01 	call	0x232	; 0x232 <_Z14lcd_wr_commandh>
	lcd_wr_command(0x06);
     296:	86 e0       	ldi	r24, 0x06	; 6
     298:	0e 94 19 01 	call	0x232	; 0x232 <_Z14lcd_wr_commandh>
	lcd_wr_command(0x0E);
     29c:	8e e0       	ldi	r24, 0x0E	; 14
     29e:	0e 94 19 01 	call	0x232	; 0x232 <_Z14lcd_wr_commandh>
	lcd_wr_command(0x80);
     2a2:	80 e8       	ldi	r24, 0x80	; 128
     2a4:	0e 94 19 01 	call	0x232	; 0x232 <_Z14lcd_wr_commandh>
		
}
     2a8:	08 95       	ret

000002aa <_Z11lcd_wr_charc>:
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
	lcd_port &= 0x0F;
     2aa:	98 b1       	in	r25, 0x08	; 8
     2ac:	9f 70       	andi	r25, 0x0F	; 15
     2ae:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     2b0:	98 b1       	in	r25, 0x08	; 8
//Function to Write Data on LCD
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
     2b2:	28 2f       	mov	r18, r24
     2b4:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     2b6:	92 2b       	or	r25, r18
     2b8:	98 b9       	out	0x08, r25	; 8
	sbit(lcd_port,RS);
     2ba:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     2bc:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     2be:	42 9a       	sbi	0x08, 2	; 8
     2c0:	ef ef       	ldi	r30, 0xFF	; 255
     2c2:	f7 e4       	ldi	r31, 0x47	; 71
     2c4:	31 97       	sbiw	r30, 0x01	; 1
     2c6:	f1 f7       	brne	.-4      	; 0x2c4 <_Z11lcd_wr_charc+0x1a>
     2c8:	00 c0       	rjmp	.+0      	; 0x2ca <_Z11lcd_wr_charc+0x20>
     2ca:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     2cc:	42 98       	cbi	0x08, 2	; 8

	letter = letter & 0x0F;
	letter = letter<<4;
	lcd_port &= 0x0F;
     2ce:	98 b1       	in	r25, 0x08	; 8
     2d0:	9f 70       	andi	r25, 0x0F	; 15
     2d2:	98 b9       	out	0x08, r25	; 8
	lcd_port |= letter;
     2d4:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);

	letter = letter & 0x0F;
	letter = letter<<4;
     2d6:	82 95       	swap	r24
     2d8:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= letter;
     2da:	89 2b       	or	r24, r25
     2dc:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,RS);
     2de:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     2e0:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     2e2:	42 9a       	sbi	0x08, 2	; 8
     2e4:	8f ef       	ldi	r24, 0xFF	; 255
     2e6:	97 e4       	ldi	r25, 0x47	; 71
     2e8:	01 97       	sbiw	r24, 0x01	; 1
     2ea:	f1 f7       	brne	.-4      	; 0x2e8 <_Z11lcd_wr_charc+0x3e>
     2ec:	00 c0       	rjmp	.+0      	; 0x2ee <_Z11lcd_wr_charc+0x44>
     2ee:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     2f0:	42 98       	cbi	0x08, 2	; 8
}
     2f2:	08 95       	ret

000002f4 <_Z8lcd_homev>:


//Function to bring cursor at home position
void lcd_home()
{
	lcd_wr_command(0x80);
     2f4:	80 e8       	ldi	r24, 0x80	; 128
     2f6:	0e 94 19 01 	call	0x232	; 0x232 <_Z14lcd_wr_commandh>
}
     2fa:	08 95       	ret

000002fc <_Z10lcd_stringPc>:


//Function to Print String on LCD
void lcd_string(char *str)
{
     2fc:	cf 93       	push	r28
     2fe:	df 93       	push	r29
     300:	ec 01       	movw	r28, r24
	while(*str != '\0')
     302:	88 81       	ld	r24, Y
     304:	88 23       	and	r24, r24
     306:	31 f0       	breq	.+12     	; 0x314 <_Z10lcd_stringPc+0x18>
	lcd_wr_command(0x80);
}


//Function to Print String on LCD
void lcd_string(char *str)
     308:	21 96       	adiw	r28, 0x01	; 1
{
	while(*str != '\0')
	{
		lcd_wr_char(*str);
     30a:	0e 94 55 01 	call	0x2aa	; 0x2aa <_Z11lcd_wr_charc>


//Function to Print String on LCD
void lcd_string(char *str)
{
	while(*str != '\0')
     30e:	89 91       	ld	r24, Y+
     310:	88 23       	and	r24, r24
     312:	d9 f7       	brne	.-10     	; 0x30a <_Z10lcd_stringPc+0xe>
	{
		lcd_wr_char(*str);
		str++;
	}
}
     314:	df 91       	pop	r29
     316:	cf 91       	pop	r28
     318:	08 95       	ret

0000031a <_Z10lcd_cursorcc>:

//Position the LCD cursor at "row", "column".

void lcd_cursor (char row, char column)
{
	switch (row) {
     31a:	82 30       	cpi	r24, 0x02	; 2
     31c:	79 f0       	breq	.+30     	; 0x33c <_Z10lcd_cursorcc+0x22>
     31e:	83 30       	cpi	r24, 0x03	; 3
     320:	18 f4       	brcc	.+6      	; 0x328 <_Z10lcd_cursorcc+0xe>
     322:	81 30       	cpi	r24, 0x01	; 1
     324:	c9 f4       	brne	.+50     	; 0x358 <_Z10lcd_cursorcc+0x3e>
     326:	05 c0       	rjmp	.+10     	; 0x332 <_Z10lcd_cursorcc+0x18>
     328:	83 30       	cpi	r24, 0x03	; 3
     32a:	69 f0       	breq	.+26     	; 0x346 <_Z10lcd_cursorcc+0x2c>
     32c:	84 30       	cpi	r24, 0x04	; 4
     32e:	a1 f4       	brne	.+40     	; 0x358 <_Z10lcd_cursorcc+0x3e>
     330:	0f c0       	rjmp	.+30     	; 0x350 <_Z10lcd_cursorcc+0x36>
		case 1: lcd_wr_command (0x80 + column - 1); break;
     332:	86 2f       	mov	r24, r22
     334:	81 58       	subi	r24, 0x81	; 129
     336:	0e 94 19 01 	call	0x232	; 0x232 <_Z14lcd_wr_commandh>
     33a:	08 95       	ret
		case 2: lcd_wr_command (0xc0 + column - 1); break;
     33c:	86 2f       	mov	r24, r22
     33e:	81 54       	subi	r24, 0x41	; 65
     340:	0e 94 19 01 	call	0x232	; 0x232 <_Z14lcd_wr_commandh>
     344:	08 95       	ret
		case 3: lcd_wr_command (0x94 + column - 1); break;
     346:	86 2f       	mov	r24, r22
     348:	8d 56       	subi	r24, 0x6D	; 109
     34a:	0e 94 19 01 	call	0x232	; 0x232 <_Z14lcd_wr_commandh>
     34e:	08 95       	ret
		case 4: lcd_wr_command (0xd4 + column - 1); break;
     350:	86 2f       	mov	r24, r22
     352:	8d 52       	subi	r24, 0x2D	; 45
     354:	0e 94 19 01 	call	0x232	; 0x232 <_Z14lcd_wr_commandh>
     358:	08 95       	ret

0000035a <_Z9lcd_printccji>:
	}
}

//Function To Print Any input value upto the desired digit on LCD
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
     35a:	0f 93       	push	r16
     35c:	1f 93       	push	r17
     35e:	cf 93       	push	r28
     360:	df 93       	push	r29
     362:	8a 01       	movw	r16, r20
     364:	e9 01       	movw	r28, r18
	unsigned char flag=0;
	if(row==0||coloumn==0)
     366:	88 23       	and	r24, r24
     368:	11 f0       	breq	.+4      	; 0x36e <_Z9lcd_printccji+0x14>
     36a:	66 23       	and	r22, r22
     36c:	19 f4       	brne	.+6      	; 0x374 <_Z9lcd_printccji+0x1a>
	{
		lcd_home();
     36e:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <_Z8lcd_homev>
     372:	02 c0       	rjmp	.+4      	; 0x378 <_Z9lcd_printccji+0x1e>
	}
	else
	{
		lcd_cursor(row,coloumn);
     374:	0e 94 8d 01 	call	0x31a	; 0x31a <_Z10lcd_cursorcc>
	}
	if(digits==5 || flag==1)
     378:	c5 30       	cpi	r28, 0x05	; 5
     37a:	d1 05       	cpc	r29, r1
     37c:	71 f4       	brne	.+28     	; 0x39a <_Z9lcd_printccji+0x40>
	{
		million=value/10000+48;
     37e:	c8 01       	movw	r24, r16
     380:	60 e1       	ldi	r22, 0x10	; 16
     382:	77 e2       	ldi	r23, 0x27	; 39
     384:	0e 94 70 12 	call	0x24e0	; 0x24e0 <__udivmodhi4>
     388:	cb 01       	movw	r24, r22
     38a:	c0 96       	adiw	r24, 0x30	; 48
     38c:	90 93 7a 0c 	sts	0x0C7A, r25
     390:	80 93 79 0c 	sts	0x0C79, r24
		lcd_wr_char(million);
     394:	0e 94 55 01 	call	0x2aa	; 0x2aa <_Z11lcd_wr_charc>
     398:	03 c0       	rjmp	.+6      	; 0x3a0 <_Z9lcd_printccji+0x46>
		flag=1;
	}
	if(digits==4 || flag==1)
     39a:	c4 30       	cpi	r28, 0x04	; 4
     39c:	d1 05       	cpc	r29, r1
     39e:	b9 f4       	brne	.+46     	; 0x3ce <_Z9lcd_printccji+0x74>
	{
		temp = value/1000;
     3a0:	c8 01       	movw	r24, r16
     3a2:	68 ee       	ldi	r22, 0xE8	; 232
     3a4:	73 e0       	ldi	r23, 0x03	; 3
     3a6:	0e 94 70 12 	call	0x24e0	; 0x24e0 <__udivmodhi4>
     3aa:	cb 01       	movw	r24, r22
     3ac:	70 93 84 0c 	sts	0x0C84, r23
     3b0:	60 93 83 0c 	sts	0x0C83, r22
		thousand = temp%10 + 48;
     3b4:	6a e0       	ldi	r22, 0x0A	; 10
     3b6:	70 e0       	ldi	r23, 0x00	; 0
     3b8:	0e 94 70 12 	call	0x24e0	; 0x24e0 <__udivmodhi4>
     3bc:	c0 96       	adiw	r24, 0x30	; 48
     3be:	90 93 7c 0c 	sts	0x0C7C, r25
     3c2:	80 93 7b 0c 	sts	0x0C7B, r24
		lcd_wr_char(thousand);
     3c6:	0e 94 55 01 	call	0x2aa	; 0x2aa <_Z11lcd_wr_charc>
		flag=1;
     3ca:	81 e0       	ldi	r24, 0x01	; 1
     3cc:	01 c0       	rjmp	.+2      	; 0x3d0 <_Z9lcd_printccji+0x76>
}

//Function To Print Any input value upto the desired digit on LCD
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
	unsigned char flag=0;
     3ce:	80 e0       	ldi	r24, 0x00	; 0
		temp = value/1000;
		thousand = temp%10 + 48;
		lcd_wr_char(thousand);
		flag=1;
	}
	if(digits==3 || flag==1)
     3d0:	c3 30       	cpi	r28, 0x03	; 3
     3d2:	d1 05       	cpc	r29, r1
     3d4:	11 f0       	breq	.+4      	; 0x3da <_Z9lcd_printccji+0x80>
     3d6:	81 30       	cpi	r24, 0x01	; 1
     3d8:	b1 f4       	brne	.+44     	; 0x406 <_Z9lcd_printccji+0xac>
	{
		temp = value/100;
     3da:	c8 01       	movw	r24, r16
     3dc:	64 e6       	ldi	r22, 0x64	; 100
     3de:	70 e0       	ldi	r23, 0x00	; 0
     3e0:	0e 94 70 12 	call	0x24e0	; 0x24e0 <__udivmodhi4>
     3e4:	cb 01       	movw	r24, r22
     3e6:	70 93 84 0c 	sts	0x0C84, r23
     3ea:	60 93 83 0c 	sts	0x0C83, r22
		hundred = temp%10 + 48;
     3ee:	6a e0       	ldi	r22, 0x0A	; 10
     3f0:	70 e0       	ldi	r23, 0x00	; 0
     3f2:	0e 94 70 12 	call	0x24e0	; 0x24e0 <__udivmodhi4>
     3f6:	c0 96       	adiw	r24, 0x30	; 48
     3f8:	90 93 7e 0c 	sts	0x0C7E, r25
     3fc:	80 93 7d 0c 	sts	0x0C7D, r24
		lcd_wr_char(hundred);
     400:	0e 94 55 01 	call	0x2aa	; 0x2aa <_Z11lcd_wr_charc>
		flag=1;
     404:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==2 || flag==1)
     406:	c2 30       	cpi	r28, 0x02	; 2
     408:	d1 05       	cpc	r29, r1
     40a:	11 f0       	breq	.+4      	; 0x410 <_Z9lcd_printccji+0xb6>
     40c:	81 30       	cpi	r24, 0x01	; 1
     40e:	b1 f4       	brne	.+44     	; 0x43c <_Z9lcd_printccji+0xe2>
	{
		temp = value/10;
     410:	2a e0       	ldi	r18, 0x0A	; 10
     412:	30 e0       	ldi	r19, 0x00	; 0
     414:	c8 01       	movw	r24, r16
     416:	b9 01       	movw	r22, r18
     418:	0e 94 70 12 	call	0x24e0	; 0x24e0 <__udivmodhi4>
     41c:	cb 01       	movw	r24, r22
     41e:	70 93 84 0c 	sts	0x0C84, r23
     422:	60 93 83 0c 	sts	0x0C83, r22
		tens = temp%10 + 48;
     426:	b9 01       	movw	r22, r18
     428:	0e 94 70 12 	call	0x24e0	; 0x24e0 <__udivmodhi4>
     42c:	c0 96       	adiw	r24, 0x30	; 48
     42e:	90 93 80 0c 	sts	0x0C80, r25
     432:	80 93 7f 0c 	sts	0x0C7F, r24
		lcd_wr_char(tens);
     436:	0e 94 55 01 	call	0x2aa	; 0x2aa <_Z11lcd_wr_charc>
		flag=1;
     43a:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==1 || flag==1)
     43c:	c1 30       	cpi	r28, 0x01	; 1
     43e:	d1 05       	cpc	r29, r1
     440:	11 f0       	breq	.+4      	; 0x446 <_Z9lcd_printccji+0xec>
     442:	81 30       	cpi	r24, 0x01	; 1
     444:	61 f4       	brne	.+24     	; 0x45e <_Z9lcd_printccji+0x104>
	{
		unit = value%10 + 48;
     446:	c8 01       	movw	r24, r16
     448:	6a e0       	ldi	r22, 0x0A	; 10
     44a:	70 e0       	ldi	r23, 0x00	; 0
     44c:	0e 94 70 12 	call	0x24e0	; 0x24e0 <__udivmodhi4>
     450:	c0 96       	adiw	r24, 0x30	; 48
     452:	90 93 82 0c 	sts	0x0C82, r25
     456:	80 93 81 0c 	sts	0x0C81, r24
		lcd_wr_char(unit);
     45a:	0e 94 55 01 	call	0x2aa	; 0x2aa <_Z11lcd_wr_charc>
	}
	if(digits>5)
     45e:	c6 30       	cpi	r28, 0x06	; 6
     460:	d1 05       	cpc	r29, r1
     462:	1c f0       	brlt	.+6      	; 0x46a <_Z9lcd_printccji+0x110>
	{
		lcd_wr_char('E');
     464:	85 e4       	ldi	r24, 0x45	; 69
     466:	0e 94 55 01 	call	0x2aa	; 0x2aa <_Z11lcd_wr_charc>
	}
	
}
     46a:	df 91       	pop	r29
     46c:	cf 91       	pop	r28
     46e:	1f 91       	pop	r17
     470:	0f 91       	pop	r16
     472:	08 95       	ret

00000474 <_Z3remi>:
Output :      none
Logic:       it searches for the node in arena and sets it value to 0 to make sure that the node can never be used again in path
Example Call:rem(55)
*/
void rem(int b)
{
     474:	9c 01       	movw	r18, r24
     476:	e4 ea       	ldi	r30, 0xA4	; 164
     478:	f2 e0       	ldi	r31, 0x02	; 2
Input :       b(node number)
Output :      none
Logic:       it searches for the node in arena and sets it value to 0 to make sure that the node can never be used again in path
Example Call:rem(55)
*/
void rem(int b)
     47a:	40 e6       	ldi	r20, 0x60	; 96
     47c:	55 e0       	ldi	r21, 0x05	; 5
     47e:	df 01       	movw	r26, r30
{
    for(int i=0;i<175;i++)
    {
        if(dist[i][0]==b||dist[i][1]==b)
     480:	80 81       	ld	r24, Z
     482:	91 81       	ldd	r25, Z+1	; 0x01
     484:	82 17       	cp	r24, r18
     486:	93 07       	cpc	r25, r19
     488:	29 f0       	breq	.+10     	; 0x494 <_Z3remi+0x20>
     48a:	82 81       	ldd	r24, Z+2	; 0x02
     48c:	93 81       	ldd	r25, Z+3	; 0x03
     48e:	82 17       	cp	r24, r18
     490:	93 07       	cpc	r25, r19
     492:	39 f4       	brne	.+14     	; 0x4a2 <_Z3remi+0x2e>
        {
            //cout<<"\nREMOVED="<<i<<" "<<dist[i][0]<< " "<<dist[i][1];
            dist[i][0]=0;
     494:	11 96       	adiw	r26, 0x01	; 1
     496:	1c 92       	st	X, r1
     498:	1e 92       	st	-X, r1
            dist[i][1]=0;
     49a:	13 96       	adiw	r26, 0x03	; 3
     49c:	1c 92       	st	X, r1
     49e:	1e 92       	st	-X, r1
     4a0:	12 97       	sbiw	r26, 0x02	; 2
     4a2:	34 96       	adiw	r30, 0x04	; 4
Logic:       it searches for the node in arena and sets it value to 0 to make sure that the node can never be used again in path
Example Call:rem(55)
*/
void rem(int b)
{
    for(int i=0;i<175;i++)
     4a4:	e4 17       	cp	r30, r20
     4a6:	f5 07       	cpc	r31, r21
     4a8:	51 f7       	brne	.-44     	; 0x47e <_Z3remi+0xa>
            dist[i][1]=0;
        }


    }
}
     4aa:	08 95       	ret

000004ac <_Z13shortest_pathjj>:
Output :      none
Logic:       standard implementation of dijkstra algorithm
Example Call:shortest_path(55,68)
*/
void shortest_path(unsigned int s,unsigned int t)
{
     4ac:	2f 92       	push	r2
     4ae:	3f 92       	push	r3
     4b0:	4f 92       	push	r4
     4b2:	5f 92       	push	r5
     4b4:	6f 92       	push	r6
     4b6:	7f 92       	push	r7
     4b8:	8f 92       	push	r8
     4ba:	9f 92       	push	r9
     4bc:	af 92       	push	r10
     4be:	bf 92       	push	r11
     4c0:	cf 92       	push	r12
     4c2:	df 92       	push	r13
     4c4:	ef 92       	push	r14
     4c6:	ff 92       	push	r15
     4c8:	0f 93       	push	r16
     4ca:	1f 93       	push	r17
     4cc:	cf 93       	push	r28
     4ce:	df 93       	push	r29
     4d0:	cd b7       	in	r28, 0x3d	; 61
     4d2:	de b7       	in	r29, 0x3e	; 62
     4d4:	28 97       	sbiw	r28, 0x08	; 8
     4d6:	0f b6       	in	r0, 0x3f	; 63
     4d8:	f8 94       	cli
     4da:	de bf       	out	0x3e, r29	; 62
     4dc:	0f be       	out	0x3f, r0	; 63
     4de:	cd bf       	out	0x3d, r28	; 61
     4e0:	1c 01       	movw	r2, r24
     4e2:	4b 01       	movw	r8, r22

   unsigned int f=0,part;
   unsigned int i,k,min;
   struct state *p;
   for(p=&state[0];p<&state[n];p++)
     4e4:	80 91 30 05 	lds	r24, 0x0530
     4e8:	90 91 31 05 	lds	r25, 0x0531
     4ec:	9c 01       	movw	r18, r24
     4ee:	22 0f       	add	r18, r18
     4f0:	33 1f       	adc	r19, r19
     4f2:	22 0f       	add	r18, r18
     4f4:	33 1f       	adc	r19, r19
     4f6:	82 0f       	add	r24, r18
     4f8:	93 1f       	adc	r25, r19
     4fa:	81 59       	subi	r24, 0x91	; 145
     4fc:	9a 4f       	sbci	r25, 0xFA	; 250
     4fe:	25 e0       	ldi	r18, 0x05	; 5
     500:	8f 36       	cpi	r24, 0x6F	; 111
     502:	92 07       	cpc	r25, r18
     504:	a1 f0       	breq	.+40     	; 0x52e <_Z13shortest_pathjj+0x82>
     506:	98 f0       	brcs	.+38     	; 0x52e <_Z13shortest_pathjj+0x82>
     508:	a3 e7       	ldi	r26, 0x73	; 115
     50a:	b5 e0       	ldi	r27, 0x05	; 5
     50c:	fd 01       	movw	r30, r26
     50e:	34 97       	sbiw	r30, 0x04	; 4
   {
		p->predecessor=-1;
     510:	2f ef       	ldi	r18, 0xFF	; 255
     512:	3f ef       	ldi	r19, 0xFF	; 255
		p->length=INFINITE;
     514:	4f e0       	ldi	r20, 0x0F	; 15
     516:	57 e2       	ldi	r21, 0x27	; 39
		p->label=tentative;
     518:	61 e0       	ldi	r22, 0x01	; 1
   unsigned int f=0,part;
   unsigned int i,k,min;
   struct state *p;
   for(p=&state[0];p<&state[n];p++)
   {
		p->predecessor=-1;
     51a:	31 83       	std	Z+1, r19	; 0x01
     51c:	20 83       	st	Z, r18
		p->length=INFINITE;
     51e:	53 83       	std	Z+3, r21	; 0x03
     520:	42 83       	std	Z+2, r20	; 0x02
		p->label=tentative;
     522:	6c 93       	st	X, r22
{

   unsigned int f=0,part;
   unsigned int i,k,min;
   struct state *p;
   for(p=&state[0];p<&state[n];p++)
     524:	35 96       	adiw	r30, 0x05	; 5
     526:	15 96       	adiw	r26, 0x05	; 5
     528:	e8 17       	cp	r30, r24
     52a:	f9 07       	cpc	r31, r25
     52c:	b0 f3       	brcs	.-20     	; 0x51a <_Z13shortest_pathjj+0x6e>
   {
		p->predecessor=-1;
		p->length=INFINITE;
		p->label=tentative;
   }
   state[t].length=0;
     52e:	f4 01       	movw	r30, r8
     530:	ee 0f       	add	r30, r30
     532:	ff 1f       	adc	r31, r31
     534:	ee 0f       	add	r30, r30
     536:	ff 1f       	adc	r31, r31
     538:	e8 0d       	add	r30, r8
     53a:	f9 1d       	adc	r31, r9
     53c:	e1 59       	subi	r30, 0x91	; 145
     53e:	fa 4f       	sbci	r31, 0xFA	; 250
     540:	13 82       	std	Z+3, r1	; 0x03
     542:	12 82       	std	Z+2, r1	; 0x02
   state[t].label=permanent;
     544:	14 82       	std	Z+4, r1	; 0x04
   k=t;

   do
   {
	   //lcd_string("do started");
		for(i=0;i<n;i++)
     546:	c0 90 30 05 	lds	r12, 0x0530
     54a:	d0 90 31 05 	lds	r13, 0x0531
		p->length=INFINITE;
		p->label=tentative;
   }
   state[t].length=0;
   state[t].label=permanent;
   k=t;
     54e:	a4 01       	movw	r20, r8

   do
   {
	   //lcd_string("do started");
		for(i=0;i<n;i++)
     550:	66 24       	eor	r6, r6
     552:	77 24       	eor	r7, r7
     554:	0f 2e       	mov	r0, r31
     556:	f3 e7       	ldi	r31, 0x73	; 115
     558:	4f 2e       	mov	r4, r31
     55a:	f5 e0       	ldi	r31, 0x05	; 5
     55c:	5f 2e       	mov	r5, r31
     55e:	f0 2d       	mov	r31, r0
     560:	c2 01       	movw	r24, r4
     562:	04 97       	sbiw	r24, 0x04	; 4
     564:	9c 83       	std	Y+4, r25	; 0x04
     566:	8b 83       	std	Y+3, r24	; 0x03
     568:	4d 82       	std	Y+5, r4	; 0x05
     56a:	5e 82       	std	Y+6, r5	; 0x06
Input :       s(source),d(destination)
Output :      none
Logic:       standard implementation of dijkstra algorithm
Example Call:shortest_path(55,68)
*/
void shortest_path(unsigned int s,unsigned int t)
     56c:	60 e3       	ldi	r22, 0x30	; 48
     56e:	75 e0       	ldi	r23, 0x05	; 5
   k=t;

   do
   {
	   //lcd_string("do started");
		for(i=0;i<n;i++)
     570:	0f 2e       	mov	r0, r31
     572:	f4 ea       	ldi	r31, 0xA4	; 164
     574:	af 2e       	mov	r10, r31
     576:	f2 e0       	ldi	r31, 0x02	; 2
     578:	bf 2e       	mov	r11, r31
     57a:	f0 2d       	mov	r31, r0
     57c:	c1 14       	cp	r12, r1
     57e:	d1 04       	cpc	r13, r1
     580:	09 f4       	brne	.+2      	; 0x584 <_Z13shortest_pathjj+0xd8>
     582:	6e c0       	rjmp	.+220    	; 0x660 <_Z13shortest_pathjj+0x1b4>
     584:	f2 01       	movw	r30, r4
     586:	eb 80       	ldd	r14, Y+3	; 0x03
     588:	fc 80       	ldd	r15, Y+4	; 0x04
     58a:	0d 81       	ldd	r16, Y+5	; 0x05
     58c:	1e 81       	ldd	r17, Y+6	; 0x06
     58e:	d3 01       	movw	r26, r6
			}
			//lcd_string("break");

			 if(f==1 && state[i].label==tentative)
			{
				if(state[k].length+1<state[i].length)
     590:	ca 01       	movw	r24, r20
     592:	88 0f       	add	r24, r24
     594:	99 1f       	adc	r25, r25
     596:	88 0f       	add	r24, r24
     598:	99 1f       	adc	r25, r25
     59a:	84 0f       	add	r24, r20
     59c:	95 1f       	adc	r25, r21
     59e:	81 59       	subi	r24, 0x91	; 145
     5a0:	9a 4f       	sbci	r25, 0xFA	; 250
     5a2:	9c 01       	movw	r18, r24
     5a4:	2e 5f       	subi	r18, 0xFE	; 254
     5a6:	3f 4f       	sbci	r19, 0xFF	; 255
     5a8:	3a 83       	std	Y+2, r19	; 0x02
     5aa:	29 83       	std	Y+1, r18	; 0x01
     5ac:	18 87       	std	Y+8, r17	; 0x08
     5ae:	0f 83       	std	Y+7, r16	; 0x07
     5b0:	87 01       	movw	r16, r14
     5b2:	7f 01       	movw	r14, r30
     5b4:	38 c0       	rjmp	.+112    	; 0x626 <_Z13shortest_pathjj+0x17a>
		{
			f=0;
			for(part=0;part<163;part++)
			{

				if((dist[part][0]==k)&&(dist[part][1]==i))
     5b6:	80 81       	ld	r24, Z
     5b8:	91 81       	ldd	r25, Z+1	; 0x01
     5ba:	84 17       	cp	r24, r20
     5bc:	95 07       	cpc	r25, r21
     5be:	29 f4       	brne	.+10     	; 0x5ca <_Z13shortest_pathjj+0x11e>
     5c0:	82 81       	ldd	r24, Z+2	; 0x02
     5c2:	93 81       	ldd	r25, Z+3	; 0x03
     5c4:	8a 17       	cp	r24, r26
     5c6:	9b 07       	cpc	r25, r27
     5c8:	39 f0       	breq	.+14     	; 0x5d8 <_Z13shortest_pathjj+0x12c>
     5ca:	34 96       	adiw	r30, 0x04	; 4
   {
	   //lcd_string("do started");
		for(i=0;i<n;i++)
		{
			f=0;
			for(part=0;part<163;part++)
     5cc:	e6 17       	cp	r30, r22
     5ce:	f7 07       	cpc	r31, r23
     5d0:	91 f7       	brne	.-28     	; 0x5b6 <_Z13shortest_pathjj+0x10a>
     5d2:	38 87       	std	Y+8, r19	; 0x08
     5d4:	2f 83       	std	Y+7, r18	; 0x07
     5d6:	1b c0       	rjmp	.+54     	; 0x60e <_Z13shortest_pathjj+0x162>
     5d8:	38 87       	std	Y+8, r19	; 0x08
     5da:	2f 83       	std	Y+7, r18	; 0x07

				}
			}
			//lcd_string("break");

			 if(f==1 && state[i].label==tentative)
     5dc:	f9 01       	movw	r30, r18
     5de:	80 81       	ld	r24, Z
     5e0:	81 30       	cpi	r24, 0x01	; 1
     5e2:	a9 f4       	brne	.+42     	; 0x60e <_Z13shortest_pathjj+0x162>
			{
				if(state[k].length+1<state[i].length)
     5e4:	e9 81       	ldd	r30, Y+1	; 0x01
     5e6:	fa 81       	ldd	r31, Y+2	; 0x02
     5e8:	80 81       	ld	r24, Z
     5ea:	91 81       	ldd	r25, Z+1	; 0x01
     5ec:	01 96       	adiw	r24, 0x01	; 1
     5ee:	f8 01       	movw	r30, r16
     5f0:	22 81       	ldd	r18, Z+2	; 0x02
     5f2:	33 81       	ldd	r19, Z+3	; 0x03
     5f4:	82 17       	cp	r24, r18
     5f6:	93 07       	cpc	r25, r19
     5f8:	50 f4       	brcc	.+20     	; 0x60e <_Z13shortest_pathjj+0x162>
				{
					state[i].predecessor=k;
     5fa:	51 83       	std	Z+1, r21	; 0x01
     5fc:	40 83       	st	Z, r20
					state[i].length=state[k].length+1;
     5fe:	e9 81       	ldd	r30, Y+1	; 0x01
     600:	fa 81       	ldd	r31, Y+2	; 0x02
     602:	80 81       	ld	r24, Z
     604:	91 81       	ldd	r25, Z+1	; 0x01
     606:	01 96       	adiw	r24, 0x01	; 1
     608:	f8 01       	movw	r30, r16
     60a:	93 83       	std	Z+3, r25	; 0x03
     60c:	82 83       	std	Z+2, r24	; 0x02
   k=t;

   do
   {
	   //lcd_string("do started");
		for(i=0;i<n;i++)
     60e:	11 96       	adiw	r26, 0x01	; 1
     610:	2f 81       	ldd	r18, Y+7	; 0x07
     612:	38 85       	ldd	r19, Y+8	; 0x08
     614:	2b 5f       	subi	r18, 0xFB	; 251
     616:	3f 4f       	sbci	r19, 0xFF	; 255
     618:	38 87       	std	Y+8, r19	; 0x08
     61a:	2f 83       	std	Y+7, r18	; 0x07
     61c:	0b 5f       	subi	r16, 0xFB	; 251
     61e:	1f 4f       	sbci	r17, 0xFF	; 255
     620:	ac 15       	cp	r26, r12
     622:	bd 05       	cpc	r27, r13
     624:	20 f4       	brcc	.+8      	; 0x62e <_Z13shortest_pathjj+0x182>
     626:	f5 01       	movw	r30, r10
     628:	2f 81       	ldd	r18, Y+7	; 0x07
     62a:	38 85       	ldd	r19, Y+8	; 0x08
     62c:	c4 cf       	rjmp	.-120    	; 0x5b6 <_Z13shortest_pathjj+0x10a>
     62e:	af e0       	ldi	r26, 0x0F	; 15
     630:	b7 e2       	ldi	r27, 0x27	; 39
     632:	a3 01       	movw	r20, r6
     634:	93 01       	movw	r18, r6
     636:	87 01       	movw	r16, r14
		}
		//lcd_string("to");
		k=0;min=INFINITE;
		for(i=0;i<n;i++)
		{
			if(state[i].label==tentative && state[i].length<min)
     638:	f8 01       	movw	r30, r16
     63a:	80 81       	ld	r24, Z
     63c:	81 30       	cpi	r24, 0x01	; 1
     63e:	41 f4       	brne	.+16     	; 0x650 <_Z13shortest_pathjj+0x1a4>
Input :       s(source),d(destination)
Output :      none
Logic:       standard implementation of dijkstra algorithm
Example Call:shortest_path(55,68)
*/
void shortest_path(unsigned int s,unsigned int t)
     640:	32 97       	sbiw	r30, 0x02	; 2
		}
		//lcd_string("to");
		k=0;min=INFINITE;
		for(i=0;i<n;i++)
		{
			if(state[i].label==tentative && state[i].length<min)
     642:	80 81       	ld	r24, Z
     644:	91 81       	ldd	r25, Z+1	; 0x01
     646:	8a 17       	cp	r24, r26
     648:	9b 07       	cpc	r25, r27
     64a:	10 f4       	brcc	.+4      	; 0x650 <_Z13shortest_pathjj+0x1a4>
			{
				min=state[i].length;
     64c:	dc 01       	movw	r26, r24
		}
		//lcd_string("to");
		k=0;min=INFINITE;
		for(i=0;i<n;i++)
		{
			if(state[i].label==tentative && state[i].length<min)
     64e:	a9 01       	movw	r20, r18
				}
		    }
		}
		//lcd_string("to");
		k=0;min=INFINITE;
		for(i=0;i<n;i++)
     650:	2f 5f       	subi	r18, 0xFF	; 255
     652:	3f 4f       	sbci	r19, 0xFF	; 255
     654:	0b 5f       	subi	r16, 0xFB	; 251
     656:	1f 4f       	sbci	r17, 0xFF	; 255
     658:	2c 15       	cp	r18, r12
     65a:	3d 05       	cpc	r19, r13
     65c:	69 f7       	brne	.-38     	; 0x638 <_Z13shortest_pathjj+0x18c>
     65e:	01 c0       	rjmp	.+2      	; 0x662 <_Z13shortest_pathjj+0x1b6>
   k=t;

   do
   {
	   //lcd_string("do started");
		for(i=0;i<n;i++)
     660:	a3 01       	movw	r20, r6
				min=state[i].length;
				k=i;
			}

		}
		state[k].label=permanent;
     662:	ca 01       	movw	r24, r20
     664:	88 0f       	add	r24, r24
     666:	99 1f       	adc	r25, r25
     668:	88 0f       	add	r24, r24
     66a:	99 1f       	adc	r25, r25
     66c:	84 0f       	add	r24, r20
     66e:	95 1f       	adc	r25, r21
     670:	81 59       	subi	r24, 0x91	; 145
     672:	9a 4f       	sbci	r25, 0xFA	; 250
     674:	dc 01       	movw	r26, r24
     676:	14 96       	adiw	r26, 0x04	; 4
     678:	1c 92       	st	X, r1
     67a:	14 97       	sbiw	r26, 0x04	; 4
   }
   state[t].length=0;
   state[t].label=permanent;
   k=t;

   do
     67c:	42 15       	cp	r20, r2
     67e:	53 05       	cpc	r21, r3
     680:	09 f0       	breq	.+2      	; 0x684 <_Z13shortest_pathjj+0x1d8>
     682:	7c cf       	rjmp	.-264    	; 0x57c <_Z13shortest_pathjj+0xd0>
     684:	0f 2e       	mov	r0, r31
     686:	f9 ee       	ldi	r31, 0xE9	; 233
     688:	cf 2e       	mov	r12, r31
     68a:	fa e0       	ldi	r31, 0x0A	; 10
     68c:	df 2e       	mov	r13, r31
     68e:	f0 2d       	mov	r31, r0
     690:	f6 01       	movw	r30, r12
     692:	91 01       	movw	r18, r2
     694:	40 e0       	ldi	r20, 0x00	; 0
     696:	50 e0       	ldi	r21, 0x00	; 0
   i=0;k=s;
   do
   {
		path[i++]=k;

		k=state[k].predecessor;
     698:	0f e6       	ldi	r16, 0x6F	; 111
     69a:	15 e0       	ldi	r17, 0x05	; 5
     69c:	01 c0       	rjmp	.+2      	; 0x6a0 <_Z13shortest_pathjj+0x1f4>
   }while(k!=s);

   i=0;k=s;
   do
   {
		path[i++]=k;
     69e:	ab 01       	movw	r20, r22
     6a0:	21 93       	st	Z+, r18
     6a2:	31 93       	st	Z+, r19
     6a4:	ba 01       	movw	r22, r20
     6a6:	6f 5f       	subi	r22, 0xFF	; 255
     6a8:	7f 4f       	sbci	r23, 0xFF	; 255

		k=state[k].predecessor;
     6aa:	c9 01       	movw	r24, r18
     6ac:	88 0f       	add	r24, r24
     6ae:	99 1f       	adc	r25, r25
     6b0:	88 0f       	add	r24, r24
     6b2:	99 1f       	adc	r25, r25
     6b4:	82 0f       	add	r24, r18
     6b6:	93 1f       	adc	r25, r19
     6b8:	80 0f       	add	r24, r16
     6ba:	91 1f       	adc	r25, r17
     6bc:	dc 01       	movw	r26, r24
     6be:	2d 91       	ld	r18, X+
     6c0:	3c 91       	ld	r19, X
     6c2:	11 97       	sbiw	r26, 0x01	; 1
		}
		state[k].label=permanent;
   }while(k!=s);

   i=0;k=s;
   do
     6c4:	82 16       	cp	r8, r18
     6c6:	93 06       	cpc	r9, r19
     6c8:	51 f7       	brne	.-44     	; 0x69e <_Z13shortest_pathjj+0x1f2>
   {
		path[i++]=k;

		k=state[k].predecessor;
   }while(k!=t);
   path[i++]=t;
     6ca:	fb 01       	movw	r30, r22
     6cc:	ee 0f       	add	r30, r30
     6ce:	ff 1f       	adc	r31, r31
     6d0:	e7 51       	subi	r30, 0x17	; 23
     6d2:	f5 4f       	sbci	r31, 0xF5	; 245
     6d4:	91 82       	std	Z+1, r9	; 0x01
     6d6:	80 82       	st	Z, r8
     6d8:	ca 01       	movw	r24, r20
     6da:	02 96       	adiw	r24, 0x02	; 2
   tot=i;
     6dc:	90 93 58 09 	sts	0x0958, r25
     6e0:	80 93 57 09 	sts	0x0957, r24
   for(unsigned int j=0;j<tot-1;j++)
     6e4:	bf ef       	ldi	r27, 0xFF	; 255
     6e6:	4f 3f       	cpi	r20, 0xFF	; 255
     6e8:	5b 07       	cpc	r21, r27
     6ea:	79 f0       	breq	.+30     	; 0x70a <_Z13shortest_pathjj+0x25e>
     6ec:	a9 e5       	ldi	r26, 0x59	; 89
     6ee:	b9 e0       	ldi	r27, 0x09	; 9
Input :       s(source),d(destination)
Output :      none
Logic:       standard implementation of dijkstra algorithm
Example Call:shortest_path(55,68)
*/
void shortest_path(unsigned int s,unsigned int t)
     6f0:	ca 01       	movw	r24, r20
     6f2:	88 0f       	add	r24, r24
     6f4:	99 1f       	adc	r25, r25
     6f6:	85 51       	subi	r24, 0x15	; 21
     6f8:	95 4f       	sbci	r25, 0xF5	; 245
     6fa:	f6 01       	movw	r30, r12
   }while(k!=t);
   path[i++]=t;
   tot=i;
   for(unsigned int j=0;j<tot-1;j++)
	{
		original[j]=path[j];
     6fc:	21 91       	ld	r18, Z+
     6fe:	31 91       	ld	r19, Z+
     700:	2d 93       	st	X+, r18
     702:	3d 93       	st	X+, r19

		k=state[k].predecessor;
   }while(k!=t);
   path[i++]=t;
   tot=i;
   for(unsigned int j=0;j<tot-1;j++)
     704:	e8 17       	cp	r30, r24
     706:	f9 07       	cpc	r31, r25
     708:	c9 f7       	brne	.-14     	; 0x6fc <_Z13shortest_pathjj+0x250>
	{
		original[j]=path[j];
	}
	for(unsigned int j=0;j<tot-1;j++)
     70a:	60 90 57 09 	lds	r6, 0x0957
     70e:	70 90 58 09 	lds	r7, 0x0958
Input :       s(source),d(destination)
Output :      none
Logic:       standard implementation of dijkstra algorithm
Example Call:shortest_path(55,68)
*/
void shortest_path(unsigned int s,unsigned int t)
     712:	c3 01       	movw	r24, r6
     714:	88 0f       	add	r24, r24
     716:	99 1f       	adc	r25, r25
     718:	0f 2e       	mov	r0, r31
     71a:	f7 ee       	ldi	r31, 0xE7	; 231
     71c:	8f 2e       	mov	r8, r31
     71e:	fa e0       	ldi	r31, 0x0A	; 10
     720:	9f 2e       	mov	r9, r31
     722:	f0 2d       	mov	r31, r0
     724:	88 0e       	add	r8, r24
     726:	99 1e       	adc	r9, r25
     728:	76 01       	movw	r14, r12
	{
		original[j]=path[j];
	}
	for(unsigned int j=0;j<tot-1;j++)
	{
		if((path[j]/10==path[j+1]/10)&&(path[j]<path[j+1]))
     72a:	0f 2e       	mov	r0, r31
     72c:	fa e0       	ldi	r31, 0x0A	; 10
     72e:	af 2e       	mov	r10, r31
     730:	bb 24       	eor	r11, r11
     732:	f0 2d       	mov	r31, r0
		else if((path[j]/10==path[j+1]/10)&&(path[j]>path[j+1]))
		path[j]='N';
		else if(path[j]>path[j+1])
		path[j]='W';
		else if(path[j]<path[j+1])
		path[j]='E';
     734:	0f 2e       	mov	r0, r31
     736:	f5 e4       	ldi	r31, 0x45	; 69
     738:	4f 2e       	mov	r4, r31
     73a:	55 24       	eor	r5, r5
     73c:	f0 2d       	mov	r31, r0
		if((path[j]/10==path[j+1]/10)&&(path[j]<path[j+1]))
		path[j]='S';
		else if((path[j]/10==path[j+1]/10)&&(path[j]>path[j+1]))
		path[j]='N';
		else if(path[j]>path[j+1])
		path[j]='W';
     73e:	0f 2e       	mov	r0, r31
     740:	f7 e5       	ldi	r31, 0x57	; 87
     742:	2f 2e       	mov	r2, r31
     744:	33 24       	eor	r3, r3
     746:	f0 2d       	mov	r31, r0
     748:	3b c0       	rjmp	.+118    	; 0x7c0 <_Z13shortest_pathjj+0x314>
	{
		original[j]=path[j];
	}
	for(unsigned int j=0;j<tot-1;j++)
	{
		if((path[j]/10==path[j+1]/10)&&(path[j]<path[j+1]))
     74a:	f7 01       	movw	r30, r14
     74c:	20 81       	ld	r18, Z
     74e:	31 81       	ldd	r19, Z+1	; 0x01
     750:	02 80       	ldd	r0, Z+2	; 0x02
     752:	f3 81       	ldd	r31, Z+3	; 0x03
     754:	e0 2d       	mov	r30, r0
     756:	c9 01       	movw	r24, r18
     758:	b5 01       	movw	r22, r10
     75a:	0e 94 84 12 	call	0x2508	; 0x2508 <__divmodhi4>
     75e:	7a 83       	std	Y+2, r23	; 0x02
     760:	69 83       	std	Y+1, r22	; 0x01
     762:	cf 01       	movw	r24, r30
     764:	b5 01       	movw	r22, r10
     766:	0e 94 84 12 	call	0x2508	; 0x2508 <__divmodhi4>
     76a:	89 81       	ldd	r24, Y+1	; 0x01
     76c:	9a 81       	ldd	r25, Y+2	; 0x02
     76e:	86 17       	cp	r24, r22
     770:	97 07       	cpc	r25, r23
     772:	a1 f4       	brne	.+40     	; 0x79c <_Z13shortest_pathjj+0x2f0>
     774:	2e 17       	cp	r18, r30
     776:	3f 07       	cpc	r19, r31
     778:	3c f4       	brge	.+14     	; 0x788 <_Z13shortest_pathjj+0x2dc>
		path[j]='S';
     77a:	e3 e5       	ldi	r30, 0x53	; 83
     77c:	f0 e0       	ldi	r31, 0x00	; 0
     77e:	d7 01       	movw	r26, r14
     780:	11 96       	adiw	r26, 0x01	; 1
     782:	fc 93       	st	X, r31
     784:	ee 93       	st	-X, r30
     786:	18 c0       	rjmp	.+48     	; 0x7b8 <_Z13shortest_pathjj+0x30c>
		else if((path[j]/10==path[j+1]/10)&&(path[j]>path[j+1]))
     788:	e2 17       	cp	r30, r18
     78a:	f3 07       	cpc	r31, r19
     78c:	ac f4       	brge	.+42     	; 0x7b8 <_Z13shortest_pathjj+0x30c>
		path[j]='N';
     78e:	ee e4       	ldi	r30, 0x4E	; 78
     790:	f0 e0       	ldi	r31, 0x00	; 0
     792:	d7 01       	movw	r26, r14
     794:	11 96       	adiw	r26, 0x01	; 1
     796:	fc 93       	st	X, r31
     798:	ee 93       	st	-X, r30
     79a:	0e c0       	rjmp	.+28     	; 0x7b8 <_Z13shortest_pathjj+0x30c>
		else if(path[j]>path[j+1])
     79c:	e2 17       	cp	r30, r18
     79e:	f3 07       	cpc	r31, r19
     7a0:	2c f4       	brge	.+10     	; 0x7ac <_Z13shortest_pathjj+0x300>
		path[j]='W';
     7a2:	d7 01       	movw	r26, r14
     7a4:	11 96       	adiw	r26, 0x01	; 1
     7a6:	3c 92       	st	X, r3
     7a8:	2e 92       	st	-X, r2
     7aa:	06 c0       	rjmp	.+12     	; 0x7b8 <_Z13shortest_pathjj+0x30c>
		else if(path[j]<path[j+1])
     7ac:	2e 17       	cp	r18, r30
     7ae:	3f 07       	cpc	r19, r31
     7b0:	1c f4       	brge	.+6      	; 0x7b8 <_Z13shortest_pathjj+0x30c>
		path[j]='E';
     7b2:	f7 01       	movw	r30, r14
     7b4:	51 82       	std	Z+1, r5	; 0x01
     7b6:	40 82       	st	Z, r4
     7b8:	22 e0       	ldi	r18, 0x02	; 2
     7ba:	30 e0       	ldi	r19, 0x00	; 0
     7bc:	e2 0e       	add	r14, r18
     7be:	f3 1e       	adc	r15, r19
   tot=i;
   for(unsigned int j=0;j<tot-1;j++)
	{
		original[j]=path[j];
	}
	for(unsigned int j=0;j<tot-1;j++)
     7c0:	e8 14       	cp	r14, r8
     7c2:	f9 04       	cpc	r15, r9
     7c4:	11 f6       	brne	.-124    	; 0x74a <_Z13shortest_pathjj+0x29e>
		path[j]='W';
		else if(path[j]<path[j+1])
		path[j]='E';

	}
	for(unsigned int j=0;j<tot-1;j++)
     7c6:	31 e0       	ldi	r19, 0x01	; 1
     7c8:	63 16       	cp	r6, r19
     7ca:	71 04       	cpc	r7, r1
     7cc:	e9 f1       	breq	.+122    	; 0x848 <_Z13shortest_pathjj+0x39c>
     7ce:	f6 01       	movw	r30, r12
		if((char)path[j]=='E')
		path[j]=1;
		if((char)path[j]=='S')
		path[j]=2;
		if((char)path[j]=='W')
		path[j]=3;
     7d0:	83 e0       	ldi	r24, 0x03	; 3
     7d2:	90 e0       	ldi	r25, 0x00	; 0
		if((char)path[j]=='N')
		path[j]=0;
		if((char)path[j]=='E')
		path[j]=1;
		if((char)path[j]=='S')
		path[j]=2;
     7d4:	22 e0       	ldi	r18, 0x02	; 2
     7d6:	30 e0       	ldi	r19, 0x00	; 0
	for(unsigned int j=0;j<tot-1;j++)
	{
		if((char)path[j]=='N')
		path[j]=0;
		if((char)path[j]=='E')
		path[j]=1;
     7d8:	41 e0       	ldi	r20, 0x01	; 1
     7da:	50 e0       	ldi	r21, 0x00	; 0
Input :       s(source),d(destination)
Output :      none
Logic:       standard implementation of dijkstra algorithm
Example Call:shortest_path(55,68)
*/
void shortest_path(unsigned int s,unsigned int t)
     7dc:	df 01       	movw	r26, r30
		path[j]='E';

	}
	for(unsigned int j=0;j<tot-1;j++)
	{
		if((char)path[j]=='N')
     7de:	60 81       	ld	r22, Z
     7e0:	6e 34       	cpi	r22, 0x4E	; 78
     7e2:	19 f4       	brne	.+6      	; 0x7ea <_Z13shortest_pathjj+0x33e>
		path[j]=0;
     7e4:	11 82       	std	Z+1, r1	; 0x01
     7e6:	10 82       	st	Z, r1
     7e8:	06 c0       	rjmp	.+12     	; 0x7f6 <_Z13shortest_pathjj+0x34a>
		if((char)path[j]=='E')
     7ea:	60 81       	ld	r22, Z
     7ec:	65 34       	cpi	r22, 0x45	; 69
     7ee:	19 f4       	brne	.+6      	; 0x7f6 <_Z13shortest_pathjj+0x34a>
		path[j]=1;
     7f0:	51 83       	std	Z+1, r21	; 0x01
     7f2:	40 83       	st	Z, r20
     7f4:	07 c0       	rjmp	.+14     	; 0x804 <_Z13shortest_pathjj+0x358>
		if((char)path[j]=='S')
     7f6:	6c 91       	ld	r22, X
     7f8:	63 35       	cpi	r22, 0x53	; 83
     7fa:	21 f4       	brne	.+8      	; 0x804 <_Z13shortest_pathjj+0x358>
		path[j]=2;
     7fc:	11 96       	adiw	r26, 0x01	; 1
     7fe:	3c 93       	st	X, r19
     800:	2e 93       	st	-X, r18
     802:	06 c0       	rjmp	.+12     	; 0x810 <_Z13shortest_pathjj+0x364>
		if((char)path[j]=='W')
     804:	6c 91       	ld	r22, X
     806:	67 35       	cpi	r22, 0x57	; 87
     808:	19 f4       	brne	.+6      	; 0x810 <_Z13shortest_pathjj+0x364>
		path[j]=3;
     80a:	11 96       	adiw	r26, 0x01	; 1
     80c:	9c 93       	st	X, r25
     80e:	8e 93       	st	-X, r24
     810:	32 96       	adiw	r30, 0x02	; 2
		path[j]='W';
		else if(path[j]<path[j+1])
		path[j]='E';

	}
	for(unsigned int j=0;j<tot-1;j++)
     812:	e8 15       	cp	r30, r8
     814:	f9 05       	cpc	r31, r9
     816:	11 f7       	brne	.-60     	; 0x7dc <_Z13shortest_pathjj+0x330>
     818:	f6 01       	movw	r30, r12
     81a:	80 e0       	ldi	r24, 0x00	; 0
     81c:	90 e0       	ldi	r25, 0x00	; 0
	int temp=0;
	for(unsigned int j=0;j<tot-1;j++)
	{
		temp=current;
		current=path[j];
		path[j]=(path[j]-temp)*90;
     81e:	6a e5       	ldi	r22, 0x5A	; 90
     820:	70 e0       	ldi	r23, 0x00	; 0
     822:	01 c0       	rjmp	.+2      	; 0x826 <_Z13shortest_pathjj+0x37a>
	int current =0;
	int temp=0;
	for(unsigned int j=0;j<tot-1;j++)
	{
		temp=current;
		current=path[j];
     824:	ca 01       	movw	r24, r20
     826:	40 81       	ld	r20, Z
     828:	51 81       	ldd	r21, Z+1	; 0x01
		path[j]=(path[j]-temp)*90;
     82a:	da 01       	movw	r26, r20
     82c:	a8 1b       	sub	r26, r24
     82e:	b9 0b       	sbc	r27, r25
     830:	a6 9f       	mul	r26, r22
     832:	90 01       	movw	r18, r0
     834:	a7 9f       	mul	r26, r23
     836:	30 0d       	add	r19, r0
     838:	b6 9f       	mul	r27, r22
     83a:	30 0d       	add	r19, r0
     83c:	11 24       	eor	r1, r1
     83e:	21 93       	st	Z+, r18
     840:	31 93       	st	Z+, r19
		path[j]=3;
	}

	int current =0;
	int temp=0;
	for(unsigned int j=0;j<tot-1;j++)
     842:	e8 15       	cp	r30, r8
     844:	f9 05       	cpc	r31, r9
     846:	71 f7       	brne	.-36     	; 0x824 <_Z13shortest_pathjj+0x378>
		temp=current;
		current=path[j];
		path[j]=(path[j]-temp)*90;
		//cout<<path[j]<<" ";
	}
	for(unsigned int j=0;j<tot-1;j++)
     848:	40 91 57 09 	lds	r20, 0x0957
     84c:	50 91 58 09 	lds	r21, 0x0958
     850:	41 30       	cpi	r20, 0x01	; 1
     852:	51 05       	cpc	r21, r1
     854:	c1 f1       	breq	.+112    	; 0x8c6 <_Z13shortest_pathjj+0x41a>
     856:	41 50       	subi	r20, 0x01	; 1
     858:	50 40       	sbci	r21, 0x00	; 0
     85a:	20 e0       	ldi	r18, 0x00	; 0
     85c:	30 e0       	ldi	r19, 0x00	; 0
	{
		if(path[j]==90||path[j]==-270)
		{
			path[j]=3;
     85e:	63 e0       	ldi	r22, 0x03	; 3
     860:	70 e0       	ldi	r23, 0x00	; 0
		}
		else if(path[j]==270||path[j]==-90)
		{
			path[j]=1;
     862:	aa 24       	eor	r10, r10
     864:	bb 24       	eor	r11, r11
     866:	a3 94       	inc	r10
		{
			path[j]=4;
		}
		else
		{
			path[j]=2;
     868:	88 24       	eor	r8, r8
     86a:	99 24       	eor	r9, r9
     86c:	68 94       	set
     86e:	81 f8       	bld	r8, 1
		{
			path[j]=1;
		}
		else if(path[j]==0)
		{
			path[j]=4;
     870:	04 e0       	ldi	r16, 0x04	; 4
     872:	10 e0       	ldi	r17, 0x00	; 0
     874:	7a 01       	movw	r14, r20
     876:	a9 01       	movw	r20, r18
     878:	96 01       	movw	r18, r12
Input :       s(source),d(destination)
Output :      none
Logic:       standard implementation of dijkstra algorithm
Example Call:shortest_path(55,68)
*/
void shortest_path(unsigned int s,unsigned int t)
     87a:	f9 01       	movw	r30, r18
		path[j]=(path[j]-temp)*90;
		//cout<<path[j]<<" ";
	}
	for(unsigned int j=0;j<tot-1;j++)
	{
		if(path[j]==90||path[j]==-270)
     87c:	80 81       	ld	r24, Z
     87e:	91 81       	ldd	r25, Z+1	; 0x01
     880:	8a 35       	cpi	r24, 0x5A	; 90
     882:	91 05       	cpc	r25, r1
     884:	21 f0       	breq	.+8      	; 0x88e <_Z13shortest_pathjj+0x3e2>
     886:	be ef       	ldi	r27, 0xFE	; 254
     888:	82 3f       	cpi	r24, 0xF2	; 242
     88a:	9b 07       	cpc	r25, r27
     88c:	19 f4       	brne	.+6      	; 0x894 <_Z13shortest_pathjj+0x3e8>
		{
			path[j]=3;
     88e:	71 83       	std	Z+1, r23	; 0x01
     890:	60 83       	st	Z, r22
     892:	12 c0       	rjmp	.+36     	; 0x8b8 <_Z13shortest_pathjj+0x40c>
		}
		else if(path[j]==270||path[j]==-90)
     894:	a1 e0       	ldi	r26, 0x01	; 1
     896:	8e 30       	cpi	r24, 0x0E	; 14
     898:	9a 07       	cpc	r25, r26
     89a:	21 f0       	breq	.+8      	; 0x8a4 <_Z13shortest_pathjj+0x3f8>
     89c:	bf ef       	ldi	r27, 0xFF	; 255
     89e:	86 3a       	cpi	r24, 0xA6	; 166
     8a0:	9b 07       	cpc	r25, r27
     8a2:	19 f4       	brne	.+6      	; 0x8aa <_Z13shortest_pathjj+0x3fe>
		{
			path[j]=1;
     8a4:	b1 82       	std	Z+1, r11	; 0x01
     8a6:	a0 82       	st	Z, r10
     8a8:	07 c0       	rjmp	.+14     	; 0x8b8 <_Z13shortest_pathjj+0x40c>
		}
		else if(path[j]==0)
     8aa:	00 97       	sbiw	r24, 0x00	; 0
     8ac:	19 f4       	brne	.+6      	; 0x8b4 <_Z13shortest_pathjj+0x408>
		{
			path[j]=4;
     8ae:	11 83       	std	Z+1, r17	; 0x01
     8b0:	00 83       	st	Z, r16
     8b2:	02 c0       	rjmp	.+4      	; 0x8b8 <_Z13shortest_pathjj+0x40c>
		}
		else
		{
			path[j]=2;
     8b4:	91 82       	std	Z+1, r9	; 0x01
     8b6:	80 82       	st	Z, r8
		temp=current;
		current=path[j];
		path[j]=(path[j]-temp)*90;
		//cout<<path[j]<<" ";
	}
	for(unsigned int j=0;j<tot-1;j++)
     8b8:	4f 5f       	subi	r20, 0xFF	; 255
     8ba:	5f 4f       	sbci	r21, 0xFF	; 255
     8bc:	2e 5f       	subi	r18, 0xFE	; 254
     8be:	3f 4f       	sbci	r19, 0xFF	; 255
     8c0:	4e 15       	cp	r20, r14
     8c2:	5f 05       	cpc	r21, r15
     8c4:	d0 f2       	brcs	.-76     	; 0x87a <_Z13shortest_pathjj+0x3ce>
		{
			path[j]=2;
		}
	}

}
     8c6:	28 96       	adiw	r28, 0x08	; 8
     8c8:	0f b6       	in	r0, 0x3f	; 63
     8ca:	f8 94       	cli
     8cc:	de bf       	out	0x3e, r29	; 62
     8ce:	0f be       	out	0x3f, r0	; 63
     8d0:	cd bf       	out	0x3d, r28	; 61
     8d2:	df 91       	pop	r29
     8d4:	cf 91       	pop	r28
     8d6:	1f 91       	pop	r17
     8d8:	0f 91       	pop	r16
     8da:	ff 90       	pop	r15
     8dc:	ef 90       	pop	r14
     8de:	df 90       	pop	r13
     8e0:	cf 90       	pop	r12
     8e2:	bf 90       	pop	r11
     8e4:	af 90       	pop	r10
     8e6:	9f 90       	pop	r9
     8e8:	8f 90       	pop	r8
     8ea:	7f 90       	pop	r7
     8ec:	6f 90       	pop	r6
     8ee:	5f 90       	pop	r5
     8f0:	4f 90       	pop	r4
     8f2:	3f 90       	pop	r3
     8f4:	2f 90       	pop	r2
     8f6:	08 95       	ret

000008f8 <_Z10filter_redv>:

//Filter Selection
void filter_red(void)    //Used to select red filter
{
	//Filter Select - red filter
	PORTD = PORTD & 0xBF; //set S2 low
     8f8:	5e 98       	cbi	0x0b, 6	; 11
	PORTD = PORTD & 0x7F; //set S3 low
     8fa:	5f 98       	cbi	0x0b, 7	; 11
}
     8fc:	08 95       	ret

000008fe <_Z12filter_greenv>:

void filter_green(void)	//Used to select green filter
{
	//Filter Select - green filter
	PORTD = PORTD | 0x40; //set S2 High
     8fe:	5e 9a       	sbi	0x0b, 6	; 11
	PORTD = PORTD | 0x80; //set S3 High
     900:	5f 9a       	sbi	0x0b, 7	; 11
}
     902:	08 95       	ret

00000904 <_Z11filter_bluev>:

void filter_blue(void)	//Used to select blue filter
{
	//Filter Select - blue filter
	PORTD = PORTD & 0xBF; //set S2 low
     904:	5e 98       	cbi	0x0b, 6	; 11
	PORTD = PORTD | 0x80; //set S3 High
     906:	5f 9a       	sbi	0x0b, 7	; 11
}
     908:	08 95       	ret

0000090a <_Z12filter_clearv>:

void filter_clear(void)	//select no filter
{
	//Filter Select - no filter
	PORTD = PORTD | 0x40; //set S2 High
     90a:	5e 9a       	sbi	0x0b, 6	; 11
	PORTD = PORTD & 0x7F; //set S3 Low
     90c:	5f 98       	cbi	0x0b, 7	; 11
}
     90e:	08 95       	ret

00000910 <_Z20color_sensor_scalingv>:
//Color Sensing Scaling
void color_sensor_scaling()		//This function is used to select the scaled down version of the original frequency of the output generated by the color sensor, generally 20% scaling is preferable, though you can change the values as per your application by referring datasheet
{
	//Output Scaling 20% from datasheet
	//PORTD = PORTD & 0xEF;
	PORTD = PORTD | 0x10; //set S0 high
     910:	5c 9a       	sbi	0x0b, 4	; 11
	//PORTD = PORTD & 0xDF; //set S1 low
	PORTD = PORTD | 0x20; //set S1 high
     912:	5d 9a       	sbi	0x0b, 5	; 11
}
     914:	08 95       	ret

00000916 <_Z5colorv>:
Logic:       it identifies the color of patch and save it in variable name color1 and 2
Example Call:color()
*/
void color(void) // function to select red filter and display the count generated by the sensor on LCD. The count will be more if the color is red. The count will be very less if its blue or green.
{
	color_sensor_scaling();
     916:	0e 94 88 04 	call	0x910	; 0x910 <_Z20color_sensor_scalingv>
	//Red
	filter_red(); //select red filter
     91a:	0e 94 7c 04 	call	0x8f8	; 0x8f8 <_Z10filter_redv>
	pulse=0; //reset the count to 0
     91e:	10 92 65 05 	sts	0x0565, r1
     922:	10 92 66 05 	sts	0x0566, r1
     926:	10 92 67 05 	sts	0x0567, r1
     92a:	10 92 68 05 	sts	0x0568, r1
     92e:	8f ef       	ldi	r24, 0xFF	; 255
     930:	9f e7       	ldi	r25, 0x7F	; 127
     932:	a4 e0       	ldi	r26, 0x04	; 4
     934:	81 50       	subi	r24, 0x01	; 1
     936:	90 40       	sbci	r25, 0x00	; 0
     938:	a0 40       	sbci	r26, 0x00	; 0
     93a:	e1 f7       	brne	.-8      	; 0x934 <_Z5colorv+0x1e>
     93c:	00 c0       	rjmp	.+0      	; 0x93e <_Z5colorv+0x28>
     93e:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	red = pulse;  //store the count in variable called red
     940:	80 91 65 05 	lds	r24, 0x0565
     944:	90 91 66 05 	lds	r25, 0x0566
     948:	a0 91 67 05 	lds	r26, 0x0567
     94c:	b0 91 68 05 	lds	r27, 0x0568
     950:	80 93 61 05 	sts	0x0561, r24
     954:	90 93 62 05 	sts	0x0562, r25
     958:	a0 93 63 05 	sts	0x0563, r26
     95c:	b0 93 64 05 	sts	0x0564, r27
	
	//Green
	filter_green(); //select green filter
     960:	0e 94 7f 04 	call	0x8fe	; 0x8fe <_Z12filter_greenv>
	pulse=0; //reset the count to 0
     964:	10 92 65 05 	sts	0x0565, r1
     968:	10 92 66 05 	sts	0x0566, r1
     96c:	10 92 67 05 	sts	0x0567, r1
     970:	10 92 68 05 	sts	0x0568, r1
     974:	8f ef       	ldi	r24, 0xFF	; 255
     976:	9f e7       	ldi	r25, 0x7F	; 127
     978:	a4 e0       	ldi	r26, 0x04	; 4
     97a:	81 50       	subi	r24, 0x01	; 1
     97c:	90 40       	sbci	r25, 0x00	; 0
     97e:	a0 40       	sbci	r26, 0x00	; 0
     980:	e1 f7       	brne	.-8      	; 0x97a <_Z5colorv+0x64>
     982:	00 c0       	rjmp	.+0      	; 0x984 <_Z5colorv+0x6e>
     984:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	green = pulse;  //store the count in variable called green
     986:	80 91 65 05 	lds	r24, 0x0565
     98a:	90 91 66 05 	lds	r25, 0x0566
     98e:	a0 91 67 05 	lds	r26, 0x0567
     992:	b0 91 68 05 	lds	r27, 0x0568
     996:	80 93 59 05 	sts	0x0559, r24
     99a:	90 93 5a 05 	sts	0x055A, r25
     99e:	a0 93 5b 05 	sts	0x055B, r26
     9a2:	b0 93 5c 05 	sts	0x055C, r27
	
	//Blue
	filter_blue(); //select blue filter
     9a6:	0e 94 82 04 	call	0x904	; 0x904 <_Z11filter_bluev>
	pulse=0; //reset the count to 0
     9aa:	10 92 65 05 	sts	0x0565, r1
     9ae:	10 92 66 05 	sts	0x0566, r1
     9b2:	10 92 67 05 	sts	0x0567, r1
     9b6:	10 92 68 05 	sts	0x0568, r1
     9ba:	8f ef       	ldi	r24, 0xFF	; 255
     9bc:	9f e7       	ldi	r25, 0x7F	; 127
     9be:	a4 e0       	ldi	r26, 0x04	; 4
     9c0:	81 50       	subi	r24, 0x01	; 1
     9c2:	90 40       	sbci	r25, 0x00	; 0
     9c4:	a0 40       	sbci	r26, 0x00	; 0
     9c6:	e1 f7       	brne	.-8      	; 0x9c0 <_Z5colorv+0xaa>
     9c8:	00 c0       	rjmp	.+0      	; 0x9ca <_Z5colorv+0xb4>
     9ca:	00 00       	nop
	_delay_ms(100); //capture the pulses for 100 ms or 0.1 second
	blue = pulse;  //store the count in variable called blue
     9cc:	80 91 65 05 	lds	r24, 0x0565
     9d0:	90 91 66 05 	lds	r25, 0x0566
     9d4:	a0 91 67 05 	lds	r26, 0x0567
     9d8:	b0 91 68 05 	lds	r27, 0x0568
     9dc:	80 93 5d 05 	sts	0x055D, r24
     9e0:	90 93 5e 05 	sts	0x055E, r25
     9e4:	a0 93 5f 05 	sts	0x055F, r26
     9e8:	b0 93 60 05 	sts	0x0560, r27
	/*lcd_print(1,1,red,5);
	lcd_print(1,7,blue,5);
	lcd_print(1,13,green,5);
	*/
	if(red>blue &&red >green)				//red color detected
     9ec:	40 91 61 05 	lds	r20, 0x0561
     9f0:	50 91 62 05 	lds	r21, 0x0562
     9f4:	60 91 63 05 	lds	r22, 0x0563
     9f8:	70 91 64 05 	lds	r23, 0x0564
     9fc:	80 91 5d 05 	lds	r24, 0x055D
     a00:	90 91 5e 05 	lds	r25, 0x055E
     a04:	a0 91 5f 05 	lds	r26, 0x055F
     a08:	b0 91 60 05 	lds	r27, 0x0560
     a0c:	84 17       	cp	r24, r20
     a0e:	95 07       	cpc	r25, r21
     a10:	a6 07       	cpc	r26, r22
     a12:	b7 07       	cpc	r27, r23
     a14:	e0 f4       	brcc	.+56     	; 0xa4e <_Z5colorv+0x138>
     a16:	40 91 61 05 	lds	r20, 0x0561
     a1a:	50 91 62 05 	lds	r21, 0x0562
     a1e:	60 91 63 05 	lds	r22, 0x0563
     a22:	70 91 64 05 	lds	r23, 0x0564
     a26:	80 91 59 05 	lds	r24, 0x0559
     a2a:	90 91 5a 05 	lds	r25, 0x055A
     a2e:	a0 91 5b 05 	lds	r26, 0x055B
     a32:	b0 91 5c 05 	lds	r27, 0x055C
     a36:	84 17       	cp	r24, r20
     a38:	95 07       	cpc	r25, r21
     a3a:	a6 07       	cpc	r26, r22
     a3c:	b7 07       	cpc	r27, r23
     a3e:	38 f4       	brcc	.+14     	; 0xa4e <_Z5colorv+0x138>
	{
			data=92;
     a40:	8c e5       	ldi	r24, 0x5C	; 92
     a42:	90 e0       	ldi	r25, 0x00	; 0
     a44:	90 93 6e 05 	sts	0x056E, r25
     a48:	80 93 6d 05 	sts	0x056D, r24
     a4c:	08 95       	ret

	}
	else                  //green color detected
	{
		data=93;
     a4e:	8d e5       	ldi	r24, 0x5D	; 93
     a50:	90 e0       	ldi	r25, 0x00	; 0
     a52:	90 93 6e 05 	sts	0x056E, r25
     a56:	80 93 6d 05 	sts	0x056D, r24
     a5a:	08 95       	ret

00000a5c <__vector_25>:
Logic:       -
Example Call:   -
*/

SIGNAL(SIG_USART0_RECV) 		// ISR for receive complete interrupt
{
     a5c:	1f 92       	push	r1
     a5e:	0f 92       	push	r0
     a60:	0f b6       	in	r0, 0x3f	; 63
     a62:	0f 92       	push	r0
     a64:	11 24       	eor	r1, r1
     a66:	8f 93       	push	r24
	rec = UDR0; 				//making copy of data from UDR0 in 'rec' variable
     a68:	80 91 c6 00 	lds	r24, 0x00C6
     a6c:	80 93 6b 05 	sts	0x056B, r24
     a70:	10 92 6c 05 	sts	0x056C, r1
}
     a74:	8f 91       	pop	r24
     a76:	0f 90       	pop	r0
     a78:	0f be       	out	0x3f, r0	; 63
     a7a:	0f 90       	pop	r0
     a7c:	1f 90       	pop	r1
     a7e:	18 95       	reti

00000a80 <_Z10uart0_initv>:
// actual baud rate:9600 (error 0.0%)
// char size: 8 bit
// parity: Disabled
void uart0_init(void)
{
	UCSR0B = 0x00; //disable while setting baud rate
     a80:	e1 ec       	ldi	r30, 0xC1	; 193
     a82:	f0 e0       	ldi	r31, 0x00	; 0
     a84:	10 82       	st	Z, r1
	UCSR0A = 0x00;
     a86:	10 92 c0 00 	sts	0x00C0, r1
	UCSR0C = 0x06;
     a8a:	86 e0       	ldi	r24, 0x06	; 6
     a8c:	80 93 c2 00 	sts	0x00C2, r24
	UBRR0L = 0x5F; //set baud rate lo
     a90:	8f e5       	ldi	r24, 0x5F	; 95
     a92:	80 93 c4 00 	sts	0x00C4, r24
	UBRR0H = 0x00; //set baud rate hi
     a96:	10 92 c5 00 	sts	0x00C5, r1
	UCSR0B = 0x98;
     a9a:	88 e9       	ldi	r24, 0x98	; 152
     a9c:	80 83       	st	Z, r24
}
     a9e:	08 95       	ret

00000aa0 <_Z17servo2_pin_configv>:
//Configure PORTB 6 pin for servo motor 2 operation
void servo2_pin_config (void)
{
	DDRB  = DDRB | 0x40;  //making PORTB 6 pin output
     aa0:	26 9a       	sbi	0x04, 6	; 4
	PORTB = PORTB | 0x40; //setting PORTB 6 pin to logic 1
     aa2:	2e 9a       	sbi	0x05, 6	; 5
}
     aa4:	08 95       	ret

00000aa6 <_Z10uart2_initv>:
// actual baud rate:9600 (error 0.0%)
// char size: 8 bit
// parity: Disabled
void uart2_init(void)
{
	UCSR2B = 0x00; //disable while setting baud rate
     aa6:	e1 ed       	ldi	r30, 0xD1	; 209
     aa8:	f0 e0       	ldi	r31, 0x00	; 0
     aaa:	10 82       	st	Z, r1
	UCSR2A = 0x00;
     aac:	10 92 d0 00 	sts	0x00D0, r1
	UCSR2C = 0x06;
     ab0:	86 e0       	ldi	r24, 0x06	; 6
     ab2:	80 93 d2 00 	sts	0x00D2, r24
	UBRR2L = 0x5F; //set baud rate lo
     ab6:	8f e5       	ldi	r24, 0x5F	; 95
     ab8:	80 93 d4 00 	sts	0x00D4, r24
	UBRR2H = 0x00; //set baud rate hi
     abc:	10 92 d5 00 	sts	0x00D5, r1
	UCSR2B = 0x98;
     ac0:	88 e9       	ldi	r24, 0x98	; 152
     ac2:	80 83       	st	Z, r24
}
     ac4:	08 95       	ret

00000ac6 <_Z10led_configv>:
void led_config(void)  //configuration setting for led on port H 5,6,7
{
	
	DDRH=0b11100000;
     ac6:	80 ee       	ldi	r24, 0xE0	; 224
     ac8:	80 93 01 01 	sts	0x0101, r24
	PORTH=0x00;
     acc:	10 92 02 01 	sts	0x0102, r1
}
     ad0:	08 95       	ret

00000ad2 <_Z6red_onv>:
Logic:       -
Example Call:   red_on();
*/
void red_on(void)    //for red led
{
	PORTH=0b10000000;
     ad2:	80 e8       	ldi	r24, 0x80	; 128
     ad4:	80 93 02 01 	sts	0x0102, r24
}
     ad8:	08 95       	ret

00000ada <_Z7led_offv>:
Logic:       -
Example Call:   led_off();
*/
void led_off(void)			//for led off
{
	PORTH=0x00;
     ada:	10 92 02 01 	sts	0x0102, r1
}
     ade:	08 95       	ret

00000ae0 <_Z7blue_onv>:
Logic:       -
Example Call:   blue_on();
*/
void blue_on(void)		//for blue led
{
	PORTH=0b00100000;
     ae0:	80 e2       	ldi	r24, 0x20	; 32
     ae2:	80 93 02 01 	sts	0x0102, r24
}
     ae6:	08 95       	ret

00000ae8 <_Z8green_onv>:
Logic:       -
Example Call:   green_on();
*/
void green_on(void)		//for green led
{
	PORTH=0b01000000;
     ae8:	80 e4       	ldi	r24, 0x40	; 64
     aea:	80 93 02 01 	sts	0x0102, r24
}
     aee:	08 95       	ret

00000af0 <_Z17motion_pin_configv>:
//Function to configure ports to enable robot's motion
void motion_pin_config (void)
{
	DDRA = DDRA | 0x0F;
     af0:	81 b1       	in	r24, 0x01	; 1
     af2:	8f 60       	ori	r24, 0x0F	; 15
     af4:	81 b9       	out	0x01, r24	; 1
	PORTA = PORTA & 0xF0;
     af6:	82 b1       	in	r24, 0x02	; 2
     af8:	80 7f       	andi	r24, 0xF0	; 240
     afa:	82 b9       	out	0x02, r24	; 2
	DDRL = DDRL | 0x18;   //Setting PL3 and PL4 pins as output for PWM generation
     afc:	ea e0       	ldi	r30, 0x0A	; 10
     afe:	f1 e0       	ldi	r31, 0x01	; 1
     b00:	80 81       	ld	r24, Z
     b02:	88 61       	ori	r24, 0x18	; 24
     b04:	80 83       	st	Z, r24
	PORTL = PORTL | 0x18; //PL3 and PL4 pins are for velocity control using PWM.
     b06:	eb e0       	ldi	r30, 0x0B	; 11
     b08:	f1 e0       	ldi	r31, 0x01	; 1
     b0a:	80 81       	ld	r24, Z
     b0c:	88 61       	ori	r24, 0x18	; 24
     b0e:	80 83       	st	Z, r24
}
     b10:	08 95       	ret

00000b12 <_Z15lcd_port_configv>:
//Function to configure LCD port
void lcd_port_config (void)
{
	DDRC = DDRC | 0xF7; //all the LCD pin's direction set as output
     b12:	87 b1       	in	r24, 0x07	; 7
     b14:	87 6f       	ori	r24, 0xF7	; 247
     b16:	87 b9       	out	0x07, r24	; 7
	PORTC = PORTC & 0x80; // all the LCD pins are set to logic 0 except PORTC 7
     b18:	88 b1       	in	r24, 0x08	; 8
     b1a:	80 78       	andi	r24, 0x80	; 128
     b1c:	88 b9       	out	0x08, r24	; 8
}
     b1e:	08 95       	ret

00000b20 <_Z14adc_pin_configv>:

//ADC pin configuration
void adc_pin_config (void)
{
	DDRF = 0x00;
     b20:	10 ba       	out	0x10, r1	; 16
	PORTF = 0x00;
     b22:	11 ba       	out	0x11, r1	; 17
	DDRK = 0x00;
     b24:	10 92 07 01 	sts	0x0107, r1
	PORTK = 0x00;
     b28:	10 92 08 01 	sts	0x0108, r1
}
     b2c:	08 95       	ret

00000b2e <_Z23left_encoder_pin_configv>:

//Function to configure INT4 (PORTE 4) pin as input for the left position encoder
void left_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xEF;  //Set the direction of the PORTE 4 pin as input
     b2e:	6c 98       	cbi	0x0d, 4	; 13
	PORTE = PORTE | 0x10; //Enable internal pull-up for PORTE 4 pin
     b30:	74 9a       	sbi	0x0e, 4	; 14
}
     b32:	08 95       	ret

00000b34 <_Z24right_encoder_pin_configv>:

//Function to configure INT5 (PORTE 5) pin as input for the right position encoder
void right_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xDF;  //Set the direction of the PORTE 4 pin as input
     b34:	6d 98       	cbi	0x0d, 5	; 13
	PORTE = PORTE | 0x20; //Enable internal pull-up for PORTE 4 pin
     b36:	75 9a       	sbi	0x0e, 5	; 14
}
     b38:	08 95       	ret

00000b3a <_Z17buzzer_pin_configv>:
void buzzer_pin_config (void)
{
	DDRC = DDRC | 0x08;		//Setting PORTC 3 as output
     b3a:	3b 9a       	sbi	0x07, 3	; 7
	PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer
     b3c:	43 98       	cbi	0x08, 3	; 8
}
     b3e:	08 95       	ret

00000b40 <_Z23color_sensor_pin_configv>:

void color_sensor_pin_config(void)
{
	DDRD  = DDRD | 0xFE; //set PD0 as input for color sensor output
     b40:	8a b1       	in	r24, 0x0a	; 10
     b42:	8e 6f       	ori	r24, 0xFE	; 254
     b44:	8a b9       	out	0x0a, r24	; 10
	PORTD = PORTD | 0x01;//Enable internal pull-up for PORTD 0 pin
     b46:	58 9a       	sbi	0x0b, 0	; 11
}
     b48:	08 95       	ret

00000b4a <_Z31color_sensor_pin_interrupt_initv>:


void color_sensor_pin_interrupt_init(void) //Interrupt 0 enable
{
	cli(); //Clears the global interrupt
     b4a:	f8 94       	cli
	EICRA = EICRA | 0x02; // INT0 is set to trigger with falling edge
     b4c:	e9 e6       	ldi	r30, 0x69	; 105
     b4e:	f0 e0       	ldi	r31, 0x00	; 0
     b50:	80 81       	ld	r24, Z
     b52:	82 60       	ori	r24, 0x02	; 2
     b54:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x01; // Enable Interrupt INT0 for color sensor
     b56:	e8 9a       	sbi	0x1d, 0	; 29
	sei(); // Enables the global interrupt
     b58:	78 94       	sei
}
     b5a:	08 95       	ret

00000b5c <__vector_1>:
//ISR for color sensor
ISR(INT0_vect)
{
     b5c:	1f 92       	push	r1
     b5e:	0f 92       	push	r0
     b60:	0f b6       	in	r0, 0x3f	; 63
     b62:	0f 92       	push	r0
     b64:	11 24       	eor	r1, r1
     b66:	8f 93       	push	r24
     b68:	9f 93       	push	r25
     b6a:	af 93       	push	r26
     b6c:	bf 93       	push	r27
	pulse++; //increment on receiving pulse from the color sensor
     b6e:	80 91 65 05 	lds	r24, 0x0565
     b72:	90 91 66 05 	lds	r25, 0x0566
     b76:	a0 91 67 05 	lds	r26, 0x0567
     b7a:	b0 91 68 05 	lds	r27, 0x0568
     b7e:	01 96       	adiw	r24, 0x01	; 1
     b80:	a1 1d       	adc	r26, r1
     b82:	b1 1d       	adc	r27, r1
     b84:	80 93 65 05 	sts	0x0565, r24
     b88:	90 93 66 05 	sts	0x0566, r25
     b8c:	a0 93 67 05 	sts	0x0567, r26
     b90:	b0 93 68 05 	sts	0x0568, r27
}
     b94:	bf 91       	pop	r27
     b96:	af 91       	pop	r26
     b98:	9f 91       	pop	r25
     b9a:	8f 91       	pop	r24
     b9c:	0f 90       	pop	r0
     b9e:	0f be       	out	0x3f, r0	; 63
     ba0:	0f 90       	pop	r0
     ba2:	1f 90       	pop	r1
     ba4:	18 95       	reti

00000ba6 <_Z17servo1_pin_configv>:
//Configure PORTB 5 pin for servo motor 1 operation
void servo1_pin_config (void)
{
	DDRB  = DDRB | 0x20;  //making PORTB 5 pin output
     ba6:	25 9a       	sbi	0x04, 5	; 4
	PORTB = PORTB | 0x20; //setting PORTB 5 pin to logic 1
     ba8:	2d 9a       	sbi	0x05, 5	; 5
}
     baa:	08 95       	ret

00000bac <_Z9port_initv>:
//Function to initialize ports
void port_init()
{
	servo1_pin_config();
     bac:	0e 94 d3 05 	call	0xba6	; 0xba6 <_Z17servo1_pin_configv>
	servo2_pin_config();
     bb0:	0e 94 50 05 	call	0xaa0	; 0xaa0 <_Z17servo2_pin_configv>
	motion_pin_config(); //robot motion pins config
     bb4:	0e 94 78 05 	call	0xaf0	; 0xaf0 <_Z17motion_pin_configv>
	left_encoder_pin_config(); //left encoder pin config
     bb8:	0e 94 97 05 	call	0xb2e	; 0xb2e <_Z23left_encoder_pin_configv>
	right_encoder_pin_config(); //right encoder pin config
     bbc:	0e 94 9a 05 	call	0xb34	; 0xb34 <_Z24right_encoder_pin_configv>
	lcd_port_config();
     bc0:	0e 94 89 05 	call	0xb12	; 0xb12 <_Z15lcd_port_configv>
	adc_pin_config();
     bc4:	0e 94 90 05 	call	0xb20	; 0xb20 <_Z14adc_pin_configv>
	buzzer_pin_config();
     bc8:	0e 94 9d 05 	call	0xb3a	; 0xb3a <_Z17buzzer_pin_configv>
	led_config();
     bcc:	0e 94 63 05 	call	0xac6	; 0xac6 <_Z10led_configv>
	color_sensor_pin_config();
     bd0:	0e 94 a0 05 	call	0xb40	; 0xb40 <_Z23color_sensor_pin_configv>
}
     bd4:	08 95       	ret

00000bd6 <_Z11timer5_initv>:
// Prescale:256
// PWM 8bit fast, TOP=0x00FF
// Timer Frequency:225.000Hz
void timer5_init()
{
	TCCR5B = 0x00;	//Stop
     bd6:	e1 e2       	ldi	r30, 0x21	; 33
     bd8:	f1 e0       	ldi	r31, 0x01	; 1
     bda:	10 82       	st	Z, r1
	TCNT5H = 0xFF;	//Counter higher 8-bit value to which OCR5xH value is compared with
     bdc:	8f ef       	ldi	r24, 0xFF	; 255
     bde:	80 93 25 01 	sts	0x0125, r24
	TCNT5L = 0x01;	//Counter lower 8-bit value to which OCR5xH value is compared with
     be2:	91 e0       	ldi	r25, 0x01	; 1
     be4:	90 93 24 01 	sts	0x0124, r25
	OCR5AH = 0x00;	//Output compare register high value for Left Motor
     be8:	10 92 29 01 	sts	0x0129, r1
	OCR5AL = 0xFF;	//Output compare register low value for Left Motor
     bec:	80 93 28 01 	sts	0x0128, r24
	OCR5BH = 0x00;	//Output compare register high value for Right Motor
     bf0:	10 92 2b 01 	sts	0x012B, r1
	OCR5BL = 0xFF;	//Output compare register low value for Right Motor
     bf4:	80 93 2a 01 	sts	0x012A, r24
	OCR5CH = 0x00;	//Output compare register high value for Motor C1
     bf8:	10 92 2d 01 	sts	0x012D, r1
	OCR5CL = 0xFF;	//Output compare register low value for Motor C1
     bfc:	80 93 2c 01 	sts	0x012C, r24
	TCCR5A = 0xA9;	/*{COM5A1=1, COM5A0=0; COM5B1=1, COM5B0=0; COM5C1=1 COM5C0=0}
     c00:	89 ea       	ldi	r24, 0xA9	; 169
     c02:	80 93 20 01 	sts	0x0120, r24
 					  For Overriding normal port functionality to OCRnA outputs.
				  	  {WGM51=0, WGM50=1} Along With WGM52 in TCCR5B for Selecting FAST PWM 8-bit Mode*/
	
	TCCR5B = 0x0B;	//WGM12=1; CS12=0, CS11=1, CS10=1 (Prescaler=64)
     c06:	8b e0       	ldi	r24, 0x0B	; 11
     c08:	80 83       	st	Z, r24
}
     c0a:	08 95       	ret

00000c0c <_Z8adc_initv>:

void adc_init()
{
	ADCSRA = 0x00;
     c0c:	ea e7       	ldi	r30, 0x7A	; 122
     c0e:	f0 e0       	ldi	r31, 0x00	; 0
     c10:	10 82       	st	Z, r1
	ADCSRB = 0x00;		//MUX5 = 0
     c12:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
     c16:	80 e2       	ldi	r24, 0x20	; 32
     c18:	80 93 7c 00 	sts	0x007C, r24
	ACSR = 0x80;
     c1c:	80 e8       	ldi	r24, 0x80	; 128
     c1e:	80 bf       	out	0x30, r24	; 48
	ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
     c20:	86 e8       	ldi	r24, 0x86	; 134
     c22:	80 83       	st	Z, r24
}
     c24:	08 95       	ret

00000c26 <_Z14ADC_Conversionh>:

//Function For ADC Conversion
unsigned char ADC_Conversion(unsigned char Ch)
{
	unsigned char a;
	if(Ch>7)
     c26:	88 30       	cpi	r24, 0x08	; 8
     c28:	18 f0       	brcs	.+6      	; 0xc30 <_Z14ADC_Conversionh+0xa>
	{
		ADCSRB = 0x08;
     c2a:	98 e0       	ldi	r25, 0x08	; 8
     c2c:	90 93 7b 00 	sts	0x007B, r25
	}
	Ch = Ch & 0x07;
     c30:	87 70       	andi	r24, 0x07	; 7
	ADMUX= 0x20| Ch;
     c32:	80 62       	ori	r24, 0x20	; 32
     c34:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA = ADCSRA | 0x40;		//Set start conversion bit
     c38:	ea e7       	ldi	r30, 0x7A	; 122
     c3a:	f0 e0       	ldi	r31, 0x00	; 0
     c3c:	80 81       	ld	r24, Z
     c3e:	80 64       	ori	r24, 0x40	; 64
     c40:	80 83       	st	Z, r24
	while((ADCSRA&0x10)==0);	//Wait for conversion to complete
     c42:	80 81       	ld	r24, Z
     c44:	84 ff       	sbrs	r24, 4
     c46:	fd cf       	rjmp	.-6      	; 0xc42 <_Z14ADC_Conversionh+0x1c>
	a=ADCH;
     c48:	80 91 79 00 	lds	r24, 0x0079
	ADCSRA = ADCSRA|0x10; //clear ADIF (ADC Interrupt Flag) by writing 1 to it
     c4c:	ea e7       	ldi	r30, 0x7A	; 122
     c4e:	f0 e0       	ldi	r31, 0x00	; 0
     c50:	90 81       	ld	r25, Z
     c52:	90 61       	ori	r25, 0x10	; 16
     c54:	90 83       	st	Z, r25
	ADCSRB = 0x00;
     c56:	10 92 7b 00 	sts	0x007B, r1
	return a;
}
     c5a:	08 95       	ret

00000c5c <_Z12print_sensorcch>:

//Function To Print Sesor Values At Desired Row And Coloumn Location on LCD
void print_sensor(char row, char coloumn,unsigned char channel)
{
     c5c:	cf 93       	push	r28
     c5e:	df 93       	push	r29
     c60:	d8 2f       	mov	r29, r24
     c62:	c6 2f       	mov	r28, r22
     c64:	84 2f       	mov	r24, r20
	
	ADC_Value = ADC_Conversion(channel);
     c66:	0e 94 13 06 	call	0xc26	; 0xc26 <_Z14ADC_Conversionh>
     c6a:	48 2f       	mov	r20, r24
     c6c:	80 93 4b 05 	sts	0x054B, r24
	lcd_print(row, coloumn, ADC_Value, 3);
     c70:	8d 2f       	mov	r24, r29
     c72:	6c 2f       	mov	r22, r28
     c74:	50 e0       	ldi	r21, 0x00	; 0
     c76:	23 e0       	ldi	r18, 0x03	; 3
     c78:	30 e0       	ldi	r19, 0x00	; 0
     c7a:	0e 94 ad 01 	call	0x35a	; 0x35a <_Z9lcd_printccji>
}
     c7e:	df 91       	pop	r29
     c80:	cf 91       	pop	r28
     c82:	08 95       	ret

00000c84 <_Z36left_position_encoder_interrupt_initv>:

void left_position_encoder_interrupt_init (void) //Interrupt 4 enable
{
	cli(); //Clears the global interrupt
     c84:	f8 94       	cli
	EICRB = EICRB | 0x02; // INT4 is set to trigger with falling edge
     c86:	ea e6       	ldi	r30, 0x6A	; 106
     c88:	f0 e0       	ldi	r31, 0x00	; 0
     c8a:	80 81       	ld	r24, Z
     c8c:	82 60       	ori	r24, 0x02	; 2
     c8e:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x10; // Enable Interrupt INT4 for left position encoder
     c90:	ec 9a       	sbi	0x1d, 4	; 29
	sei();   // Enables the global interrupt
     c92:	78 94       	sei
}
     c94:	08 95       	ret

00000c96 <_Z37right_position_encoder_interrupt_initv>:

void right_position_encoder_interrupt_init (void) //Interrupt 5 enable
{
	cli(); //Clears the global interrupt
     c96:	f8 94       	cli
	EICRB = EICRB | 0x08; // INT5 is set to trigger with falling edge
     c98:	ea e6       	ldi	r30, 0x6A	; 106
     c9a:	f0 e0       	ldi	r31, 0x00	; 0
     c9c:	80 81       	ld	r24, Z
     c9e:	88 60       	ori	r24, 0x08	; 8
     ca0:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x20; // Enable Interrupt INT5 for right position encoder
     ca2:	ed 9a       	sbi	0x1d, 5	; 29
	sei();   // Enables the global interrupt
     ca4:	78 94       	sei
}
     ca6:	08 95       	ret

00000ca8 <__vector_6>:

//ISR for right position encoder
ISR(INT5_vect)
{
     ca8:	1f 92       	push	r1
     caa:	0f 92       	push	r0
     cac:	0f b6       	in	r0, 0x3f	; 63
     cae:	0f 92       	push	r0
     cb0:	11 24       	eor	r1, r1
     cb2:	8f 93       	push	r24
     cb4:	9f 93       	push	r25
     cb6:	af 93       	push	r26
     cb8:	bf 93       	push	r27
	ShaftCountRight++;  //increment right shaft position count
     cba:	80 91 51 05 	lds	r24, 0x0551
     cbe:	90 91 52 05 	lds	r25, 0x0552
     cc2:	a0 91 53 05 	lds	r26, 0x0553
     cc6:	b0 91 54 05 	lds	r27, 0x0554
     cca:	01 96       	adiw	r24, 0x01	; 1
     ccc:	a1 1d       	adc	r26, r1
     cce:	b1 1d       	adc	r27, r1
     cd0:	80 93 51 05 	sts	0x0551, r24
     cd4:	90 93 52 05 	sts	0x0552, r25
     cd8:	a0 93 53 05 	sts	0x0553, r26
     cdc:	b0 93 54 05 	sts	0x0554, r27
}
     ce0:	bf 91       	pop	r27
     ce2:	af 91       	pop	r26
     ce4:	9f 91       	pop	r25
     ce6:	8f 91       	pop	r24
     ce8:	0f 90       	pop	r0
     cea:	0f be       	out	0x3f, r0	; 63
     cec:	0f 90       	pop	r0
     cee:	1f 90       	pop	r1
     cf0:	18 95       	reti

00000cf2 <__vector_5>:


//ISR for left position encoder
ISR(INT4_vect)
{
     cf2:	1f 92       	push	r1
     cf4:	0f 92       	push	r0
     cf6:	0f b6       	in	r0, 0x3f	; 63
     cf8:	0f 92       	push	r0
     cfa:	11 24       	eor	r1, r1
     cfc:	8f 93       	push	r24
     cfe:	9f 93       	push	r25
     d00:	af 93       	push	r26
     d02:	bf 93       	push	r27
	ShaftCountLeft++;  //increment left shaft position count
     d04:	80 91 55 05 	lds	r24, 0x0555
     d08:	90 91 56 05 	lds	r25, 0x0556
     d0c:	a0 91 57 05 	lds	r26, 0x0557
     d10:	b0 91 58 05 	lds	r27, 0x0558
     d14:	01 96       	adiw	r24, 0x01	; 1
     d16:	a1 1d       	adc	r26, r1
     d18:	b1 1d       	adc	r27, r1
     d1a:	80 93 55 05 	sts	0x0555, r24
     d1e:	90 93 56 05 	sts	0x0556, r25
     d22:	a0 93 57 05 	sts	0x0557, r26
     d26:	b0 93 58 05 	sts	0x0558, r27
}
     d2a:	bf 91       	pop	r27
     d2c:	af 91       	pop	r26
     d2e:	9f 91       	pop	r25
     d30:	8f 91       	pop	r24
     d32:	0f 90       	pop	r0
     d34:	0f be       	out	0x3f, r0	; 63
     d36:	0f 90       	pop	r0
     d38:	1f 90       	pop	r1
     d3a:	18 95       	reti

00000d3c <_Z8velocityhh>:
//Function for velocity control
void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR5AL = (unsigned char)left_motor;
     d3c:	80 93 28 01 	sts	0x0128, r24
	OCR5BL = (unsigned char)right_motor;
     d40:	60 93 2a 01 	sts	0x012A, r22
}
     d44:	08 95       	ret

00000d46 <_Z10motion_seth>:
void motion_set (unsigned char Direction)
{
	unsigned char PortARestore = 0;

	Direction &= 0x0F; 		// removing upper nibbel for the protection
	PortARestore = PORTA; 		// reading the PORTA original status
     d46:	92 b1       	in	r25, 0x02	; 2
	PortARestore &= 0xF0; 		// making lower direction nibbel to 0
     d48:	90 7f       	andi	r25, 0xF0	; 240
//Function used for setting motor's direction
void motion_set (unsigned char Direction)
{
	unsigned char PortARestore = 0;

	Direction &= 0x0F; 		// removing upper nibbel for the protection
     d4a:	8f 70       	andi	r24, 0x0F	; 15
	PortARestore = PORTA; 		// reading the PORTA original status
	PortARestore &= 0xF0; 		// making lower direction nibbel to 0
	PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
     d4c:	98 2b       	or	r25, r24
	PORTA = PortARestore; 		// executing the command
     d4e:	92 b9       	out	0x02, r25	; 2
}
     d50:	08 95       	ret

00000d52 <_Z9buzzer_onv>:
void buzzer_on (void)
{
	unsigned char port_restore = 0;
	port_restore = PINC;
     d52:	86 b1       	in	r24, 0x06	; 6
	port_restore = port_restore | 0x08;
     d54:	88 60       	ori	r24, 0x08	; 8
	PORTC = port_restore;
     d56:	88 b9       	out	0x08, r24	; 8
}
     d58:	08 95       	ret

00000d5a <_Z10buzzer_offv>:

void buzzer_off (void)
{
	unsigned char port_restore = 0;
	port_restore = PINC;
     d5a:	86 b1       	in	r24, 0x06	; 6
	port_restore = port_restore & 0xF7;
     d5c:	87 7f       	andi	r24, 0xF7	; 247
	PORTC = port_restore;
     d5e:	88 b9       	out	0x08, r24	; 8
}
     d60:	08 95       	ret

00000d62 <_Z7forwardv>:

void forward (void) //both wheels forward
{
	motion_set(0x06);
     d62:	86 e0       	ldi	r24, 0x06	; 6
     d64:	0e 94 a3 06 	call	0xd46	; 0xd46 <_Z10motion_seth>
}
     d68:	08 95       	ret

00000d6a <_Z4backv>:

void back (void) //both wheels backward
{
	motion_set(0x09);
     d6a:	89 e0       	ldi	r24, 0x09	; 9
     d6c:	0e 94 a3 06 	call	0xd46	; 0xd46 <_Z10motion_seth>
}
     d70:	08 95       	ret

00000d72 <_Z4leftv>:

void left (void) //Left wheel backward, Right wheel forward
{
	motion_set(0x05);
     d72:	85 e0       	ldi	r24, 0x05	; 5
     d74:	0e 94 a3 06 	call	0xd46	; 0xd46 <_Z10motion_seth>
}
     d78:	08 95       	ret

00000d7a <_Z5rightv>:

void right (void) //Left wheel forward, Right wheel backward
{
	motion_set(0x0A);
     d7a:	8a e0       	ldi	r24, 0x0A	; 10
     d7c:	0e 94 a3 06 	call	0xd46	; 0xd46 <_Z10motion_seth>
}
     d80:	08 95       	ret

00000d82 <_Z9soft_leftv>:

void soft_left (void) //Left wheel stationary, Right wheel forward
{
	motion_set(0x04);
     d82:	84 e0       	ldi	r24, 0x04	; 4
     d84:	0e 94 a3 06 	call	0xd46	; 0xd46 <_Z10motion_seth>
}
     d88:	08 95       	ret

00000d8a <_Z10soft_rightv>:

void soft_right (void) //Left wheel forward, Right wheel is stationary
{
	motion_set(0x02);
     d8a:	82 e0       	ldi	r24, 0x02	; 2
     d8c:	0e 94 a3 06 	call	0xd46	; 0xd46 <_Z10motion_seth>
}
     d90:	08 95       	ret

00000d92 <_Z11soft_left_2v>:

void soft_left_2 (void) //Left wheel backward, right wheel stationary
{
	motion_set(0x01);
     d92:	81 e0       	ldi	r24, 0x01	; 1
     d94:	0e 94 a3 06 	call	0xd46	; 0xd46 <_Z10motion_seth>
}
     d98:	08 95       	ret

00000d9a <_Z12soft_right_2v>:

void soft_right_2 (void) //Left wheel stationary, Right wheel backward
{
	motion_set(0x08);
     d9a:	88 e0       	ldi	r24, 0x08	; 8
     d9c:	0e 94 a3 06 	call	0xd46	; 0xd46 <_Z10motion_seth>
}
     da0:	08 95       	ret

00000da2 <_Z4stopv>:

void stop (void)
{
	motion_set(0x00);
     da2:	80 e0       	ldi	r24, 0x00	; 0
     da4:	0e 94 a3 06 	call	0xd46	; 0xd46 <_Z10motion_seth>
}
     da8:	08 95       	ret

00000daa <_Z23Sharp_GP2D12_estimationh>:


unsigned int Sharp_GP2D12_estimation(unsigned char adc_reading)
{
     daa:	0f 93       	push	r16
     dac:	1f 93       	push	r17
	float distance;
	unsigned int distanceInt;
	distance = (int)(10.00*(2799.6*(1.00/(pow(adc_reading,1.1546)))));
     dae:	68 2f       	mov	r22, r24
     db0:	70 e0       	ldi	r23, 0x00	; 0
     db2:	80 e0       	ldi	r24, 0x00	; 0
     db4:	90 e0       	ldi	r25, 0x00	; 0
     db6:	0e 94 1a 10 	call	0x2034	; 0x2034 <__floatunsisf>
     dba:	2f ee       	ldi	r18, 0xEF	; 239
     dbc:	39 ec       	ldi	r19, 0xC9	; 201
     dbe:	43 e9       	ldi	r20, 0x93	; 147
     dc0:	5f e3       	ldi	r21, 0x3F	; 63
     dc2:	0e 94 0b 11 	call	0x2216	; 0x2216 <pow>
     dc6:	b6 2f       	mov	r27, r22
     dc8:	a7 2f       	mov	r26, r23
     dca:	38 2f       	mov	r19, r24
     dcc:	29 2f       	mov	r18, r25
     dce:	60 e0       	ldi	r22, 0x00	; 0
     dd0:	70 e0       	ldi	r23, 0x00	; 0
     dd2:	80 e8       	ldi	r24, 0x80	; 128
     dd4:	9f e3       	ldi	r25, 0x3F	; 63
     dd6:	42 2f       	mov	r20, r18
     dd8:	0b 2f       	mov	r16, r27
     dda:	1a 2f       	mov	r17, r26
     ddc:	23 2f       	mov	r18, r19
     dde:	34 2f       	mov	r19, r20
     de0:	a9 01       	movw	r20, r18
     de2:	98 01       	movw	r18, r16
     de4:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <__divsf3>
     de8:	2a e9       	ldi	r18, 0x9A	; 154
     dea:	39 ef       	ldi	r19, 0xF9	; 249
     dec:	4e e2       	ldi	r20, 0x2E	; 46
     dee:	55 e4       	ldi	r21, 0x45	; 69
     df0:	0e 94 a8 10 	call	0x2150	; 0x2150 <__mulsf3>
     df4:	20 e0       	ldi	r18, 0x00	; 0
     df6:	30 e0       	ldi	r19, 0x00	; 0
     df8:	40 e2       	ldi	r20, 0x20	; 32
     dfa:	51 e4       	ldi	r21, 0x41	; 65
     dfc:	0e 94 a8 10 	call	0x2150	; 0x2150 <__mulsf3>
     e00:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <__fixsfsi>
     e04:	88 27       	eor	r24, r24
     e06:	77 fd       	sbrc	r23, 7
     e08:	80 95       	com	r24
     e0a:	98 2f       	mov	r25, r24
     e0c:	0e 94 1c 10 	call	0x2038	; 0x2038 <__floatsisf>
	distanceInt = (int)distance;
     e10:	0e 94 e9 0f 	call	0x1fd2	; 0x1fd2 <__fixsfsi>
	if(distanceInt>800)
	{
		distanceInt=800;
	}
	return distanceInt;
     e14:	86 2f       	mov	r24, r22
     e16:	97 2f       	mov	r25, r23
     e18:	23 e0       	ldi	r18, 0x03	; 3
     e1a:	81 32       	cpi	r24, 0x21	; 33
     e1c:	92 07       	cpc	r25, r18
     e1e:	10 f0       	brcs	.+4      	; 0xe24 <_Z23Sharp_GP2D12_estimationh+0x7a>
     e20:	80 e2       	ldi	r24, 0x20	; 32
     e22:	93 e0       	ldi	r25, 0x03	; 3
}
     e24:	1f 91       	pop	r17
     e26:	0f 91       	pop	r16
     e28:	08 95       	ret

00000e2a <_Z12angle_rotatej>:
//Function used for turning robot by specified degrees
void angle_rotate(unsigned int Degrees)
{
     e2a:	0f 93       	push	r16
     e2c:	1f 93       	push	r17
     e2e:	cf 93       	push	r28
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;

	ReqdShaftCount = (float) Degrees/ 4.090; // division by resolution to get shaft count
     e30:	bc 01       	movw	r22, r24
     e32:	80 e0       	ldi	r24, 0x00	; 0
     e34:	90 e0       	ldi	r25, 0x00	; 0
     e36:	0e 94 1a 10 	call	0x2034	; 0x2034 <__floatunsisf>
     e3a:	28 e4       	ldi	r18, 0x48	; 72
     e3c:	31 ee       	ldi	r19, 0xE1	; 225
     e3e:	42 e8       	ldi	r20, 0x82	; 130
     e40:	50 e4       	ldi	r21, 0x40	; 64
     e42:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <__divsf3>
	ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
     e46:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <__fixunssfsi>
     e4a:	dc 01       	movw	r26, r24
     e4c:	cb 01       	movw	r24, r22
     e4e:	a0 e0       	ldi	r26, 0x00	; 0
     e50:	b0 e0       	ldi	r27, 0x00	; 0
	ShaftCountRight = 0;
     e52:	10 92 51 05 	sts	0x0551, r1
     e56:	10 92 52 05 	sts	0x0552, r1
     e5a:	10 92 53 05 	sts	0x0553, r1
     e5e:	10 92 54 05 	sts	0x0554, r1
	ShaftCountLeft = 0;
     e62:	10 92 55 05 	sts	0x0555, r1
     e66:	10 92 56 05 	sts	0x0556, r1
     e6a:	10 92 57 05 	sts	0x0557, r1
     e6e:	10 92 58 05 	sts	0x0558, r1

	while (1)
	{
		if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
     e72:	f1 e0       	ldi	r31, 0x01	; 1
     e74:	c0 e0       	ldi	r28, 0x00	; 0
     e76:	40 91 51 05 	lds	r20, 0x0551
     e7a:	50 91 52 05 	lds	r21, 0x0552
     e7e:	60 91 53 05 	lds	r22, 0x0553
     e82:	70 91 54 05 	lds	r23, 0x0554
     e86:	00 91 55 05 	lds	r16, 0x0555
     e8a:	10 91 56 05 	lds	r17, 0x0556
     e8e:	20 91 57 05 	lds	r18, 0x0557
     e92:	30 91 58 05 	lds	r19, 0x0558
     e96:	ef 2f       	mov	r30, r31
     e98:	48 17       	cp	r20, r24
     e9a:	59 07       	cpc	r21, r25
     e9c:	6a 07       	cpc	r22, r26
     e9e:	7b 07       	cpc	r23, r27
     ea0:	08 f4       	brcc	.+2      	; 0xea4 <_Z12angle_rotatej+0x7a>
     ea2:	ec 2f       	mov	r30, r28
     ea4:	ee 23       	and	r30, r30
     ea6:	49 f4       	brne	.+18     	; 0xeba <_Z12angle_rotatej+0x90>
     ea8:	4f 2f       	mov	r20, r31
     eaa:	08 17       	cp	r16, r24
     eac:	19 07       	cpc	r17, r25
     eae:	2a 07       	cpc	r18, r26
     eb0:	3b 07       	cpc	r19, r27
     eb2:	08 f4       	brcc	.+2      	; 0xeb6 <_Z12angle_rotatej+0x8c>
     eb4:	4c 2f       	mov	r20, r28
     eb6:	44 23       	and	r20, r20
     eb8:	f1 f2       	breq	.-68     	; 0xe76 <_Z12angle_rotatej+0x4c>
		break;
	}
	stop(); //Stop robot
     eba:	0e 94 d1 06 	call	0xda2	; 0xda2 <_Z4stopv>
}
     ebe:	cf 91       	pop	r28
     ec0:	1f 91       	pop	r17
     ec2:	0f 91       	pop	r16
     ec4:	08 95       	ret

00000ec6 <_Z18linear_distance_mmj>:
void linear_distance_mm(unsigned int DistanceInMM)
{
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;

	ReqdShaftCount = DistanceInMM / 5.338; // division by resolution to get shaft count
     ec6:	bc 01       	movw	r22, r24
     ec8:	80 e0       	ldi	r24, 0x00	; 0
     eca:	90 e0       	ldi	r25, 0x00	; 0
     ecc:	0e 94 1a 10 	call	0x2034	; 0x2034 <__floatunsisf>
     ed0:	25 ee       	ldi	r18, 0xE5	; 229
     ed2:	30 ed       	ldi	r19, 0xD0	; 208
     ed4:	4a ea       	ldi	r20, 0xAA	; 170
     ed6:	50 e4       	ldi	r21, 0x40	; 64
     ed8:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <__divsf3>
	ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
     edc:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <__fixunssfsi>
     ee0:	46 2f       	mov	r20, r22
     ee2:	57 2f       	mov	r21, r23
     ee4:	68 2f       	mov	r22, r24
     ee6:	79 2f       	mov	r23, r25
	
	ShaftCountRight = 0;
     ee8:	10 92 51 05 	sts	0x0551, r1
     eec:	10 92 52 05 	sts	0x0552, r1
     ef0:	10 92 53 05 	sts	0x0553, r1
     ef4:	10 92 54 05 	sts	0x0554, r1
	while(1)
	{
		if(ShaftCountRight > ReqdShaftCountInt)
     ef8:	80 91 51 05 	lds	r24, 0x0551
     efc:	90 91 52 05 	lds	r25, 0x0552
     f00:	a0 91 53 05 	lds	r26, 0x0553
     f04:	b0 91 54 05 	lds	r27, 0x0554
     f08:	48 17       	cp	r20, r24
     f0a:	59 07       	cpc	r21, r25
     f0c:	6a 07       	cpc	r22, r26
     f0e:	7b 07       	cpc	r23, r27
     f10:	98 f7       	brcc	.-26     	; 0xef8 <_Z18linear_distance_mmj+0x32>
		{
			break;
		}
	}
	stop(); //Stop robot
     f12:	0e 94 d1 06 	call	0xda2	; 0xda2 <_Z4stopv>
}
     f16:	08 95       	ret

00000f18 <_Z10forward_mmj>:

void forward_mm(unsigned int DistanceInMM)
{
     f18:	cf 93       	push	r28
     f1a:	df 93       	push	r29
     f1c:	ec 01       	movw	r28, r24
	forward();
     f1e:	0e 94 b1 06 	call	0xd62	; 0xd62 <_Z7forwardv>
	linear_distance_mm(DistanceInMM);
     f22:	ce 01       	movw	r24, r28
     f24:	0e 94 63 07 	call	0xec6	; 0xec6 <_Z18linear_distance_mmj>
}
     f28:	df 91       	pop	r29
     f2a:	cf 91       	pop	r28
     f2c:	08 95       	ret

00000f2e <_Z7back_mmj>:

void back_mm(unsigned int DistanceInMM)
{
     f2e:	cf 93       	push	r28
     f30:	df 93       	push	r29
     f32:	ec 01       	movw	r28, r24
	back();
     f34:	0e 94 b5 06 	call	0xd6a	; 0xd6a <_Z4backv>
	linear_distance_mm(DistanceInMM);
     f38:	ce 01       	movw	r24, r28
     f3a:	0e 94 63 07 	call	0xec6	; 0xec6 <_Z18linear_distance_mmj>
}
     f3e:	df 91       	pop	r29
     f40:	cf 91       	pop	r28
     f42:	08 95       	ret

00000f44 <_Z12left_degreesj>:

void left_degrees(unsigned int Degrees)
{
     f44:	cf 93       	push	r28
     f46:	df 93       	push	r29
     f48:	ec 01       	movw	r28, r24
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	left(); //Turn left
     f4a:	0e 94 b9 06 	call	0xd72	; 0xd72 <_Z4leftv>
	angle_rotate(Degrees);
     f4e:	ce 01       	movw	r24, r28
     f50:	0e 94 15 07 	call	0xe2a	; 0xe2a <_Z12angle_rotatej>
}
     f54:	df 91       	pop	r29
     f56:	cf 91       	pop	r28
     f58:	08 95       	ret

00000f5a <_Z13right_degreesj>:



void right_degrees(unsigned int Degrees)
{
     f5a:	cf 93       	push	r28
     f5c:	df 93       	push	r29
     f5e:	ec 01       	movw	r28, r24
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	right(); //Turn right
     f60:	0e 94 bd 06 	call	0xd7a	; 0xd7a <_Z5rightv>
	angle_rotate(Degrees);
     f64:	ce 01       	movw	r24, r28
     f66:	0e 94 15 07 	call	0xe2a	; 0xe2a <_Z12angle_rotatej>
}
     f6a:	df 91       	pop	r29
     f6c:	cf 91       	pop	r28
     f6e:	08 95       	ret

00000f70 <_Z17soft_left_degreesj>:


void soft_left_degrees(unsigned int Degrees)
{
     f70:	cf 93       	push	r28
     f72:	df 93       	push	r29
     f74:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_left(); //Turn soft left
     f76:	0e 94 c1 06 	call	0xd82	; 0xd82 <_Z9soft_leftv>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     f7a:	ce 01       	movw	r24, r28
     f7c:	88 0f       	add	r24, r24
     f7e:	99 1f       	adc	r25, r25
     f80:	0e 94 15 07 	call	0xe2a	; 0xe2a <_Z12angle_rotatej>
}
     f84:	df 91       	pop	r29
     f86:	cf 91       	pop	r28
     f88:	08 95       	ret

00000f8a <_Z18soft_right_degreesj>:

void soft_right_degrees(unsigned int Degrees)
{
     f8a:	cf 93       	push	r28
     f8c:	df 93       	push	r29
     f8e:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_right();  //Turn soft right
     f90:	0e 94 c5 06 	call	0xd8a	; 0xd8a <_Z10soft_rightv>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     f94:	ce 01       	movw	r24, r28
     f96:	88 0f       	add	r24, r24
     f98:	99 1f       	adc	r25, r25
     f9a:	0e 94 15 07 	call	0xe2a	; 0xe2a <_Z12angle_rotatej>
}
     f9e:	df 91       	pop	r29
     fa0:	cf 91       	pop	r28
     fa2:	08 95       	ret

00000fa4 <_Z19soft_left_2_degreesj>:

void soft_left_2_degrees(unsigned int Degrees)
{
     fa4:	cf 93       	push	r28
     fa6:	df 93       	push	r29
     fa8:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_left_2(); //Turn reverse soft left
     faa:	0e 94 c9 06 	call	0xd92	; 0xd92 <_Z11soft_left_2v>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     fae:	ce 01       	movw	r24, r28
     fb0:	88 0f       	add	r24, r24
     fb2:	99 1f       	adc	r25, r25
     fb4:	0e 94 15 07 	call	0xe2a	; 0xe2a <_Z12angle_rotatej>
}
     fb8:	df 91       	pop	r29
     fba:	cf 91       	pop	r28
     fbc:	08 95       	ret

00000fbe <_Z20soft_right_2_degreesj>:

void soft_right_2_degrees(unsigned int Degrees)
{
     fbe:	cf 93       	push	r28
     fc0:	df 93       	push	r29
     fc2:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_right_2();  //Turn reverse soft right
     fc4:	0e 94 cd 06 	call	0xd9a	; 0xd9a <_Z12soft_right_2v>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
     fc8:	ce 01       	movw	r24, r28
     fca:	88 0f       	add	r24, r24
     fcc:	99 1f       	adc	r25, r25
     fce:	0e 94 15 07 	call	0xe2a	; 0xe2a <_Z12angle_rotatej>
}
     fd2:	df 91       	pop	r29
     fd4:	cf 91       	pop	r28
     fd6:	08 95       	ret

00000fd8 <_Z7servo_2h>:
//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
	OCR1BH = 0x00;
     fd8:	10 92 8b 00 	sts	0x008B, r1

//Function to rotate Servo 2 by a specified angle in the multiples of 1.86 degrees
void servo_2(unsigned char degrees)
{
	float PositionTiltServo = 0;
	PositionTiltServo = ((float)degrees / 1.86) + 35.0;
     fdc:	68 2f       	mov	r22, r24
     fde:	70 e0       	ldi	r23, 0x00	; 0
     fe0:	80 e0       	ldi	r24, 0x00	; 0
     fe2:	90 e0       	ldi	r25, 0x00	; 0
     fe4:	0e 94 1a 10 	call	0x2034	; 0x2034 <__floatunsisf>
     fe8:	2b e7       	ldi	r18, 0x7B	; 123
     fea:	34 e1       	ldi	r19, 0x14	; 20
     fec:	4e ee       	ldi	r20, 0xEE	; 238
     fee:	5f e3       	ldi	r21, 0x3F	; 63
     ff0:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <__divsf3>
     ff4:	20 e0       	ldi	r18, 0x00	; 0
     ff6:	30 e0       	ldi	r19, 0x00	; 0
     ff8:	4c e0       	ldi	r20, 0x0C	; 12
     ffa:	52 e4       	ldi	r21, 0x42	; 66
     ffc:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <__addsf3>
	OCR1BH = 0x00;
	OCR1BL = (unsigned char) PositionTiltServo;
    1000:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <__fixunssfsi>
    1004:	60 93 8a 00 	sts	0x008A, r22
}
    1008:	08 95       	ret

0000100a <_Z10left_countv>:
*/
void left_count()
{
	while(1)
	{
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
    100a:	82 e0       	ldi	r24, 0x02	; 2
    100c:	0e 94 13 06 	call	0xc26	; 0xc26 <_Z14ADC_Conversionh>
    1010:	80 93 33 05 	sts	0x0533, r24
		left(); //Turn left
    1014:	0e 94 b9 06 	call	0xd72	; 0xd72 <_Z4leftv>
		velocity(180,180);
    1018:	84 eb       	ldi	r24, 0xB4	; 180
    101a:	64 eb       	ldi	r22, 0xB4	; 180
    101c:	0e 94 9e 06 	call	0xd3c	; 0xd3c <_Z8velocityhh>
		if(Center_white_line>0x15)
    1020:	80 91 33 05 	lds	r24, 0x0533
    1024:	86 31       	cpi	r24, 0x16	; 22
    1026:	88 f3       	brcs	.-30     	; 0x100a <_Z10left_countv>
		return;
	}
	
}
    1028:	08 95       	ret

0000102a <_Z11timer1_initv>:
//prescale:256
// WGM: 7) PWM 10bit fast, TOP=0x03FF
// actual value: 52.25Hz 
void timer1_init(void)
{
 TCCR1B = 0x00; //stop
    102a:	e1 e8       	ldi	r30, 0x81	; 129
    102c:	f0 e0       	ldi	r31, 0x00	; 0
    102e:	10 82       	st	Z, r1
 TCNT1H = 0xFC; //Counter high value to which OCR1xH value is to be compared with
    1030:	8c ef       	ldi	r24, 0xFC	; 252
    1032:	80 93 85 00 	sts	0x0085, r24
 TCNT1L = 0x01;	//Counter low value to which OCR1xH value is to be compared with
    1036:	81 e0       	ldi	r24, 0x01	; 1
    1038:	80 93 84 00 	sts	0x0084, r24
 OCR1AH = 0x03;	//Output compare Register high value for servo 1
    103c:	93 e0       	ldi	r25, 0x03	; 3
    103e:	90 93 89 00 	sts	0x0089, r25
 OCR1AL = 0xFF;	//Output Compare Register low Value For servo 1
    1042:	8f ef       	ldi	r24, 0xFF	; 255
    1044:	80 93 88 00 	sts	0x0088, r24
 OCR1BH = 0x03;	//Output compare Register high value for servo 2
    1048:	90 93 8b 00 	sts	0x008B, r25
 OCR1BL = 0xFF;	//Output Compare Register low Value For servo 2
    104c:	80 93 8a 00 	sts	0x008A, r24
 OCR1CH = 0x03;	//Output compare Register high value for servo 3
    1050:	90 93 8d 00 	sts	0x008D, r25
 OCR1CL = 0xFF;	//Output Compare Register low Value For servo 3
    1054:	80 93 8c 00 	sts	0x008C, r24
 ICR1H  = 0x03;	
    1058:	90 93 87 00 	sts	0x0087, r25
 ICR1L  = 0xFF;
    105c:	80 93 86 00 	sts	0x0086, r24
 TCCR1A = 0xAB; /*{COM1A1=1, COM1A0=0; COM1B1=1, COM1B0=0; COM1C1=1 COM1C0=0}
    1060:	8b ea       	ldi	r24, 0xAB	; 171
    1062:	80 93 80 00 	sts	0x0080, r24
 					For Overriding normal port functionality to OCRnA outputs.
				  {WGM11=1, WGM10=1} Along With WGM12 in TCCR1B for Selecting FAST PWM Mode*/
 TCCR1C = 0x00;
    1066:	10 92 82 00 	sts	0x0082, r1
 TCCR1B = 0x0C; //WGM12=1; CS12=1, CS11=0, CS10=0 (Prescaler=256)
    106a:	8c e0       	ldi	r24, 0x0C	; 12
    106c:	80 83       	st	Z, r24
}
    106e:	08 95       	ret

00001070 <_Z7servo_1h>:
//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
	OCR1AH = 0x00;
    1070:	10 92 89 00 	sts	0x0089, r1

//Function to rotate Servo 1 by a specified angle in the multiples of 1.86 degrees
void servo_1(unsigned char degrees)
{
	float PositionPanServo = 0;
	PositionPanServo = ((float)degrees / 1.86) + 35.0;
    1074:	68 2f       	mov	r22, r24
    1076:	70 e0       	ldi	r23, 0x00	; 0
    1078:	80 e0       	ldi	r24, 0x00	; 0
    107a:	90 e0       	ldi	r25, 0x00	; 0
    107c:	0e 94 1a 10 	call	0x2034	; 0x2034 <__floatunsisf>
    1080:	2b e7       	ldi	r18, 0x7B	; 123
    1082:	34 e1       	ldi	r19, 0x14	; 20
    1084:	4e ee       	ldi	r20, 0xEE	; 238
    1086:	5f e3       	ldi	r21, 0x3F	; 63
    1088:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <__divsf3>
    108c:	20 e0       	ldi	r18, 0x00	; 0
    108e:	30 e0       	ldi	r19, 0x00	; 0
    1090:	4c e0       	ldi	r20, 0x0C	; 12
    1092:	52 e4       	ldi	r21, 0x42	; 66
    1094:	0e 94 1d 0f 	call	0x1e3a	; 0x1e3a <__addsf3>
	OCR1AH = 0x00;
	OCR1AL = (unsigned char) PositionPanServo;
    1098:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <__fixunssfsi>
    109c:	60 93 88 00 	sts	0x0088, r22
}
    10a0:	08 95       	ret

000010a2 <_Z12servo_1_restv>:
Logic:		  -
Example Call: servo_1_rest();
*/
void servo_1_rest (void) //makes servo 1 free rotating
{
	servo_1(90);
    10a2:	8a e5       	ldi	r24, 0x5A	; 90
    10a4:	0e 94 38 08 	call	0x1070	; 0x1070 <_Z7servo_1h>
}
    10a8:	08 95       	ret

000010aa <_Z12servo_2_restv>:
Logic:		  -
Example Call: servo_2_rest();
*/
void servo_2_rest (void) //makes servo 1 free rotating
{
	servo_2(0);
    10aa:	80 e0       	ldi	r24, 0x00	; 0
    10ac:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <_Z7servo_2h>
}
    10b0:	08 95       	ret

000010b2 <_Z12servo_1_freev>:
//and make them free by giving 100% duty cycle at the PWM. This function can be used to
//reduce the power consumption of the motor if it is holding load against the gravity.

void servo_1_free (void) //makes servo 1 free rotating
{
	OCR1AH = 0x03;
    10b2:	83 e0       	ldi	r24, 0x03	; 3
    10b4:	80 93 89 00 	sts	0x0089, r24
	OCR1AL = 0xFF; //Servo 1 off
    10b8:	8f ef       	ldi	r24, 0xFF	; 255
    10ba:	80 93 88 00 	sts	0x0088, r24
}
    10be:	08 95       	ret

000010c0 <_Z3IDRv>:
Output :      none
Logic:		  it moves the debris in clearing zone and idenfies the color of survivor beneath
Example Call: servo_1_rest();
*/
void IDR(void)				//identification routine
{
    10c0:	cf 93       	push	r28
	stop();
    10c2:	0e 94 d1 06 	call	0xda2	; 0xda2 <_Z4stopv>
	servo_1(40);
    10c6:	88 e2       	ldi	r24, 0x28	; 40
    10c8:	0e 94 38 08 	call	0x1070	; 0x1070 <_Z7servo_1h>
    10cc:	c8 e2       	ldi	r28, 0x28	; 40
	int x=40;
	for(int j=x;j<=95;j++){
		servo_1(j);
    10ce:	8c 2f       	mov	r24, r28
    10d0:	0e 94 38 08 	call	0x1070	; 0x1070 <_Z7servo_1h>
    10d4:	8f ef       	ldi	r24, 0xFF	; 255
    10d6:	9f e3       	ldi	r25, 0x3F	; 63
    10d8:	a2 e0       	ldi	r26, 0x02	; 2
    10da:	81 50       	subi	r24, 0x01	; 1
    10dc:	90 40       	sbci	r25, 0x00	; 0
    10de:	a0 40       	sbci	r26, 0x00	; 0
    10e0:	e1 f7       	brne	.-8      	; 0x10da <_Z3IDRv+0x1a>
    10e2:	00 c0       	rjmp	.+0      	; 0x10e4 <_Z3IDRv+0x24>
    10e4:	00 00       	nop
    10e6:	cf 5f       	subi	r28, 0xFF	; 255
void IDR(void)				//identification routine
{
	stop();
	servo_1(40);
	int x=40;
	for(int j=x;j<=95;j++){
    10e8:	c0 36       	cpi	r28, 0x60	; 96
    10ea:	89 f7       	brne	.-30     	; 0x10ce <_Z3IDRv+0xe>
		servo_1(j);
		_delay_ms(50);
		
	}
	if(angle2==0)
    10ec:	80 91 37 05 	lds	r24, 0x0537
    10f0:	90 91 38 05 	lds	r25, 0x0538
    10f4:	00 97       	sbiw	r24, 0x00	; 0
    10f6:	21 f4       	brne	.+8      	; 0x1100 <_Z3IDRv+0x40>
	servo_1(85);
    10f8:	85 e5       	ldi	r24, 0x55	; 85
    10fa:	0e 94 38 08 	call	0x1070	; 0x1070 <_Z7servo_1h>
    10fe:	03 c0       	rjmp	.+6      	; 0x1106 <_Z3IDRv+0x46>
	else servo_1(90);
    1100:	8a e5       	ldi	r24, 0x5A	; 90
    1102:	0e 94 38 08 	call	0x1070	; 0x1070 <_Z7servo_1h>
    1106:	8f ef       	ldi	r24, 0xFF	; 255
    1108:	9f e7       	ldi	r25, 0x7F	; 127
    110a:	a4 e0       	ldi	r26, 0x04	; 4
    110c:	81 50       	subi	r24, 0x01	; 1
    110e:	90 40       	sbci	r25, 0x00	; 0
    1110:	a0 40       	sbci	r26, 0x00	; 0
    1112:	e1 f7       	brne	.-8      	; 0x110c <_Z3IDRv+0x4c>
    1114:	00 c0       	rjmp	.+0      	; 0x1116 <_Z3IDRv+0x56>
    1116:	00 00       	nop
	_delay_ms(100);
	color();
    1118:	0e 94 8b 04 	call	0x916	; 0x916 <_Z5colorv>
	if(angle2==0)
    111c:	80 91 37 05 	lds	r24, 0x0537
    1120:	90 91 38 05 	lds	r25, 0x0538
    1124:	00 97       	sbiw	r24, 0x00	; 0
    1126:	49 f4       	brne	.+18     	; 0x113a <_Z3IDRv+0x7a>
	color1=data;
    1128:	80 91 6d 05 	lds	r24, 0x056D
    112c:	90 91 6e 05 	lds	r25, 0x056E
    1130:	90 93 3e 05 	sts	0x053E, r25
    1134:	80 93 3d 05 	sts	0x053D, r24
    1138:	08 c0       	rjmp	.+16     	; 0x114a <_Z3IDRv+0x8a>
	else color2=data;
    113a:	80 91 6d 05 	lds	r24, 0x056D
    113e:	90 91 6e 05 	lds	r25, 0x056E
    1142:	90 93 3c 05 	sts	0x053C, r25
    1146:	80 93 3b 05 	sts	0x053B, r24
	if(data==92)			//color of patch is red
    114a:	80 91 6d 05 	lds	r24, 0x056D
    114e:	90 91 6e 05 	lds	r25, 0x056E
    1152:	8c 35       	cpi	r24, 0x5C	; 92
    1154:	91 05       	cpc	r25, r1
    1156:	19 f4       	brne	.+6      	; 0x115e <_Z3IDRv+0x9e>
	{
		red_on();
    1158:	0e 94 69 05 	call	0xad2	; 0xad2 <_Z6red_onv>
    115c:	05 c0       	rjmp	.+10     	; 0x1168 <_Z3IDRv+0xa8>
		
	}
	else if(data==93)			//color of patch is green
    115e:	8d 35       	cpi	r24, 0x5D	; 93
    1160:	91 05       	cpc	r25, r1
    1162:	11 f4       	brne	.+4      	; 0x1168 <_Z3IDRv+0xa8>
	{
		green_on();
    1164:	0e 94 74 05 	call	0xae8	; 0xae8 <_Z8green_onv>
    1168:	8f ef       	ldi	r24, 0xFF	; 255
    116a:	9f ef       	ldi	r25, 0xFF	; 255
    116c:	a9 e5       	ldi	r26, 0x59	; 89
    116e:	81 50       	subi	r24, 0x01	; 1
    1170:	90 40       	sbci	r25, 0x00	; 0
    1172:	a0 40       	sbci	r26, 0x00	; 0
    1174:	e1 f7       	brne	.-8      	; 0x116e <_Z3IDRv+0xae>
    1176:	00 c0       	rjmp	.+0      	; 0x1178 <_Z3IDRv+0xb8>
    1178:	00 00       	nop
		
	}
	_delay_ms(2000);
	led_off();
    117a:	0e 94 6d 05 	call	0xada	; 0xada <_Z7led_offv>
	servo_1_rest();
    117e:	0e 94 51 08 	call	0x10a2	; 0x10a2 <_Z12servo_1_restv>
    1182:	8f ef       	ldi	r24, 0xFF	; 255
    1184:	9f ef       	ldi	r25, 0xFF	; 255
    1186:	a9 e5       	ldi	r26, 0x59	; 89
    1188:	81 50       	subi	r24, 0x01	; 1
    118a:	90 40       	sbci	r25, 0x00	; 0
    118c:	a0 40       	sbci	r26, 0x00	; 0
    118e:	e1 f7       	brne	.-8      	; 0x1188 <_Z3IDRv+0xc8>
    1190:	00 c0       	rjmp	.+0      	; 0x1192 <_Z3IDRv+0xd2>
    1192:	00 00       	nop
	_delay_ms(2000);
}
    1194:	cf 91       	pop	r28
    1196:	08 95       	ret

00001198 <_Z17left_angle_rotatej>:

//Function used for turning robot by specified degrees
void left_angle_rotate(unsigned int Degrees)
{
    1198:	cf 92       	push	r12
    119a:	df 92       	push	r13
    119c:	ef 92       	push	r14
    119e:	ff 92       	push	r15
    11a0:	cf 93       	push	r28
    11a2:	df 93       	push	r29
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;

	ReqdShaftCount = (float) Degrees/ 4.090; // division by resolution to get shaft count
    11a4:	bc 01       	movw	r22, r24
    11a6:	80 e0       	ldi	r24, 0x00	; 0
    11a8:	90 e0       	ldi	r25, 0x00	; 0
    11aa:	0e 94 1a 10 	call	0x2034	; 0x2034 <__floatunsisf>
    11ae:	28 e4       	ldi	r18, 0x48	; 72
    11b0:	31 ee       	ldi	r19, 0xE1	; 225
    11b2:	42 e8       	ldi	r20, 0x82	; 130
    11b4:	50 e4       	ldi	r21, 0x40	; 64
    11b6:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <__divsf3>
	ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
    11ba:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <__fixunssfsi>
    11be:	6b 01       	movw	r12, r22
    11c0:	ee 24       	eor	r14, r14
    11c2:	ff 24       	eor	r15, r15
	ShaftCountRight = 0;
    11c4:	10 92 51 05 	sts	0x0551, r1
    11c8:	10 92 52 05 	sts	0x0552, r1
    11cc:	10 92 53 05 	sts	0x0553, r1
    11d0:	10 92 54 05 	sts	0x0554, r1
	ShaftCountLeft = 0;
    11d4:	10 92 55 05 	sts	0x0555, r1
    11d8:	10 92 56 05 	sts	0x0556, r1
    11dc:	10 92 57 05 	sts	0x0557, r1
    11e0:	10 92 58 05 	sts	0x0558, r1
			break;
		}
		left(); //Turn right
		velocity(200,200);
		
		if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
    11e4:	c1 e0       	ldi	r28, 0x01	; 1
    11e6:	d0 e0       	ldi	r29, 0x00	; 0
	
	while (1)
	{
		//Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
		//print_sensor(1,1,2);
		sharp = ADC_Conversion(11);						//Stores the Analog value of front sharp connected to ADC channel 11 into variable "sharp"
    11e8:	8b e0       	ldi	r24, 0x0B	; 11
    11ea:	0e 94 13 06 	call	0xc26	; 0xc26 <_Z14ADC_Conversionh>
    11ee:	80 93 4e 05 	sts	0x054E, r24
		value = Sharp_GP2D12_estimation(sharp);				//Stores Distance calculated in a variable "value".
    11f2:	0e 94 d5 06 	call	0xdaa	; 0xdaa <_Z23Sharp_GP2D12_estimationh>
    11f6:	90 93 4d 05 	sts	0x054D, r25
    11fa:	80 93 4c 05 	sts	0x054C, r24
		//lcd_print(1,1,value,3); 						//Prints Value Of Distanc in MM measured by Sharp Sensor.
		if(value>90 && value<150)
    11fe:	8b 55       	subi	r24, 0x5B	; 91
    1200:	90 40       	sbci	r25, 0x00	; 0
    1202:	8b 33       	cpi	r24, 0x3B	; 59
    1204:	91 05       	cpc	r25, r1
    1206:	68 f4       	brcc	.+26     	; 0x1222 <_Z17left_angle_rotatej+0x8a>
		{
			stop();
    1208:	0e 94 d1 06 	call	0xda2	; 0xda2 <_Z4stopv>
			angle2=102;
    120c:	86 e6       	ldi	r24, 0x66	; 102
    120e:	90 e0       	ldi	r25, 0x00	; 0
    1210:	90 93 38 05 	sts	0x0538, r25
    1214:	80 93 37 05 	sts	0x0537, r24
			IDR();
    1218:	0e 94 60 08 	call	0x10c0	; 0x10c0 <_Z3IDRv>
			stop();
    121c:	0e 94 d1 06 	call	0xda2	; 0xda2 <_Z4stopv>
			break;
    1220:	45 c0       	rjmp	.+138    	; 0x12ac <_Z17left_angle_rotatej+0x114>
		}
		left(); //Turn right
    1222:	0e 94 b9 06 	call	0xd72	; 0xd72 <_Z4leftv>
		velocity(200,200);
    1226:	88 ec       	ldi	r24, 0xC8	; 200
    1228:	68 ec       	ldi	r22, 0xC8	; 200
    122a:	0e 94 9e 06 	call	0xd3c	; 0xd3c <_Z8velocityhh>
		
		if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
    122e:	80 91 51 05 	lds	r24, 0x0551
    1232:	90 91 52 05 	lds	r25, 0x0552
    1236:	a0 91 53 05 	lds	r26, 0x0553
    123a:	b0 91 54 05 	lds	r27, 0x0554
    123e:	40 91 55 05 	lds	r20, 0x0555
    1242:	50 91 56 05 	lds	r21, 0x0556
    1246:	60 91 57 05 	lds	r22, 0x0557
    124a:	70 91 58 05 	lds	r23, 0x0558
    124e:	2c 2f       	mov	r18, r28
    1250:	8c 15       	cp	r24, r12
    1252:	9d 05       	cpc	r25, r13
    1254:	ae 05       	cpc	r26, r14
    1256:	bf 05       	cpc	r27, r15
    1258:	08 f4       	brcc	.+2      	; 0x125c <_Z17left_angle_rotatej+0xc4>
    125a:	2d 2f       	mov	r18, r29
    125c:	22 23       	and	r18, r18
    125e:	51 f4       	brne	.+20     	; 0x1274 <_Z17left_angle_rotatej+0xdc>
    1260:	8c 2f       	mov	r24, r28
    1262:	4c 15       	cp	r20, r12
    1264:	5d 05       	cpc	r21, r13
    1266:	6e 05       	cpc	r22, r14
    1268:	7f 05       	cpc	r23, r15
    126a:	08 f4       	brcc	.+2      	; 0x126e <_Z17left_angle_rotatej+0xd6>
    126c:	8d 2f       	mov	r24, r29
    126e:	88 23       	and	r24, r24
    1270:	09 f4       	brne	.+2      	; 0x1274 <_Z17left_angle_rotatej+0xdc>
    1272:	ba cf       	rjmp	.-140    	; 0x11e8 <_Z17left_angle_rotatej+0x50>
		{
			stop();
    1274:	0e 94 d1 06 	call	0xda2	; 0xda2 <_Z4stopv>
			blue_on();
    1278:	0e 94 70 05 	call	0xae0	; 0xae0 <_Z7blue_onv>
			buzzer_on();
    127c:	0e 94 a9 06 	call	0xd52	; 0xd52 <_Z9buzzer_onv>
    1280:	8f ef       	ldi	r24, 0xFF	; 255
    1282:	9f ef       	ldi	r25, 0xFF	; 255
    1284:	a9 e5       	ldi	r26, 0x59	; 89
    1286:	81 50       	subi	r24, 0x01	; 1
    1288:	90 40       	sbci	r25, 0x00	; 0
    128a:	a0 40       	sbci	r26, 0x00	; 0
    128c:	e1 f7       	brne	.-8      	; 0x1286 <_Z17left_angle_rotatej+0xee>
    128e:	00 c0       	rjmp	.+0      	; 0x1290 <_Z17left_angle_rotatej+0xf8>
    1290:	00 00       	nop
			_delay_ms(2000);
			buzzer_off();
    1292:	0e 94 ad 06 	call	0xd5a	; 0xd5a <_Z10buzzer_offv>
			led_off();
    1296:	0e 94 6d 05 	call	0xada	; 0xada <_Z7led_offv>
			j=j+1;
    129a:	80 91 69 05 	lds	r24, 0x0569
    129e:	90 91 6a 05 	lds	r25, 0x056A
    12a2:	01 96       	adiw	r24, 0x01	; 1
    12a4:	90 93 6a 05 	sts	0x056A, r25
    12a8:	80 93 69 05 	sts	0x0569, r24
			break;
		}
		
	}
	stop(); //Stop robot
    12ac:	0e 94 d1 06 	call	0xda2	; 0xda2 <_Z4stopv>
}
    12b0:	df 91       	pop	r29
    12b2:	cf 91       	pop	r28
    12b4:	ff 90       	pop	r15
    12b6:	ef 90       	pop	r14
    12b8:	df 90       	pop	r13
    12ba:	cf 90       	pop	r12
    12bc:	08 95       	ret

000012be <_Z18right_angle_rotatej>:
//Function used for turning robot by specified degrees
void right_angle_rotate(unsigned int Degrees)
{
    12be:	cf 92       	push	r12
    12c0:	df 92       	push	r13
    12c2:	ef 92       	push	r14
    12c4:	ff 92       	push	r15
    12c6:	cf 93       	push	r28
    12c8:	df 93       	push	r29
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;

	ReqdShaftCount = (float) Degrees/ 4.090; // division by resolution to get shaft count
    12ca:	bc 01       	movw	r22, r24
    12cc:	80 e0       	ldi	r24, 0x00	; 0
    12ce:	90 e0       	ldi	r25, 0x00	; 0
    12d0:	0e 94 1a 10 	call	0x2034	; 0x2034 <__floatunsisf>
    12d4:	28 e4       	ldi	r18, 0x48	; 72
    12d6:	31 ee       	ldi	r19, 0xE1	; 225
    12d8:	42 e8       	ldi	r20, 0x82	; 130
    12da:	50 e4       	ldi	r21, 0x40	; 64
    12dc:	0e 94 81 0f 	call	0x1f02	; 0x1f02 <__divsf3>
	ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
    12e0:	0e 94 ee 0f 	call	0x1fdc	; 0x1fdc <__fixunssfsi>
    12e4:	6b 01       	movw	r12, r22
    12e6:	ee 24       	eor	r14, r14
    12e8:	ff 24       	eor	r15, r15
	ShaftCountRight = 0;
    12ea:	10 92 51 05 	sts	0x0551, r1
    12ee:	10 92 52 05 	sts	0x0552, r1
    12f2:	10 92 53 05 	sts	0x0553, r1
    12f6:	10 92 54 05 	sts	0x0554, r1
	ShaftCountLeft = 0;
    12fa:	10 92 55 05 	sts	0x0555, r1
    12fe:	10 92 56 05 	sts	0x0556, r1
    1302:	10 92 57 05 	sts	0x0557, r1
    1306:	10 92 58 05 	sts	0x0558, r1
			stop();
			break;
		}
		right(); //Turn right
		velocity(200,200);
		if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
    130a:	c1 e0       	ldi	r28, 0x01	; 1
    130c:	d0 e0       	ldi	r29, 0x00	; 0
	
	while (1)
	{
		//Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
		//print_sensor(1,1,2);
		sharp = ADC_Conversion(11);						//Stores the Analog value of front sharp connected to ADC channel 11 into variable "sharp"
    130e:	8b e0       	ldi	r24, 0x0B	; 11
    1310:	0e 94 13 06 	call	0xc26	; 0xc26 <_Z14ADC_Conversionh>
    1314:	80 93 4e 05 	sts	0x054E, r24
		value = Sharp_GP2D12_estimation(sharp);				//Stores Distance calsulated in a variable "value".
    1318:	0e 94 d5 06 	call	0xdaa	; 0xdaa <_Z23Sharp_GP2D12_estimationh>
    131c:	90 93 4d 05 	sts	0x054D, r25
    1320:	80 93 4c 05 	sts	0x054C, r24
		//lcd_print(1,1,value,3); 						//Prints Value Of Distanc in MM measured by Sharp Sensor.
		if(value>90 && value<120)
    1324:	8b 55       	subi	r24, 0x5B	; 91
    1326:	90 40       	sbci	r25, 0x00	; 0
    1328:	8d 31       	cpi	r24, 0x1D	; 29
    132a:	91 05       	cpc	r25, r1
    132c:	58 f4       	brcc	.+22     	; 0x1344 <_Z18right_angle_rotatej+0x86>
		{
			angle1=101;
    132e:	85 e6       	ldi	r24, 0x65	; 101
    1330:	90 e0       	ldi	r25, 0x00	; 0
    1332:	90 93 3a 05 	sts	0x053A, r25
    1336:	80 93 39 05 	sts	0x0539, r24
			
			//lcd_print(1,1,data,3);
			
			//UDR0=data;
			IDR();
    133a:	0e 94 60 08 	call	0x10c0	; 0x10c0 <_Z3IDRv>
			stop();
    133e:	0e 94 d1 06 	call	0xda2	; 0xda2 <_Z4stopv>
			break;
    1342:	4e c0       	rjmp	.+156    	; 0x13e0 <_Z18right_angle_rotatej+0x122>
		}
		right(); //Turn right
    1344:	0e 94 bd 06 	call	0xd7a	; 0xd7a <_Z5rightv>
		velocity(200,200);
    1348:	88 ec       	ldi	r24, 0xC8	; 200
    134a:	68 ec       	ldi	r22, 0xC8	; 200
    134c:	0e 94 9e 06 	call	0xd3c	; 0xd3c <_Z8velocityhh>
		if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
    1350:	80 91 51 05 	lds	r24, 0x0551
    1354:	90 91 52 05 	lds	r25, 0x0552
    1358:	a0 91 53 05 	lds	r26, 0x0553
    135c:	b0 91 54 05 	lds	r27, 0x0554
    1360:	40 91 55 05 	lds	r20, 0x0555
    1364:	50 91 56 05 	lds	r21, 0x0556
    1368:	60 91 57 05 	lds	r22, 0x0557
    136c:	70 91 58 05 	lds	r23, 0x0558
    1370:	2c 2f       	mov	r18, r28
    1372:	8c 15       	cp	r24, r12
    1374:	9d 05       	cpc	r25, r13
    1376:	ae 05       	cpc	r26, r14
    1378:	bf 05       	cpc	r27, r15
    137a:	08 f4       	brcc	.+2      	; 0x137e <_Z18right_angle_rotatej+0xc0>
    137c:	2d 2f       	mov	r18, r29
    137e:	22 23       	and	r18, r18
    1380:	51 f4       	brne	.+20     	; 0x1396 <_Z18right_angle_rotatej+0xd8>
    1382:	8c 2f       	mov	r24, r28
    1384:	4c 15       	cp	r20, r12
    1386:	5d 05       	cpc	r21, r13
    1388:	6e 05       	cpc	r22, r14
    138a:	7f 05       	cpc	r23, r15
    138c:	08 f4       	brcc	.+2      	; 0x1390 <_Z18right_angle_rotatej+0xd2>
    138e:	8d 2f       	mov	r24, r29
    1390:	88 23       	and	r24, r24
    1392:	09 f4       	brne	.+2      	; 0x1396 <_Z18right_angle_rotatej+0xd8>
    1394:	bc cf       	rjmp	.-136    	; 0x130e <_Z18right_angle_rotatej+0x50>
		{
			stop();
    1396:	0e 94 d1 06 	call	0xda2	; 0xda2 <_Z4stopv>
    139a:	8f ef       	ldi	r24, 0xFF	; 255
    139c:	9f ef       	ldi	r25, 0xFF	; 255
    139e:	ac e2       	ldi	r26, 0x2C	; 44
    13a0:	81 50       	subi	r24, 0x01	; 1
    13a2:	90 40       	sbci	r25, 0x00	; 0
    13a4:	a0 40       	sbci	r26, 0x00	; 0
    13a6:	e1 f7       	brne	.-8      	; 0x13a0 <_Z18right_angle_rotatej+0xe2>
    13a8:	00 c0       	rjmp	.+0      	; 0x13aa <_Z18right_angle_rotatej+0xec>
    13aa:	00 00       	nop
			_delay_ms(1000);
			blue_on();
    13ac:	0e 94 70 05 	call	0xae0	; 0xae0 <_Z7blue_onv>
			buzzer_on();
    13b0:	0e 94 a9 06 	call	0xd52	; 0xd52 <_Z9buzzer_onv>
    13b4:	8f ef       	ldi	r24, 0xFF	; 255
    13b6:	9f ef       	ldi	r25, 0xFF	; 255
    13b8:	a9 e5       	ldi	r26, 0x59	; 89
    13ba:	81 50       	subi	r24, 0x01	; 1
    13bc:	90 40       	sbci	r25, 0x00	; 0
    13be:	a0 40       	sbci	r26, 0x00	; 0
    13c0:	e1 f7       	brne	.-8      	; 0x13ba <_Z18right_angle_rotatej+0xfc>
    13c2:	00 c0       	rjmp	.+0      	; 0x13c4 <_Z18right_angle_rotatej+0x106>
    13c4:	00 00       	nop
			_delay_ms(2000);
			buzzer_off();
    13c6:	0e 94 ad 06 	call	0xd5a	; 0xd5a <_Z10buzzer_offv>
			led_off();
    13ca:	0e 94 6d 05 	call	0xada	; 0xada <_Z7led_offv>
			j=j+1;
    13ce:	80 91 69 05 	lds	r24, 0x0569
    13d2:	90 91 6a 05 	lds	r25, 0x056A
    13d6:	01 96       	adiw	r24, 0x01	; 1
    13d8:	90 93 6a 05 	sts	0x056A, r25
    13dc:	80 93 69 05 	sts	0x0569, r24
			break;	
		}
		
	}
	stop(); //Stop robot
    13e0:	0e 94 d1 06 	call	0xda2	; 0xda2 <_Z4stopv>
}
    13e4:	df 91       	pop	r29
    13e6:	cf 91       	pop	r28
    13e8:	ff 90       	pop	r15
    13ea:	ef 90       	pop	r14
    13ec:	df 90       	pop	r13
    13ee:	cf 90       	pop	r12
    13f0:	08 95       	ret

000013f2 <_Z11right_countv>:
void right_count()
{
	int flag=1;
	while(1)
	{
		Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
    13f2:	82 e0       	ldi	r24, 0x02	; 2
    13f4:	0e 94 13 06 	call	0xc26	; 0xc26 <_Z14ADC_Conversionh>
    13f8:	80 93 33 05 	sts	0x0533, r24
		//print_sensor(1,1,2);
		
		right(); //Turn right
    13fc:	0e 94 bd 06 	call	0xd7a	; 0xd7a <_Z5rightv>
		velocity(180,180);
    1400:	84 eb       	ldi	r24, 0xB4	; 180
    1402:	64 eb       	ldi	r22, 0xB4	; 180
    1404:	0e 94 9e 06 	call	0xd3c	; 0xd3c <_Z8velocityhh>
		if(Center_white_line>0x15)
    1408:	80 91 33 05 	lds	r24, 0x0533
    140c:	86 31       	cpi	r24, 0x16	; 22
    140e:	88 f3       	brcs	.-30     	; 0x13f2 <_Z11right_countv>
		return;
	}
	
}
    1410:	08 95       	ret

00001412 <_Z5alignv>:
Logic:		  bot looks for black line while turning right and stops as soon as it identifies the black line and do this for other direction as well
Example Call: align();
*/
int align()
{
		velocity(180,180);
    1412:	84 eb       	ldi	r24, 0xB4	; 180
    1414:	64 eb       	ldi	r22, 0xB4	; 180
    1416:	0e 94 9e 06 	call	0xd3c	; 0xd3c <_Z8velocityhh>
		right_degrees(15);
    141a:	8f e0       	ldi	r24, 0x0F	; 15
    141c:	90 e0       	ldi	r25, 0x00	; 0
    141e:	0e 94 ad 07 	call	0xf5a	; 0xf5a <_Z13right_degreesj>
		left_count();
    1422:	0e 94 05 08 	call	0x100a	; 0x100a <_Z10left_countv>
		velocity(180,180);
    1426:	84 eb       	ldi	r24, 0xB4	; 180
    1428:	64 eb       	ldi	r22, 0xB4	; 180
    142a:	0e 94 9e 06 	call	0xd3c	; 0xd3c <_Z8velocityhh>
		left_degrees(15);
    142e:	8f e0       	ldi	r24, 0x0F	; 15
    1430:	90 e0       	ldi	r25, 0x00	; 0
    1432:	0e 94 a2 07 	call	0xf44	; 0xf44 <_Z12left_degreesj>
		right_count();
    1436:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <_Z11right_countv>
	
	
}
    143a:	08 95       	ret

0000143c <_Z8nextdestv>:
int nextdest()
{
	int pos=0;
	for(int i=0;i<17;i++)
	{
		if(search[i]==1)
    143c:	80 91 80 02 	lds	r24, 0x0280
    1440:	90 91 81 02 	lds	r25, 0x0281
    1444:	81 30       	cpi	r24, 0x01	; 1
    1446:	91 05       	cpc	r25, r1
    1448:	e1 f0       	breq	.+56     	; 0x1482 <_Z8nextdestv+0x46>
		{
			pos=i;
			break;
		}	
		if(search[i]==2)
    144a:	82 30       	cpi	r24, 0x02	; 2
    144c:	91 05       	cpc	r25, r1
    144e:	61 f0       	breq	.+24     	; 0x1468 <_Z8nextdestv+0x2c>
    1450:	e2 e8       	ldi	r30, 0x82	; 130
    1452:	f2 e0       	ldi	r31, 0x02	; 2
Example: dest=nextdest();
*/
int nextdest()
{
	int pos=0;
	for(int i=0;i<17;i++)
    1454:	21 e0       	ldi	r18, 0x01	; 1
    1456:	30 e0       	ldi	r19, 0x00	; 0
	{
		if(search[i]==1)
    1458:	81 91       	ld	r24, Z+
    145a:	91 91       	ld	r25, Z+
    145c:	81 30       	cpi	r24, 0x01	; 1
    145e:	91 05       	cpc	r25, r1
    1460:	91 f0       	breq	.+36     	; 0x1486 <_Z8nextdestv+0x4a>
		{
			pos=i;
			break;
		}	
		if(search[i]==2)
    1462:	82 30       	cpi	r24, 0x02	; 2
    1464:	91 05       	cpc	r25, r1
    1466:	29 f4       	brne	.+10     	; 0x1472 <_Z8nextdestv+0x36>
		{
			stop();
    1468:	0e 94 d1 06 	call	0xda2	; 0xda2 <_Z4stopv>
			return 49;
    146c:	81 e3       	ldi	r24, 0x31	; 49
    146e:	90 e0       	ldi	r25, 0x00	; 0
    1470:	08 95       	ret
Example: dest=nextdest();
*/
int nextdest()
{
	int pos=0;
	for(int i=0;i<17;i++)
    1472:	2f 5f       	subi	r18, 0xFF	; 255
    1474:	3f 4f       	sbci	r19, 0xFF	; 255
    1476:	21 31       	cpi	r18, 0x11	; 17
    1478:	31 05       	cpc	r19, r1
    147a:	71 f7       	brne	.-36     	; 0x1458 <_Z8nextdestv+0x1c>
Logic:		  it marks out the nodes currently searched and finds the next one to look for
Example: dest=nextdest();
*/
int nextdest()
{
	int pos=0;
    147c:	20 e0       	ldi	r18, 0x00	; 0
    147e:	30 e0       	ldi	r19, 0x00	; 0
    1480:	02 c0       	rjmp	.+4      	; 0x1486 <_Z8nextdestv+0x4a>
	for(int i=0;i<17;i++)
    1482:	20 e0       	ldi	r18, 0x00	; 0
    1484:	30 e0       	ldi	r19, 0x00	; 0
			break;
		}
	}
	for(int j=0;j<4;j++)
	{
		if(val[pos][j]!=0)
    1486:	f9 01       	movw	r30, r18
    1488:	ee 0f       	add	r30, r30
    148a:	ff 1f       	adc	r31, r31
    148c:	ee 0f       	add	r30, r30
    148e:	ff 1f       	adc	r31, r31
    1490:	ee 0f       	add	r30, r30
    1492:	ff 1f       	adc	r31, r31
    1494:	e0 50       	subi	r30, 0x00	; 0
    1496:	fe 4f       	sbci	r31, 0xFE	; 254
    1498:	80 81       	ld	r24, Z
    149a:	91 81       	ldd	r25, Z+1	; 0x01
    149c:	00 97       	sbiw	r24, 0x00	; 0
    149e:	81 f5       	brne	.+96     	; 0x1500 <_Z8nextdestv+0xc4>
    14a0:	f9 01       	movw	r30, r18
    14a2:	ee 0f       	add	r30, r30
    14a4:	ff 1f       	adc	r31, r31
    14a6:	ee 0f       	add	r30, r30
    14a8:	ff 1f       	adc	r31, r31
    14aa:	ee 0f       	add	r30, r30
    14ac:	ff 1f       	adc	r31, r31
    14ae:	e0 50       	subi	r30, 0x00	; 0
    14b0:	fe 4f       	sbci	r31, 0xFE	; 254
    14b2:	82 81       	ldd	r24, Z+2	; 0x02
    14b4:	93 81       	ldd	r25, Z+3	; 0x03
    14b6:	00 97       	sbiw	r24, 0x00	; 0
    14b8:	19 f5       	brne	.+70     	; 0x1500 <_Z8nextdestv+0xc4>
    14ba:	f9 01       	movw	r30, r18
    14bc:	ee 0f       	add	r30, r30
    14be:	ff 1f       	adc	r31, r31
    14c0:	ee 0f       	add	r30, r30
    14c2:	ff 1f       	adc	r31, r31
    14c4:	ee 0f       	add	r30, r30
    14c6:	ff 1f       	adc	r31, r31
    14c8:	e0 50       	subi	r30, 0x00	; 0
    14ca:	fe 4f       	sbci	r31, 0xFE	; 254
    14cc:	84 81       	ldd	r24, Z+4	; 0x04
    14ce:	95 81       	ldd	r25, Z+5	; 0x05
    14d0:	00 97       	sbiw	r24, 0x00	; 0
    14d2:	b1 f4       	brne	.+44     	; 0x1500 <_Z8nextdestv+0xc4>
    14d4:	f9 01       	movw	r30, r18
    14d6:	ee 0f       	add	r30, r30
    14d8:	ff 1f       	adc	r31, r31
    14da:	ee 0f       	add	r30, r30
    14dc:	ff 1f       	adc	r31, r31
    14de:	ee 0f       	add	r30, r30
    14e0:	ff 1f       	adc	r31, r31
    14e2:	e0 50       	subi	r30, 0x00	; 0
    14e4:	fe 4f       	sbci	r31, 0xFE	; 254
    14e6:	86 81       	ldd	r24, Z+6	; 0x06
    14e8:	97 81       	ldd	r25, Z+7	; 0x07
    14ea:	00 97       	sbiw	r24, 0x00	; 0
    14ec:	49 f4       	brne	.+18     	; 0x1500 <_Z8nextdestv+0xc4>
		{
			return val[pos][j];
		}
	}
	search[pos]=0;
    14ee:	f9 01       	movw	r30, r18
    14f0:	ee 0f       	add	r30, r30
    14f2:	ff 1f       	adc	r31, r31
    14f4:	e0 58       	subi	r30, 0x80	; 128
    14f6:	fd 4f       	sbci	r31, 0xFD	; 253
    14f8:	11 82       	std	Z+1, r1	; 0x01
    14fa:	10 82       	st	Z, r1
	return 0;
    14fc:	80 e0       	ldi	r24, 0x00	; 0
    14fe:	90 e0       	ldi	r25, 0x00	; 0
}
    1500:	08 95       	ret

00001502 <_Z11makeitrighti>:
Output :      bot faces in the direction it need to travel in the next dijkstra's run
Logic:		  since there are four direction bot can face so sum of all previous turn tells which direction bot is facing now and accordingly turns itself in the next deisred direction
Example Call: makeitright(sum);
*/
void makeitright(int x)
{
    1502:	cf 93       	push	r28
    1504:	df 93       	push	r29
	int a=4-(x%4);
    1506:	24 e0       	ldi	r18, 0x04	; 4
    1508:	30 e0       	ldi	r19, 0x00	; 0
    150a:	b9 01       	movw	r22, r18
    150c:	0e 94 84 12 	call	0x2508	; 0x2508 <__divmodhi4>
    1510:	e9 01       	movw	r28, r18
    1512:	c8 1b       	sub	r28, r24
    1514:	d9 0b       	sbc	r29, r25
	//lcd_print(1,7,a,2);
	//lcd_print(1,10,a+path[0],2);
	if((a+path[0])%4==0)
    1516:	80 91 e9 0a 	lds	r24, 0x0AE9
    151a:	90 91 ea 0a 	lds	r25, 0x0AEA
    151e:	8c 0f       	add	r24, r28
    1520:	9d 1f       	adc	r25, r29
    1522:	9c 01       	movw	r18, r24
    1524:	23 70       	andi	r18, 0x03	; 3
    1526:	30 70       	andi	r19, 0x00	; 0
    1528:	21 15       	cp	r18, r1
    152a:	31 05       	cpc	r19, r1
    152c:	69 f1       	breq	.+90     	; 0x1588 <_Z11makeitrighti+0x86>
	{
	}
	else if((a+path[0])%4==2)//it is back
    152e:	64 e0       	ldi	r22, 0x04	; 4
    1530:	70 e0       	ldi	r23, 0x00	; 0
    1532:	0e 94 84 12 	call	0x2508	; 0x2508 <__divmodhi4>
    1536:	82 30       	cpi	r24, 0x02	; 2
    1538:	91 05       	cpc	r25, r1
    153a:	91 f4       	brne	.+36     	; 0x1560 <_Z11makeitrighti+0x5e>
	{
		
		right_degrees(135); //Rotate robot right by 90 degrees
    153c:	87 e8       	ldi	r24, 0x87	; 135
    153e:	90 e0       	ldi	r25, 0x00	; 0
    1540:	0e 94 ad 07 	call	0xf5a	; 0xf5a <_Z13right_degreesj>
		right_count(); //Rotate robot right by 90 degrees
    1544:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <_Z11right_countv>
    1548:	8f ef       	ldi	r24, 0xFF	; 255
    154a:	9f e7       	ldi	r25, 0x7F	; 127
    154c:	a4 e0       	ldi	r26, 0x04	; 4
    154e:	81 50       	subi	r24, 0x01	; 1
    1550:	90 40       	sbci	r25, 0x00	; 0
    1552:	a0 40       	sbci	r26, 0x00	; 0
    1554:	e1 f7       	brne	.-8      	; 0x154e <_Z11makeitrighti+0x4c>
    1556:	00 c0       	rjmp	.+0      	; 0x1558 <_Z11makeitrighti+0x56>
    1558:	00 00       	nop
		_delay_ms(100);
		align();
    155a:	0e 94 09 0a 	call	0x1412	; 0x1412 <_Z5alignv>
    155e:	14 c0       	rjmp	.+40     	; 0x1588 <_Z11makeitrighti+0x86>
	}
	else if((a+path[0])%4==3)//it is right
    1560:	83 30       	cpi	r24, 0x03	; 3
    1562:	91 05       	cpc	r25, r1
    1564:	89 f4       	brne	.+34     	; 0x1588 <_Z11makeitrighti+0x86>
	{
		right_degrees(45); //Rotate robot right by 90 degrees
    1566:	8d e2       	ldi	r24, 0x2D	; 45
    1568:	90 e0       	ldi	r25, 0x00	; 0
    156a:	0e 94 ad 07 	call	0xf5a	; 0xf5a <_Z13right_degreesj>
		right_count(); //Rotate robot right by 90 degrees
    156e:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <_Z11right_countv>
    1572:	8f ef       	ldi	r24, 0xFF	; 255
    1574:	9f e7       	ldi	r25, 0x7F	; 127
    1576:	a4 e0       	ldi	r26, 0x04	; 4
    1578:	81 50       	subi	r24, 0x01	; 1
    157a:	90 40       	sbci	r25, 0x00	; 0
    157c:	a0 40       	sbci	r26, 0x00	; 0
    157e:	e1 f7       	brne	.-8      	; 0x1578 <_Z11makeitrighti+0x76>
    1580:	00 c0       	rjmp	.+0      	; 0x1582 <_Z11makeitrighti+0x80>
    1582:	00 00       	nop
		_delay_ms(100);
		align();
    1584:	0e 94 09 0a 	call	0x1412	; 0x1412 <_Z5alignv>
	}
	if((a+path[0])%4==1)//it is left
    1588:	80 91 e9 0a 	lds	r24, 0x0AE9
    158c:	90 91 ea 0a 	lds	r25, 0x0AEA
    1590:	8c 0f       	add	r24, r28
    1592:	9d 1f       	adc	r25, r29
    1594:	64 e0       	ldi	r22, 0x04	; 4
    1596:	70 e0       	ldi	r23, 0x00	; 0
    1598:	0e 94 84 12 	call	0x2508	; 0x2508 <__divmodhi4>
    159c:	81 30       	cpi	r24, 0x01	; 1
    159e:	91 05       	cpc	r25, r1
    15a0:	89 f4       	brne	.+34     	; 0x15c4 <_Z11makeitrighti+0xc2>
	{
		left_degrees(45); //Rotate robot left by 90 degrees
    15a2:	8d e2       	ldi	r24, 0x2D	; 45
    15a4:	90 e0       	ldi	r25, 0x00	; 0
    15a6:	0e 94 a2 07 	call	0xf44	; 0xf44 <_Z12left_degreesj>
		left_count(); //Rotate robot right by 90 degrees
    15aa:	0e 94 05 08 	call	0x100a	; 0x100a <_Z10left_countv>
    15ae:	8f ef       	ldi	r24, 0xFF	; 255
    15b0:	9f e7       	ldi	r25, 0x7F	; 127
    15b2:	a4 e0       	ldi	r26, 0x04	; 4
    15b4:	81 50       	subi	r24, 0x01	; 1
    15b6:	90 40       	sbci	r25, 0x00	; 0
    15b8:	a0 40       	sbci	r26, 0x00	; 0
    15ba:	e1 f7       	brne	.-8      	; 0x15b4 <_Z11makeitrighti+0xb2>
    15bc:	00 c0       	rjmp	.+0      	; 0x15be <_Z11makeitrighti+0xbc>
    15be:	00 00       	nop
		_delay_ms(100);
		align();
    15c0:	0e 94 09 0a 	call	0x1412	; 0x1412 <_Z5alignv>
	}
	
}
    15c4:	df 91       	pop	r29
    15c6:	cf 91       	pop	r28
    15c8:	08 95       	ret

000015ca <_Z12init_devicesv>:


//Function to initialize all the devices
void init_devices()
{
	cli(); //Clears the global interrupt
    15ca:	f8 94       	cli
	port_init();  //Initializes all the ports
    15cc:	0e 94 d6 05 	call	0xbac	; 0xbac <_Z9port_initv>
	adc_init();
    15d0:	0e 94 06 06 	call	0xc0c	; 0xc0c <_Z8adc_initv>
	timer5_init();
    15d4:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <_Z11timer5_initv>
	timer1_init();
    15d8:	0e 94 15 08 	call	0x102a	; 0x102a <_Z11timer1_initv>
	color_sensor_pin_interrupt_init();
    15dc:	0e 94 a5 05 	call	0xb4a	; 0xb4a <_Z31color_sensor_pin_interrupt_initv>
	uart0_init(); //Initailize UART0 for serial communiaction
    15e0:	0e 94 40 05 	call	0xa80	; 0xa80 <_Z10uart0_initv>
	uart2_init(); //Initailize UART1 for serial communiaction
    15e4:	0e 94 53 05 	call	0xaa6	; 0xaa6 <_Z10uart2_initv>
	left_position_encoder_interrupt_init();
    15e8:	0e 94 42 06 	call	0xc84	; 0xc84 <_Z36left_position_encoder_interrupt_initv>
	right_position_encoder_interrupt_init();
    15ec:	0e 94 4b 06 	call	0xc96	; 0xc96 <_Z37right_position_encoder_interrupt_initv>
	sei();   // Enables the global interrupt
    15f0:	78 94       	sei
}
    15f2:	08 95       	ret

000015f4 <main>:
Output :      none
Logic:		  driver function to provide necessary medical services and call helper function appropriately
Example Call: -
*/
int main(void)
{
    15f4:	2f 92       	push	r2
    15f6:	3f 92       	push	r3
    15f8:	4f 92       	push	r4
    15fa:	5f 92       	push	r5
    15fc:	6f 92       	push	r6
    15fe:	7f 92       	push	r7
    1600:	8f 92       	push	r8
    1602:	9f 92       	push	r9
    1604:	af 92       	push	r10
    1606:	bf 92       	push	r11
    1608:	cf 92       	push	r12
    160a:	df 92       	push	r13
    160c:	ef 92       	push	r14
    160e:	ff 92       	push	r15
    1610:	0f 93       	push	r16
    1612:	1f 93       	push	r17
    1614:	cf 93       	push	r28
    1616:	df 93       	push	r29
    1618:	00 d0       	rcall	.+0      	; 0x161a <main+0x26>
    161a:	0f 92       	push	r0
    161c:	cd b7       	in	r28, 0x3d	; 61
    161e:	de b7       	in	r29, 0x3e	; 62
	init_devices();
    1620:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <_Z12init_devicesv>
	lcd_set_4bit();
    1624:	0e 94 d6 00 	call	0x1ac	; 0x1ac <_Z12lcd_set_4bitv>
	lcd_init();
    1628:	0e 94 3e 01 	call	0x27c	; 0x27c <_Z8lcd_initv>
	servo_1_rest();
    162c:	0e 94 51 08 	call	0x10a2	; 0x10a2 <_Z12servo_1_restv>
	servo_2_rest();
    1630:	0e 94 55 08 	call	0x10aa	; 0x10aa <_Z12servo_2_restv>
	rem(2);
    1634:	82 e0       	ldi	r24, 0x02	; 2
    1636:	90 e0       	ldi	r25, 0x00	; 0
    1638:	0e 94 3a 02 	call	0x474	; 0x474 <_Z3remi>
	data=250;
    163c:	8a ef       	ldi	r24, 0xFA	; 250
    163e:	90 e0       	ldi	r25, 0x00	; 0
    1640:	90 93 6e 05 	sts	0x056E, r25
    1644:	80 93 6d 05 	sts	0x056D, r24
	UDR0=data;
    1648:	8a ef       	ldi	r24, 0xFA	; 250
    164a:	80 93 c6 00 	sts	0x00C6, r24
	flag=4;
    164e:	84 e0       	ldi	r24, 0x04	; 4
    1650:	90 e0       	ldi	r25, 0x00	; 0
    1652:	90 93 44 05 	sts	0x0544, r25
    1656:	80 93 43 05 	sts	0x0543, r24
	x=0;
    165a:	10 92 46 05 	sts	0x0546, r1
    165e:	10 92 45 05 	sts	0x0545, r1
	int etc=0,sdest=0,t=0,destination=0;
	unsigned int current=49;
	for(int k=0;k<100;k++,etc++)
    1662:	88 24       	eor	r8, r8
    1664:	99 24       	eor	r9, r9
	data=250;
	UDR0=data;
	flag=4;
	x=0;
	int etc=0,sdest=0,t=0,destination=0;
	unsigned int current=49;
    1666:	01 e3       	ldi	r16, 0x31	; 49
    1668:	10 e0       	ldi	r17, 0x00	; 0
	rem(2);
	data=250;
	UDR0=data;
	flag=4;
	x=0;
	int etc=0,sdest=0,t=0,destination=0;
    166a:	1a 82       	std	Y+2, r1	; 0x02
    166c:	19 82       	std	Y+1, r1	; 0x01
		destination=sdest;
		lcd_print(2,1,current,2);
		lcd_print(2,5,sdest,2);
		shortest_path(current,sdest);
		makeitright(x);
		x=path[0];
    166e:	0f 2e       	mov	r0, r31
    1670:	f9 ee       	ldi	r31, 0xE9	; 233
    1672:	af 2e       	mov	r10, r31
    1674:	fa e0       	ldi	r31, 0x0A	; 10
    1676:	bf 2e       	mov	r11, r31
    1678:	f0 2d       	mov	r31, r0
			}
			else if((Center_white_line>0x15 && Left_white_line>0x15 && Right_white_line>0x15)||(Center_white_line>0x15 && Left_white_line>0x15 && Right_white_line<0x15)||(Center_white_line>0x15 && Left_white_line<0x15 && Right_white_line>0x15))
			{
				flag=4;
				
				lcd_print(2,9,original[count],3);
    167a:	0f 2e       	mov	r0, r31
    167c:	f9 e5       	ldi	r31, 0x59	; 89
    167e:	ef 2e       	mov	r14, r31
    1680:	f9 e0       	ldi	r31, 0x09	; 9
    1682:	ff 2e       	mov	r15, r31
    1684:	f0 2d       	mov	r31, r0
					
					if(k>1 && j!=2)
					{
						data=150;
						lcd_print(1,1,data,3);
						UDR0=data;
    1686:	0f 2e       	mov	r0, r31
    1688:	fd e6       	ldi	r31, 0x6D	; 109
    168a:	2f 2e       	mov	r2, r31
    168c:	f5 e0       	ldi	r31, 0x05	; 5
    168e:	3f 2e       	mov	r3, r31
    1690:	f0 2d       	mov	r31, r0
	int etc=0,sdest=0,t=0,destination=0;
	unsigned int current=49;
	for(int k=0;k<100;k++,etc++)
	{
		
		if(etc==0)
    1692:	81 14       	cp	r8, r1
    1694:	91 04       	cpc	r9, r1
    1696:	29 f4       	brne	.+10     	; 0x16a2 <main+0xae>
		count=0;
    1698:	10 92 4a 05 	sts	0x054A, r1
    169c:	10 92 49 05 	sts	0x0549, r1
    16a0:	06 c0       	rjmp	.+12     	; 0x16ae <main+0xba>
		else 
		count=1;
    16a2:	81 e0       	ldi	r24, 0x01	; 1
    16a4:	90 e0       	ldi	r25, 0x00	; 0
    16a6:	90 93 4a 05 	sts	0x054A, r25
    16aa:	80 93 49 05 	sts	0x0549, r24
		//lcd_print(1,7,k,2);
		sdest=nextdest();
    16ae:	0e 94 1e 0a 	call	0x143c	; 0x143c <_Z8nextdestv>
    16b2:	6c 01       	movw	r12, r24
		destination=sdest;
		lcd_print(2,1,current,2);
    16b4:	82 e0       	ldi	r24, 0x02	; 2
    16b6:	61 e0       	ldi	r22, 0x01	; 1
    16b8:	a8 01       	movw	r20, r16
    16ba:	22 e0       	ldi	r18, 0x02	; 2
    16bc:	30 e0       	ldi	r19, 0x00	; 0
    16be:	0e 94 ad 01 	call	0x35a	; 0x35a <_Z9lcd_printccji>
		lcd_print(2,5,sdest,2);
    16c2:	dc 82       	std	Y+4, r13	; 0x04
    16c4:	cb 82       	std	Y+3, r12	; 0x03
    16c6:	82 e0       	ldi	r24, 0x02	; 2
    16c8:	65 e0       	ldi	r22, 0x05	; 5
    16ca:	a6 01       	movw	r20, r12
    16cc:	22 e0       	ldi	r18, 0x02	; 2
    16ce:	30 e0       	ldi	r19, 0x00	; 0
    16d0:	0e 94 ad 01 	call	0x35a	; 0x35a <_Z9lcd_printccji>
		shortest_path(current,sdest);
    16d4:	c8 01       	movw	r24, r16
    16d6:	b6 01       	movw	r22, r12
    16d8:	0e 94 56 02 	call	0x4ac	; 0x4ac <_Z13shortest_pathjj>
		makeitright(x);
    16dc:	80 91 45 05 	lds	r24, 0x0545
    16e0:	90 91 46 05 	lds	r25, 0x0546
    16e4:	0e 94 81 0a 	call	0x1502	; 0x1502 <_Z11makeitrighti>
		x=path[0];
    16e8:	d5 01       	movw	r26, r10
    16ea:	8d 91       	ld	r24, X+
    16ec:	9c 91       	ld	r25, X
    16ee:	11 97       	sbiw	r26, 0x01	; 1
    16f0:	90 93 46 05 	sts	0x0546, r25
    16f4:	80 93 45 05 	sts	0x0545, r24
				forward();
				velocity(250,170);
			}
			else if((Center_white_line>0x15 && Left_white_line>0x15 && Right_white_line>0x15)||(Center_white_line>0x15 && Left_white_line>0x15 && Right_white_line<0x15)||(Center_white_line>0x15 && Left_white_line<0x15 && Right_white_line>0x15))
			{
				flag=4;
    16f8:	04 e0       	ldi	r16, 0x04	; 4
    16fa:	10 e0       	ldi	r17, 0x00	; 0
				velocity(250,250);
				flag=1;
			}
			else if(Center_white_line<0x15 && Left_white_line>0x15 && Right_white_line<0x15)//left sensed color is black
			{
				flag=2;
    16fc:	44 24       	eor	r4, r4
    16fe:	55 24       	eor	r5, r5
    1700:	68 94       	set
    1702:	41 f8       	bld	r4, 1
			}
			else if(Center_white_line>0x15 && Left_white_line<0x15 && Right_white_line<0x15)//center sensed color is black
			{
				forward();
				velocity(250,250);
				flag=1;
    1704:	66 24       	eor	r6, r6
    1706:	77 24       	eor	r7, r7
    1708:	63 94       	inc	r6
		shortest_path(current,sdest);
		makeitright(x);
		x=path[0];
		while(1)
		{
			if(rec>0&& rec<=90)
    170a:	80 91 6b 05 	lds	r24, 0x056B
    170e:	90 91 6c 05 	lds	r25, 0x056C
    1712:	9c 01       	movw	r18, r24
    1714:	21 50       	subi	r18, 0x01	; 1
    1716:	30 40       	sbci	r19, 0x00	; 0
    1718:	2a 35       	cpi	r18, 0x5A	; 90
    171a:	31 05       	cpc	r19, r1
    171c:	10 f4       	brcc	.+4      	; 0x1722 <main+0x12e>
			{
				
				rem(rec);
    171e:	0e 94 3a 02 	call	0x474	; 0x474 <_Z3remi>
				
			}
			
			Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
    1722:	83 e0       	ldi	r24, 0x03	; 3
    1724:	0e 94 13 06 	call	0xc26	; 0xc26 <_Z14ADC_Conversionh>
    1728:	80 93 34 05 	sts	0x0534, r24
			Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
    172c:	82 e0       	ldi	r24, 0x02	; 2
    172e:	0e 94 13 06 	call	0xc26	; 0xc26 <_Z14ADC_Conversionh>
    1732:	80 93 33 05 	sts	0x0533, r24
			Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor
    1736:	81 e0       	ldi	r24, 0x01	; 1
    1738:	0e 94 13 06 	call	0xc26	; 0xc26 <_Z14ADC_Conversionh>
    173c:	80 93 32 05 	sts	0x0532, r24
			//print_sensor(1,1,2);
			sharp = ADC_Conversion(11);						//Stores the Analog value of front sharp connected to ADC channel 11 into variable "sharp"
    1740:	8b e0       	ldi	r24, 0x0B	; 11
    1742:	0e 94 13 06 	call	0xc26	; 0xc26 <_Z14ADC_Conversionh>
    1746:	80 93 4e 05 	sts	0x054E, r24
			value = Sharp_GP2D12_estimation(sharp);				//Stores Distance calsulated in a variable "value".
    174a:	0e 94 d5 06 	call	0xdaa	; 0xdaa <_Z23Sharp_GP2D12_estimationh>
    174e:	90 93 4d 05 	sts	0x054D, r25
    1752:	80 93 4c 05 	sts	0x054C, r24
			if(value>80 && value<150)
    1756:	81 55       	subi	r24, 0x51	; 81
    1758:	90 40       	sbci	r25, 0x00	; 0
    175a:	85 34       	cpi	r24, 0x45	; 69
    175c:	91 05       	cpc	r25, r1
    175e:	08 f0       	brcs	.+2      	; 0x1762 <main+0x16e>
    1760:	ba c0       	rjmp	.+372    	; 0x18d6 <main+0x2e2>
			{
				stop();
    1762:	0e 94 d1 06 	call	0xda2	; 0xda2 <_Z4stopv>
				//_delay_ms(1000);
				if(count==tot-1)
    1766:	20 91 49 05 	lds	r18, 0x0549
    176a:	30 91 4a 05 	lds	r19, 0x054A
    176e:	80 91 57 09 	lds	r24, 0x0957
    1772:	90 91 58 09 	lds	r25, 0x0958
    1776:	01 97       	sbiw	r24, 0x01	; 1
    1778:	82 17       	cp	r24, r18
    177a:	93 07       	cpc	r25, r19
    177c:	09 f0       	breq	.+2      	; 0x1780 <main+0x18c>
    177e:	60 c0       	rjmp	.+192    	; 0x1840 <main+0x24c>
    1780:	13 c0       	rjmp	.+38     	; 0x17a8 <main+0x1b4>
				{
					for(int i=0;i<16;i++)
					{
						for(int j=0;j<4;j++)
						{
							if(val[i][j]==sdest)
    1782:	80 81       	ld	r24, Z
    1784:	91 81       	ldd	r25, Z+1	; 0x01
    1786:	a8 17       	cp	r26, r24
    1788:	b9 07       	cpc	r27, r25
    178a:	11 f4       	brne	.+4      	; 0x1790 <main+0x19c>
							val[i][j]=0;
    178c:	11 82       	std	Z+1, r1	; 0x01
    178e:	10 82       	st	Z, r1
    1790:	21 50       	subi	r18, 0x01	; 1
    1792:	30 40       	sbci	r19, 0x00	; 0
    1794:	32 96       	adiw	r30, 0x02	; 2
				//_delay_ms(1000);
				if(count==tot-1)
				{
					for(int i=0;i<16;i++)
					{
						for(int j=0;j<4;j++)
    1796:	21 15       	cp	r18, r1
    1798:	31 05       	cpc	r19, r1
    179a:	99 f7       	brne	.-26     	; 0x1782 <main+0x18e>
			{
				stop();
				//_delay_ms(1000);
				if(count==tot-1)
				{
					for(int i=0;i<16;i++)
    179c:	4f 5f       	subi	r20, 0xFF	; 255
    179e:	5f 4f       	sbci	r21, 0xFF	; 255
    17a0:	40 31       	cpi	r20, 0x10	; 16
    17a2:	51 05       	cpc	r21, r1
    17a4:	39 f4       	brne	.+14     	; 0x17b4 <main+0x1c0>
    17a6:	11 c0       	rjmp	.+34     	; 0x17ca <main+0x1d6>
			value = Sharp_GP2D12_estimation(sharp);				//Stores Distance calsulated in a variable "value".
			if(value>80 && value<150)
			{
				stop();
				//_delay_ms(1000);
				if(count==tot-1)
    17a8:	40 e0       	ldi	r20, 0x00	; 0
    17aa:	50 e0       	ldi	r21, 0x00	; 0
Input :       none
Output :      none
Logic:		  driver function to provide necessary medical services and call helper function appropriately
Example Call: -
*/
int main(void)
    17ac:	64 e0       	ldi	r22, 0x04	; 4
    17ae:	70 e0       	ldi	r23, 0x00	; 0
    17b0:	ab 81       	ldd	r26, Y+3	; 0x03
    17b2:	bc 81       	ldd	r27, Y+4	; 0x04
    17b4:	fa 01       	movw	r30, r20
    17b6:	ee 0f       	add	r30, r30
    17b8:	ff 1f       	adc	r31, r31
    17ba:	ee 0f       	add	r30, r30
    17bc:	ff 1f       	adc	r31, r31
    17be:	ee 0f       	add	r30, r30
    17c0:	ff 1f       	adc	r31, r31
    17c2:	e0 50       	subi	r30, 0x00	; 0
    17c4:	fe 4f       	sbci	r31, 0xFE	; 254
    17c6:	9b 01       	movw	r18, r22
    17c8:	dc cf       	rjmp	.-72     	; 0x1782 <main+0x18e>
							if(val[i][j]==sdest)
							val[i][j]=0;
						}
					}
					//lcd_print(1,5,sdest,2);
					rem(sdest);
    17ca:	c6 01       	movw	r24, r12
    17cc:	0e 94 3a 02 	call	0x474	; 0x474 <_Z3remi>
					data=110;
    17d0:	8e e6       	ldi	r24, 0x6E	; 110
    17d2:	90 e0       	ldi	r25, 0x00	; 0
    17d4:	90 93 6e 05 	sts	0x056E, r25
    17d8:	80 93 6d 05 	sts	0x056D, r24
					lcd_print(1,1,data,3);
    17dc:	81 e0       	ldi	r24, 0x01	; 1
    17de:	61 e0       	ldi	r22, 0x01	; 1
    17e0:	4e e6       	ldi	r20, 0x6E	; 110
    17e2:	50 e0       	ldi	r21, 0x00	; 0
    17e4:	23 e0       	ldi	r18, 0x03	; 3
    17e6:	30 e0       	ldi	r19, 0x00	; 0
    17e8:	0e 94 ad 01 	call	0x35a	; 0x35a <_Z9lcd_printccji>
					
					UDR0=data;
    17ec:	d1 01       	movw	r26, r2
    17ee:	8c 91       	ld	r24, X
    17f0:	06 ec       	ldi	r16, 0xC6	; 198
    17f2:	10 e0       	ldi	r17, 0x00	; 0
    17f4:	f8 01       	movw	r30, r16
    17f6:	80 83       	st	Z, r24
    17f8:	8f ef       	ldi	r24, 0xFF	; 255
    17fa:	9f e7       	ldi	r25, 0x7F	; 127
    17fc:	a4 e0       	ldi	r26, 0x04	; 4
    17fe:	81 50       	subi	r24, 0x01	; 1
    1800:	90 40       	sbci	r25, 0x00	; 0
    1802:	a0 40       	sbci	r26, 0x00	; 0
    1804:	e1 f7       	brne	.-8      	; 0x17fe <main+0x20a>
    1806:	00 c0       	rjmp	.+0      	; 0x1808 <main+0x214>
    1808:	00 00       	nop
					_delay_ms(100);
					data=sdest;
    180a:	d0 92 6e 05 	sts	0x056E, r13
    180e:	c0 92 6d 05 	sts	0x056D, r12
					lcd_print(1,1,data,3);
    1812:	81 e0       	ldi	r24, 0x01	; 1
    1814:	61 e0       	ldi	r22, 0x01	; 1
    1816:	a6 01       	movw	r20, r12
    1818:	23 e0       	ldi	r18, 0x03	; 3
    181a:	30 e0       	ldi	r19, 0x00	; 0
    181c:	0e 94 ad 01 	call	0x35a	; 0x35a <_Z9lcd_printccji>
					
					UDR0=data;
    1820:	d1 01       	movw	r26, r2
    1822:	8c 91       	ld	r24, X
    1824:	f8 01       	movw	r30, r16
    1826:	80 83       	st	Z, r24
					
					current=original[count-1];
    1828:	e0 91 49 05 	lds	r30, 0x0549
    182c:	f0 91 4a 05 	lds	r31, 0x054A
    1830:	31 97       	sbiw	r30, 0x01	; 1
    1832:	ee 0f       	add	r30, r30
    1834:	ff 1f       	adc	r31, r31
    1836:	ee 0d       	add	r30, r14
    1838:	ff 1d       	adc	r31, r15
    183a:	00 81       	ld	r16, Z
    183c:	11 81       	ldd	r17, Z+1	; 0x01
    183e:	db c2       	rjmp	.+1462   	; 0x1df6 <main+0x802>
					//lcd_print(1,8,original[count-1],2);
				}
				else
				{//lcd_print(1,5,original[count],2);
					rem(original[count]);
    1840:	f9 01       	movw	r30, r18
    1842:	ee 0f       	add	r30, r30
    1844:	ff 1f       	adc	r31, r31
    1846:	ee 0d       	add	r30, r14
    1848:	ff 1d       	adc	r31, r15
    184a:	80 81       	ld	r24, Z
    184c:	91 81       	ldd	r25, Z+1	; 0x01
    184e:	0e 94 3a 02 	call	0x474	; 0x474 <_Z3remi>
					data=110;
    1852:	8e e6       	ldi	r24, 0x6E	; 110
    1854:	90 e0       	ldi	r25, 0x00	; 0
    1856:	90 93 6e 05 	sts	0x056E, r25
    185a:	80 93 6d 05 	sts	0x056D, r24
					lcd_print(1,1,data,3);
    185e:	81 e0       	ldi	r24, 0x01	; 1
    1860:	61 e0       	ldi	r22, 0x01	; 1
    1862:	4e e6       	ldi	r20, 0x6E	; 110
    1864:	50 e0       	ldi	r21, 0x00	; 0
    1866:	23 e0       	ldi	r18, 0x03	; 3
    1868:	30 e0       	ldi	r19, 0x00	; 0
    186a:	0e 94 ad 01 	call	0x35a	; 0x35a <_Z9lcd_printccji>
				
					UDR0=data;
    186e:	d1 01       	movw	r26, r2
    1870:	8c 91       	ld	r24, X
    1872:	06 ec       	ldi	r16, 0xC6	; 198
    1874:	10 e0       	ldi	r17, 0x00	; 0
    1876:	f8 01       	movw	r30, r16
    1878:	80 83       	st	Z, r24
    187a:	8f ef       	ldi	r24, 0xFF	; 255
    187c:	9f e7       	ldi	r25, 0x7F	; 127
    187e:	a4 e0       	ldi	r26, 0x04	; 4
    1880:	81 50       	subi	r24, 0x01	; 1
    1882:	90 40       	sbci	r25, 0x00	; 0
    1884:	a0 40       	sbci	r26, 0x00	; 0
    1886:	e1 f7       	brne	.-8      	; 0x1880 <main+0x28c>
    1888:	00 c0       	rjmp	.+0      	; 0x188a <main+0x296>
    188a:	00 00       	nop
					_delay_ms(100);
					data=original[count];
    188c:	80 91 49 05 	lds	r24, 0x0549
    1890:	90 91 4a 05 	lds	r25, 0x054A
    1894:	88 0f       	add	r24, r24
    1896:	99 1f       	adc	r25, r25
    1898:	8e 0d       	add	r24, r14
    189a:	9f 1d       	adc	r25, r15
    189c:	dc 01       	movw	r26, r24
    189e:	4d 91       	ld	r20, X+
    18a0:	5c 91       	ld	r21, X
    18a2:	50 93 6e 05 	sts	0x056E, r21
    18a6:	40 93 6d 05 	sts	0x056D, r20
					lcd_print(1,1,data,3);
    18aa:	81 e0       	ldi	r24, 0x01	; 1
    18ac:	61 e0       	ldi	r22, 0x01	; 1
    18ae:	23 e0       	ldi	r18, 0x03	; 3
    18b0:	30 e0       	ldi	r19, 0x00	; 0
    18b2:	0e 94 ad 01 	call	0x35a	; 0x35a <_Z9lcd_printccji>
					UDR0=data;
    18b6:	f1 01       	movw	r30, r2
    18b8:	80 81       	ld	r24, Z
    18ba:	d8 01       	movw	r26, r16
    18bc:	8c 93       	st	X, r24
				current=original[count-1];
    18be:	e0 91 49 05 	lds	r30, 0x0549
    18c2:	f0 91 4a 05 	lds	r31, 0x054A
    18c6:	31 97       	sbiw	r30, 0x01	; 1
    18c8:	ee 0f       	add	r30, r30
    18ca:	ff 1f       	adc	r31, r31
    18cc:	ee 0d       	add	r30, r14
    18ce:	ff 1d       	adc	r31, r15
    18d0:	00 81       	ld	r16, Z
    18d2:	11 81       	ldd	r17, Z+1	; 0x01
    18d4:	90 c2       	rjmp	.+1312   	; 0x1df6 <main+0x802>
				//lcd_print(1,8,original[count-1],2);
				}				
				break;
			}
			if(Center_white_line<0x15 && Left_white_line<0x15 && Right_white_line<0x15)
    18d6:	80 91 33 05 	lds	r24, 0x0533
    18da:	85 31       	cpi	r24, 0x15	; 21
    18dc:	f0 f5       	brcc	.+124    	; 0x195a <main+0x366>
    18de:	90 91 34 05 	lds	r25, 0x0534
    18e2:	95 31       	cpi	r25, 0x15	; 21
    18e4:	d0 f5       	brcc	.+116    	; 0x195a <main+0x366>
    18e6:	90 91 32 05 	lds	r25, 0x0532
    18ea:	95 31       	cpi	r25, 0x15	; 21
    18ec:	b0 f5       	brcc	.+108    	; 0x195a <main+0x366>
			{
				if (flag==1)
    18ee:	80 91 43 05 	lds	r24, 0x0543
    18f2:	90 91 44 05 	lds	r25, 0x0544
    18f6:	81 30       	cpi	r24, 0x01	; 1
    18f8:	91 05       	cpc	r25, r1
    18fa:	31 f4       	brne	.+12     	; 0x1908 <main+0x314>
				{
					forward();
    18fc:	0e 94 b1 06 	call	0xd62	; 0xd62 <_Z7forwardv>
					velocity(250,250);
    1900:	8a ef       	ldi	r24, 0xFA	; 250
    1902:	6a ef       	ldi	r22, 0xFA	; 250
    1904:	0e 94 9e 06 	call	0xd3c	; 0xd3c <_Z8velocityhh>
				}
				if (flag==2)
    1908:	80 91 43 05 	lds	r24, 0x0543
    190c:	90 91 44 05 	lds	r25, 0x0544
    1910:	82 30       	cpi	r24, 0x02	; 2
    1912:	91 05       	cpc	r25, r1
    1914:	31 f4       	brne	.+12     	; 0x1922 <main+0x32e>
				{
					forward();
    1916:	0e 94 b1 06 	call	0xd62	; 0xd62 <_Z7forwardv>
					velocity(170,250);
    191a:	8a ea       	ldi	r24, 0xAA	; 170
    191c:	6a ef       	ldi	r22, 0xFA	; 250
    191e:	0e 94 9e 06 	call	0xd3c	; 0xd3c <_Z8velocityhh>
				}
				if (flag==3)
    1922:	80 91 43 05 	lds	r24, 0x0543
    1926:	90 91 44 05 	lds	r25, 0x0544
    192a:	83 30       	cpi	r24, 0x03	; 3
    192c:	91 05       	cpc	r25, r1
    192e:	31 f4       	brne	.+12     	; 0x193c <main+0x348>
				{
					forward();
    1930:	0e 94 b1 06 	call	0xd62	; 0xd62 <_Z7forwardv>
					velocity(250,170);
    1934:	8a ef       	ldi	r24, 0xFA	; 250
    1936:	6a ea       	ldi	r22, 0xAA	; 170
    1938:	0e 94 9e 06 	call	0xd3c	; 0xd3c <_Z8velocityhh>
				}
				if(flag==4)
    193c:	80 91 43 05 	lds	r24, 0x0543
    1940:	90 91 44 05 	lds	r25, 0x0544
    1944:	84 30       	cpi	r24, 0x04	; 4
    1946:	91 05       	cpc	r25, r1
    1948:	09 f0       	breq	.+2      	; 0x194c <main+0x358>
    194a:	df ce       	rjmp	.-578    	; 0x170a <main+0x116>
				{
					forward();
    194c:	0e 94 b1 06 	call	0xd62	; 0xd62 <_Z7forwardv>
					velocity(250,250);
    1950:	8a ef       	ldi	r24, 0xFA	; 250
    1952:	6a ef       	ldi	r22, 0xFA	; 250
    1954:	0e 94 9e 06 	call	0xd3c	; 0xd3c <_Z8velocityhh>
    1958:	d8 ce       	rjmp	.-592    	; 0x170a <main+0x116>
				}
			
			}
			else if(Center_white_line>0x15 && Left_white_line<0x15 && Right_white_line<0x15)//center sensed color is black
    195a:	86 31       	cpi	r24, 0x16	; 22
    195c:	98 f0       	brcs	.+38     	; 0x1984 <main+0x390>
    195e:	90 91 34 05 	lds	r25, 0x0534
    1962:	95 31       	cpi	r25, 0x15	; 21
    1964:	78 f4       	brcc	.+30     	; 0x1984 <main+0x390>
    1966:	90 91 32 05 	lds	r25, 0x0532
    196a:	95 31       	cpi	r25, 0x15	; 21
    196c:	58 f4       	brcc	.+22     	; 0x1984 <main+0x390>
			{
				forward();
    196e:	0e 94 b1 06 	call	0xd62	; 0xd62 <_Z7forwardv>
				velocity(250,250);
    1972:	8a ef       	ldi	r24, 0xFA	; 250
    1974:	6a ef       	ldi	r22, 0xFA	; 250
    1976:	0e 94 9e 06 	call	0xd3c	; 0xd3c <_Z8velocityhh>
				flag=1;
    197a:	70 92 44 05 	sts	0x0544, r7
    197e:	60 92 43 05 	sts	0x0543, r6
    1982:	c3 ce       	rjmp	.-634    	; 0x170a <main+0x116>
			}
			else if(Center_white_line<0x15 && Left_white_line>0x15 && Right_white_line<0x15)//left sensed color is black
    1984:	85 31       	cpi	r24, 0x15	; 21
    1986:	30 f5       	brcc	.+76     	; 0x19d4 <main+0x3e0>
    1988:	90 91 34 05 	lds	r25, 0x0534
    198c:	96 31       	cpi	r25, 0x16	; 22
    198e:	78 f0       	brcs	.+30     	; 0x19ae <main+0x3ba>
    1990:	20 91 32 05 	lds	r18, 0x0532
    1994:	25 31       	cpi	r18, 0x15	; 21
    1996:	58 f4       	brcc	.+22     	; 0x19ae <main+0x3ba>
			{
				flag=2;
    1998:	50 92 44 05 	sts	0x0544, r5
    199c:	40 92 43 05 	sts	0x0543, r4
				forward();
    19a0:	0e 94 b1 06 	call	0xd62	; 0xd62 <_Z7forwardv>
				velocity(170,250);
    19a4:	8a ea       	ldi	r24, 0xAA	; 170
    19a6:	6a ef       	ldi	r22, 0xFA	; 250
    19a8:	0e 94 9e 06 	call	0xd3c	; 0xd3c <_Z8velocityhh>
    19ac:	ae ce       	rjmp	.-676    	; 0x170a <main+0x116>
			}
			else if(Center_white_line<0x15 && Left_white_line<0x15 && Right_white_line>0x15)//right sensed color is black
    19ae:	95 31       	cpi	r25, 0x15	; 21
    19b0:	88 f4       	brcc	.+34     	; 0x19d4 <main+0x3e0>
    19b2:	90 91 32 05 	lds	r25, 0x0532
    19b6:	96 31       	cpi	r25, 0x16	; 22
    19b8:	68 f0       	brcs	.+26     	; 0x19d4 <main+0x3e0>
			{
				flag=3;
    19ba:	83 e0       	ldi	r24, 0x03	; 3
    19bc:	90 e0       	ldi	r25, 0x00	; 0
    19be:	90 93 44 05 	sts	0x0544, r25
    19c2:	80 93 43 05 	sts	0x0543, r24
				forward();
    19c6:	0e 94 b1 06 	call	0xd62	; 0xd62 <_Z7forwardv>
				velocity(250,170);
    19ca:	8a ef       	ldi	r24, 0xFA	; 250
    19cc:	6a ea       	ldi	r22, 0xAA	; 170
    19ce:	0e 94 9e 06 	call	0xd3c	; 0xd3c <_Z8velocityhh>
    19d2:	9b ce       	rjmp	.-714    	; 0x170a <main+0x116>
			}
			else if((Center_white_line>0x15 && Left_white_line>0x15 && Right_white_line>0x15)||(Center_white_line>0x15 && Left_white_line>0x15 && Right_white_line<0x15)||(Center_white_line>0x15 && Left_white_line<0x15 && Right_white_line>0x15))
    19d4:	86 31       	cpi	r24, 0x16	; 22
    19d6:	08 f4       	brcc	.+2      	; 0x19da <main+0x3e6>
    19d8:	98 ce       	rjmp	.-720    	; 0x170a <main+0x116>
    19da:	80 91 34 05 	lds	r24, 0x0534
    19de:	86 31       	cpi	r24, 0x16	; 22
    19e0:	20 f0       	brcs	.+8      	; 0x19ea <main+0x3f6>
    19e2:	90 91 32 05 	lds	r25, 0x0532
    19e6:	95 31       	cpi	r25, 0x15	; 21
    19e8:	41 f4       	brne	.+16     	; 0x19fa <main+0x406>
    19ea:	85 31       	cpi	r24, 0x15	; 21
    19ec:	08 f0       	brcs	.+2      	; 0x19f0 <main+0x3fc>
    19ee:	8d ce       	rjmp	.-742    	; 0x170a <main+0x116>
    19f0:	80 91 32 05 	lds	r24, 0x0532
    19f4:	86 31       	cpi	r24, 0x16	; 22
    19f6:	08 f4       	brcc	.+2      	; 0x19fa <main+0x406>
    19f8:	88 ce       	rjmp	.-752    	; 0x170a <main+0x116>
			{
				flag=4;
    19fa:	10 93 44 05 	sts	0x0544, r17
    19fe:	00 93 43 05 	sts	0x0543, r16
				
				lcd_print(2,9,original[count],3);
    1a02:	80 91 49 05 	lds	r24, 0x0549
    1a06:	90 91 4a 05 	lds	r25, 0x054A
    1a0a:	88 0f       	add	r24, r24
    1a0c:	99 1f       	adc	r25, r25
    1a0e:	8e 0d       	add	r24, r14
    1a10:	9f 1d       	adc	r25, r15
    1a12:	fc 01       	movw	r30, r24
    1a14:	40 81       	ld	r20, Z
    1a16:	51 81       	ldd	r21, Z+1	; 0x01
    1a18:	82 e0       	ldi	r24, 0x02	; 2
    1a1a:	69 e0       	ldi	r22, 0x09	; 9
    1a1c:	23 e0       	ldi	r18, 0x03	; 3
    1a1e:	30 e0       	ldi	r19, 0x00	; 0
    1a20:	0e 94 ad 01 	call	0x35a	; 0x35a <_Z9lcd_printccji>
				if(path[count]==1)//it is left
    1a24:	20 91 49 05 	lds	r18, 0x0549
    1a28:	30 91 4a 05 	lds	r19, 0x054A
    1a2c:	c9 01       	movw	r24, r18
    1a2e:	88 0f       	add	r24, r24
    1a30:	99 1f       	adc	r25, r25
    1a32:	8a 0d       	add	r24, r10
    1a34:	9b 1d       	adc	r25, r11
    1a36:	dc 01       	movw	r26, r24
    1a38:	8d 91       	ld	r24, X+
    1a3a:	9c 91       	ld	r25, X
    1a3c:	11 97       	sbiw	r26, 0x01	; 1
    1a3e:	81 30       	cpi	r24, 0x01	; 1
    1a40:	91 05       	cpc	r25, r1
    1a42:	b1 f4       	brne	.+44     	; 0x1a70 <main+0x47c>
				{
					x+=path[count];
    1a44:	80 91 45 05 	lds	r24, 0x0545
    1a48:	90 91 46 05 	lds	r25, 0x0546
    1a4c:	01 96       	adiw	r24, 0x01	; 1
    1a4e:	90 93 46 05 	sts	0x0546, r25
    1a52:	80 93 45 05 	sts	0x0545, r24
					forward_mm(75); //Moves robot forward 100mm
    1a56:	8b e4       	ldi	r24, 0x4B	; 75
    1a58:	90 e0       	ldi	r25, 0x00	; 0
    1a5a:	0e 94 8c 07 	call	0xf18	; 0xf18 <_Z10forward_mmj>
					left_degrees(45); //Rotate robot left by 90 degrees
    1a5e:	8d e2       	ldi	r24, 0x2D	; 45
    1a60:	90 e0       	ldi	r25, 0x00	; 0
    1a62:	0e 94 a2 07 	call	0xf44	; 0xf44 <_Z12left_degreesj>
					left_count();
    1a66:	0e 94 05 08 	call	0x100a	; 0x100a <_Z10left_countv>
					stop();
    1a6a:	0e 94 d1 06 	call	0xda2	; 0xda2 <_Z4stopv>
    1a6e:	b9 c1       	rjmp	.+882    	; 0x1de2 <main+0x7ee>
					
					//j++;
				}
				else if(path[count]==4)//it is straight
    1a70:	84 30       	cpi	r24, 0x04	; 4
    1a72:	91 05       	cpc	r25, r1
    1a74:	71 f4       	brne	.+28     	; 0x1a92 <main+0x49e>
				{
					x+=path[count];
    1a76:	80 91 45 05 	lds	r24, 0x0545
    1a7a:	90 91 46 05 	lds	r25, 0x0546
    1a7e:	04 96       	adiw	r24, 0x04	; 4
    1a80:	90 93 46 05 	sts	0x0546, r25
    1a84:	80 93 45 05 	sts	0x0545, r24
					//j++;
					forward_mm(45); //Moves robot forward 100mm
    1a88:	8d e2       	ldi	r24, 0x2D	; 45
    1a8a:	90 e0       	ldi	r25, 0x00	; 0
    1a8c:	0e 94 8c 07 	call	0xf18	; 0xf18 <_Z10forward_mmj>
    1a90:	a8 c1       	rjmp	.+848    	; 0x1de2 <main+0x7ee>
					//align();
				}
				else if(path[count]==3)//it is right
    1a92:	83 30       	cpi	r24, 0x03	; 3
    1a94:	91 05       	cpc	r25, r1
    1a96:	b1 f4       	brne	.+44     	; 0x1ac4 <main+0x4d0>
				{
					x+=path[count];
    1a98:	80 91 45 05 	lds	r24, 0x0545
    1a9c:	90 91 46 05 	lds	r25, 0x0546
    1aa0:	03 96       	adiw	r24, 0x03	; 3
    1aa2:	90 93 46 05 	sts	0x0546, r25
    1aa6:	80 93 45 05 	sts	0x0545, r24
					forward_mm(75); //Moves robot forward 100mm
    1aaa:	8b e4       	ldi	r24, 0x4B	; 75
    1aac:	90 e0       	ldi	r25, 0x00	; 0
    1aae:	0e 94 8c 07 	call	0xf18	; 0xf18 <_Z10forward_mmj>
					right_degrees(45); //Rotate robot right by 90 degrees
    1ab2:	8d e2       	ldi	r24, 0x2D	; 45
    1ab4:	90 e0       	ldi	r25, 0x00	; 0
    1ab6:	0e 94 ad 07 	call	0xf5a	; 0xf5a <_Z13right_degreesj>
					right_count();
    1aba:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <_Z11right_countv>
					stop();
    1abe:	0e 94 d1 06 	call	0xda2	; 0xda2 <_Z4stopv>
    1ac2:	8f c1       	rjmp	.+798    	; 0x1de2 <main+0x7ee>
					//_delay_ms(1000);
				}
				else if(path[count]==2)//it is back
    1ac4:	82 30       	cpi	r24, 0x02	; 2
    1ac6:	91 05       	cpc	r25, r1
    1ac8:	a1 f4       	brne	.+40     	; 0x1af2 <main+0x4fe>
				{
					x+=path[count];
    1aca:	80 91 45 05 	lds	r24, 0x0545
    1ace:	90 91 46 05 	lds	r25, 0x0546
    1ad2:	02 96       	adiw	r24, 0x02	; 2
    1ad4:	90 93 46 05 	sts	0x0546, r25
    1ad8:	80 93 45 05 	sts	0x0545, r24
					forward_mm(75); //Moves robot forward 100mm
    1adc:	8b e4       	ldi	r24, 0x4B	; 75
    1ade:	90 e0       	ldi	r25, 0x00	; 0
    1ae0:	0e 94 8c 07 	call	0xf18	; 0xf18 <_Z10forward_mmj>
					right_degrees(130); //Rotate robot right by 90 degrees
    1ae4:	82 e8       	ldi	r24, 0x82	; 130
    1ae6:	90 e0       	ldi	r25, 0x00	; 0
    1ae8:	0e 94 ad 07 	call	0xf5a	; 0xf5a <_Z13right_degreesj>
					right_count();
    1aec:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <_Z11right_countv>
    1af0:	78 c1       	rjmp	.+752    	; 0x1de2 <main+0x7ee>
					//align();
				}
				else if(count==tot-1)//it is right
    1af2:	80 91 57 09 	lds	r24, 0x0957
    1af6:	90 91 58 09 	lds	r25, 0x0958
    1afa:	01 97       	sbiw	r24, 0x01	; 1
    1afc:	28 17       	cp	r18, r24
    1afe:	39 07       	cpc	r19, r25
    1b00:	09 f0       	breq	.+2      	; 0x1b04 <main+0x510>
    1b02:	6f c1       	rjmp	.+734    	; 0x1de2 <main+0x7ee>
    1b04:	eb 81       	ldd	r30, Y+3	; 0x03
    1b06:	fc 81       	ldd	r31, Y+4	; 0x04
    1b08:	28 e0       	ldi	r18, 0x08	; 8
    1b0a:	32 e0       	ldi	r19, 0x02	; 2
    1b0c:	a0 e8       	ldi	r26, 0x80	; 128
    1b0e:	b2 e0       	ldi	r27, 0x02	; 2
Input :       none
Output :      none
Logic:		  driver function to provide necessary medical services and call helper function appropriately
Example Call: -
*/
int main(void)
    1b10:	40 e0       	ldi	r20, 0x00	; 0
    1b12:	50 e0       	ldi	r21, 0x00	; 0
    1b14:	bf 01       	movw	r22, r30
    1b16:	13 c0       	rjmp	.+38     	; 0x1b3e <main+0x54a>
					//lcd_print(1,11,x,2);
					for(int i=0;i<16;i++)
					{
						for(int j=0;j<4;j++)
						{
							if(val[i][j]==sdest)
    1b18:	81 91       	ld	r24, Z+
    1b1a:	91 91       	ld	r25, Z+
    1b1c:	68 17       	cp	r22, r24
    1b1e:	79 07       	cpc	r23, r25
    1b20:	19 f4       	brne	.+6      	; 0x1b28 <main+0x534>
							search[i]=0;
    1b22:	11 96       	adiw	r26, 0x01	; 1
    1b24:	1c 92       	st	X, r1
    1b26:	1e 92       	st	-X, r1
				else if(count==tot-1)//it is right
				{
					//lcd_print(1,11,x,2);
					for(int i=0;i<16;i++)
					{
						for(int j=0;j<4;j++)
    1b28:	e2 17       	cp	r30, r18
    1b2a:	f3 07       	cpc	r31, r19
    1b2c:	a9 f7       	brne	.-22     	; 0x1b18 <main+0x524>
					//align();
				}
				else if(count==tot-1)//it is right
				{
					//lcd_print(1,11,x,2);
					for(int i=0;i<16;i++)
    1b2e:	4f 5f       	subi	r20, 0xFF	; 255
    1b30:	5f 4f       	sbci	r21, 0xFF	; 255
    1b32:	28 5f       	subi	r18, 0xF8	; 248
    1b34:	3f 4f       	sbci	r19, 0xFF	; 255
    1b36:	12 96       	adiw	r26, 0x02	; 2
    1b38:	40 31       	cpi	r20, 0x10	; 16
    1b3a:	51 05       	cpc	r21, r1
    1b3c:	51 f0       	breq	.+20     	; 0x1b52 <main+0x55e>
Input :       none
Output :      none
Logic:		  driver function to provide necessary medical services and call helper function appropriately
Example Call: -
*/
int main(void)
    1b3e:	fa 01       	movw	r30, r20
    1b40:	ee 0f       	add	r30, r30
    1b42:	ff 1f       	adc	r31, r31
    1b44:	ee 0f       	add	r30, r30
    1b46:	ff 1f       	adc	r31, r31
    1b48:	ee 0f       	add	r30, r30
    1b4a:	ff 1f       	adc	r31, r31
    1b4c:	e0 50       	subi	r30, 0x00	; 0
    1b4e:	fe 4f       	sbci	r31, 0xFE	; 254
    1b50:	e3 cf       	rjmp	.-58     	; 0x1b18 <main+0x524>
							search[i]=0;
						}
					}
					
					
					stop();
    1b52:	0e 94 d1 06 	call	0xda2	; 0xda2 <_Z4stopv>
					forward_mm(75); //Moves robot forward 100mm
    1b56:	8b e4       	ldi	r24, 0x4B	; 75
    1b58:	90 e0       	ldi	r25, 0x00	; 0
    1b5a:	0e 94 8c 07 	call	0xf18	; 0xf18 <_Z10forward_mmj>
					
					if(k>1 && j!=2)
    1b5e:	f2 e0       	ldi	r31, 0x02	; 2
    1b60:	8f 16       	cp	r8, r31
    1b62:	91 04       	cpc	r9, r1
    1b64:	0c f4       	brge	.+2      	; 0x1b68 <main+0x574>
    1b66:	c1 c0       	rjmp	.+386    	; 0x1cea <main+0x6f6>
    1b68:	80 91 69 05 	lds	r24, 0x0569
    1b6c:	90 91 6a 05 	lds	r25, 0x056A
    1b70:	82 30       	cpi	r24, 0x02	; 2
    1b72:	91 05       	cpc	r25, r1
    1b74:	09 f4       	brne	.+2      	; 0x1b78 <main+0x584>
    1b76:	b9 c0       	rjmp	.+370    	; 0x1cea <main+0x6f6>
					{
						data=150;
    1b78:	86 e9       	ldi	r24, 0x96	; 150
    1b7a:	90 e0       	ldi	r25, 0x00	; 0
    1b7c:	90 93 6e 05 	sts	0x056E, r25
    1b80:	80 93 6d 05 	sts	0x056D, r24
						lcd_print(1,1,data,3);
    1b84:	81 e0       	ldi	r24, 0x01	; 1
    1b86:	61 e0       	ldi	r22, 0x01	; 1
    1b88:	46 e9       	ldi	r20, 0x96	; 150
    1b8a:	50 e0       	ldi	r21, 0x00	; 0
    1b8c:	23 e0       	ldi	r18, 0x03	; 3
    1b8e:	30 e0       	ldi	r19, 0x00	; 0
    1b90:	0e 94 ad 01 	call	0x35a	; 0x35a <_Z9lcd_printccji>
						UDR0=data;
    1b94:	d1 01       	movw	r26, r2
    1b96:	8c 91       	ld	r24, X
    1b98:	e6 ec       	ldi	r30, 0xC6	; 198
    1b9a:	f0 e0       	ldi	r31, 0x00	; 0
    1b9c:	80 83       	st	Z, r24
    1b9e:	8f ef       	ldi	r24, 0xFF	; 255
    1ba0:	9f ef       	ldi	r25, 0xFF	; 255
    1ba2:	ac e2       	ldi	r26, 0x2C	; 44
    1ba4:	81 50       	subi	r24, 0x01	; 1
    1ba6:	90 40       	sbci	r25, 0x00	; 0
    1ba8:	a0 40       	sbci	r26, 0x00	; 0
    1baa:	e1 f7       	brne	.-8      	; 0x1ba4 <main+0x5b0>
    1bac:	00 c0       	rjmp	.+0      	; 0x1bae <main+0x5ba>
    1bae:	00 00       	nop
						_delay_ms(1000);
						UDR0=via;
    1bb0:	a1 e4       	ldi	r26, 0x41	; 65
    1bb2:	b5 e0       	ldi	r27, 0x05	; 5
    1bb4:	8c 91       	ld	r24, X
    1bb6:	80 83       	st	Z, r24
    1bb8:	8f ef       	ldi	r24, 0xFF	; 255
    1bba:	9f e7       	ldi	r25, 0x7F	; 127
    1bbc:	a4 e0       	ldi	r26, 0x04	; 4
    1bbe:	81 50       	subi	r24, 0x01	; 1
    1bc0:	90 40       	sbci	r25, 0x00	; 0
    1bc2:	a0 40       	sbci	r26, 0x00	; 0
    1bc4:	e1 f7       	brne	.-8      	; 0x1bbe <main+0x5ca>
    1bc6:	00 c0       	rjmp	.+0      	; 0x1bc8 <main+0x5d4>
    1bc8:	00 00       	nop
						
						//lcd_print(1,1,via,3);
						_delay_ms(100);
						UDR0=dest;
    1bca:	af e3       	ldi	r26, 0x3F	; 63
    1bcc:	b5 e0       	ldi	r27, 0x05	; 5
    1bce:	8c 91       	ld	r24, X
    1bd0:	80 83       	st	Z, r24
    1bd2:	8f ef       	ldi	r24, 0xFF	; 255
    1bd4:	9f e7       	ldi	r25, 0x7F	; 127
    1bd6:	a4 e0       	ldi	r26, 0x04	; 4
    1bd8:	81 50       	subi	r24, 0x01	; 1
    1bda:	90 40       	sbci	r25, 0x00	; 0
    1bdc:	a0 40       	sbci	r26, 0x00	; 0
    1bde:	e1 f7       	brne	.-8      	; 0x1bd8 <main+0x5e4>
    1be0:	00 c0       	rjmp	.+0      	; 0x1be2 <main+0x5ee>
    1be2:	00 00       	nop
						//lcd_print(1,1,dest,3);
						_delay_ms(100);
						UDR0=angle1;
    1be4:	a9 e3       	ldi	r26, 0x39	; 57
    1be6:	b5 e0       	ldi	r27, 0x05	; 5
    1be8:	8c 91       	ld	r24, X
    1bea:	80 83       	st	Z, r24
    1bec:	8f ef       	ldi	r24, 0xFF	; 255
    1bee:	9f e7       	ldi	r25, 0x7F	; 127
    1bf0:	a4 e0       	ldi	r26, 0x04	; 4
    1bf2:	81 50       	subi	r24, 0x01	; 1
    1bf4:	90 40       	sbci	r25, 0x00	; 0
    1bf6:	a0 40       	sbci	r26, 0x00	; 0
    1bf8:	e1 f7       	brne	.-8      	; 0x1bf2 <main+0x5fe>
    1bfa:	00 c0       	rjmp	.+0      	; 0x1bfc <main+0x608>
    1bfc:	00 00       	nop
						
						_delay_ms(100);
						UDR0=color1;
    1bfe:	ad e3       	ldi	r26, 0x3D	; 61
    1c00:	b5 e0       	ldi	r27, 0x05	; 5
    1c02:	8c 91       	ld	r24, X
    1c04:	80 83       	st	Z, r24
    1c06:	8f ef       	ldi	r24, 0xFF	; 255
    1c08:	9f e7       	ldi	r25, 0x7F	; 127
    1c0a:	a4 e0       	ldi	r26, 0x04	; 4
    1c0c:	81 50       	subi	r24, 0x01	; 1
    1c0e:	90 40       	sbci	r25, 0x00	; 0
    1c10:	a0 40       	sbci	r26, 0x00	; 0
    1c12:	e1 f7       	brne	.-8      	; 0x1c0c <main+0x618>
    1c14:	00 c0       	rjmp	.+0      	; 0x1c16 <main+0x622>
    1c16:	00 00       	nop
						_delay_ms(100);
						UDR0=angle2;
    1c18:	a7 e3       	ldi	r26, 0x37	; 55
    1c1a:	b5 e0       	ldi	r27, 0x05	; 5
    1c1c:	8c 91       	ld	r24, X
    1c1e:	80 83       	st	Z, r24
    1c20:	8f ef       	ldi	r24, 0xFF	; 255
    1c22:	9f e7       	ldi	r25, 0x7F	; 127
    1c24:	a4 e0       	ldi	r26, 0x04	; 4
    1c26:	81 50       	subi	r24, 0x01	; 1
    1c28:	90 40       	sbci	r25, 0x00	; 0
    1c2a:	a0 40       	sbci	r26, 0x00	; 0
    1c2c:	e1 f7       	brne	.-8      	; 0x1c26 <main+0x632>
    1c2e:	00 c0       	rjmp	.+0      	; 0x1c30 <main+0x63c>
    1c30:	00 00       	nop
						_delay_ms(100);
						UDR0=color2;
    1c32:	80 91 3b 05 	lds	r24, 0x053B
    1c36:	80 83       	st	Z, r24
    1c38:	8f ef       	ldi	r24, 0xFF	; 255
    1c3a:	9f e7       	ldi	r25, 0x7F	; 127
    1c3c:	a4 e0       	ldi	r26, 0x04	; 4
    1c3e:	81 50       	subi	r24, 0x01	; 1
    1c40:	90 40       	sbci	r25, 0x00	; 0
    1c42:	a0 40       	sbci	r26, 0x00	; 0
    1c44:	e1 f7       	brne	.-8      	; 0x1c3e <main+0x64a>
    1c46:	00 c0       	rjmp	.+0      	; 0x1c48 <main+0x654>
    1c48:	00 00       	nop
						_delay_ms(100);
						UDR0=sdest;
    1c4a:	c0 82       	st	Z, r12
    1c4c:	8f ef       	ldi	r24, 0xFF	; 255
    1c4e:	9f e7       	ldi	r25, 0x7F	; 127
    1c50:	a4 e0       	ldi	r26, 0x04	; 4
    1c52:	81 50       	subi	r24, 0x01	; 1
    1c54:	90 40       	sbci	r25, 0x00	; 0
    1c56:	a0 40       	sbci	r26, 0x00	; 0
    1c58:	e1 f7       	brne	.-8      	; 0x1c52 <main+0x65e>
    1c5a:	00 c0       	rjmp	.+0      	; 0x1c5c <main+0x668>
    1c5c:	00 00       	nop
						_delay_ms(100);
						data=200;
    1c5e:	88 ec       	ldi	r24, 0xC8	; 200
    1c60:	90 e0       	ldi	r25, 0x00	; 0
    1c62:	90 93 6e 05 	sts	0x056E, r25
    1c66:	80 93 6d 05 	sts	0x056D, r24
						UDR0=data;
    1c6a:	88 ec       	ldi	r24, 0xC8	; 200
    1c6c:	80 83       	st	Z, r24
    1c6e:	8f ef       	ldi	r24, 0xFF	; 255
    1c70:	9f ef       	ldi	r25, 0xFF	; 255
    1c72:	ac e2       	ldi	r26, 0x2C	; 44
    1c74:	81 50       	subi	r24, 0x01	; 1
    1c76:	90 40       	sbci	r25, 0x00	; 0
    1c78:	a0 40       	sbci	r26, 0x00	; 0
    1c7a:	e1 f7       	brne	.-8      	; 0x1c74 <main+0x680>
    1c7c:	00 c0       	rjmp	.+0      	; 0x1c7e <main+0x68a>
    1c7e:	00 00       	nop
						_delay_ms(1000);
						while(rec!=200)
    1c80:	80 91 6b 05 	lds	r24, 0x056B
    1c84:	90 91 6c 05 	lds	r25, 0x056C
    1c88:	88 3c       	cpi	r24, 0xC8	; 200
    1c8a:	91 05       	cpc	r25, r1
    1c8c:	e1 f0       	breq	.+56     	; 0x1cc6 <main+0x6d2>
    1c8e:	09 81       	ldd	r16, Y+1	; 0x01
    1c90:	1a 81       	ldd	r17, Y+2	; 0x02
						{
							stop();
    1c92:	0e 94 d1 06 	call	0xda2	; 0xda2 <_Z4stopv>
    1c96:	af ef       	ldi	r26, 0xFF	; 255
    1c98:	bf e8       	ldi	r27, 0x8F	; 143
    1c9a:	11 97       	sbiw	r26, 0x01	; 1
    1c9c:	f1 f7       	brne	.-4      	; 0x1c9a <main+0x6a6>
    1c9e:	00 c0       	rjmp	.+0      	; 0x1ca0 <main+0x6ac>
    1ca0:	00 00       	nop
							_delay_ms(10);
							lcd_print(1,1,t,3);
    1ca2:	81 e0       	ldi	r24, 0x01	; 1
    1ca4:	61 e0       	ldi	r22, 0x01	; 1
    1ca6:	a8 01       	movw	r20, r16
    1ca8:	23 e0       	ldi	r18, 0x03	; 3
    1caa:	30 e0       	ldi	r19, 0x00	; 0
    1cac:	0e 94 ad 01 	call	0x35a	; 0x35a <_Z9lcd_printccji>
							t=t+1;
    1cb0:	0f 5f       	subi	r16, 0xFF	; 255
    1cb2:	1f 4f       	sbci	r17, 0xFF	; 255
						UDR0=sdest;
						_delay_ms(100);
						data=200;
						UDR0=data;
						_delay_ms(1000);
						while(rec!=200)
    1cb4:	80 91 6b 05 	lds	r24, 0x056B
    1cb8:	90 91 6c 05 	lds	r25, 0x056C
    1cbc:	88 3c       	cpi	r24, 0xC8	; 200
    1cbe:	91 05       	cpc	r25, r1
    1cc0:	41 f7       	brne	.-48     	; 0x1c92 <main+0x69e>
    1cc2:	1a 83       	std	Y+2, r17	; 0x02
    1cc4:	09 83       	std	Y+1, r16	; 0x01
							stop();
							_delay_ms(10);
							lcd_print(1,1,t,3);
							t=t+1;
						}
						data=250;
    1cc6:	8a ef       	ldi	r24, 0xFA	; 250
    1cc8:	90 e0       	ldi	r25, 0x00	; 0
    1cca:	90 93 6e 05 	sts	0x056E, r25
    1cce:	80 93 6d 05 	sts	0x056D, r24
						UDR0=data;
    1cd2:	8a ef       	ldi	r24, 0xFA	; 250
    1cd4:	80 93 c6 00 	sts	0x00C6, r24
    1cd8:	8f ef       	ldi	r24, 0xFF	; 255
    1cda:	9f e7       	ldi	r25, 0x7F	; 127
    1cdc:	a4 e0       	ldi	r26, 0x04	; 4
    1cde:	81 50       	subi	r24, 0x01	; 1
    1ce0:	90 40       	sbci	r25, 0x00	; 0
    1ce2:	a0 40       	sbci	r26, 0x00	; 0
    1ce4:	e1 f7       	brne	.-8      	; 0x1cde <main+0x6ea>
    1ce6:	00 c0       	rjmp	.+0      	; 0x1ce8 <main+0x6f4>
    1ce8:	00 00       	nop
						_delay_ms(100);
					}
					if(sdest==49)
    1cea:	91 e3       	ldi	r25, 0x31	; 49
    1cec:	c9 16       	cp	r12, r25
    1cee:	d1 04       	cpc	r13, r1
    1cf0:	b9 f4       	brne	.+46     	; 0x1d20 <main+0x72c>
					{
						stop();
    1cf2:	0e 94 d1 06 	call	0xda2	; 0xda2 <_Z4stopv>
						data=149;
    1cf6:	85 e9       	ldi	r24, 0x95	; 149
    1cf8:	90 e0       	ldi	r25, 0x00	; 0
    1cfa:	90 93 6e 05 	sts	0x056E, r25
    1cfe:	80 93 6d 05 	sts	0x056D, r24
						UDR0=data;
    1d02:	85 e9       	ldi	r24, 0x95	; 149
    1d04:	80 93 c6 00 	sts	0x00C6, r24
    1d08:	8f ef       	ldi	r24, 0xFF	; 255
    1d0a:	9f ef       	ldi	r25, 0xFF	; 255
    1d0c:	a6 e7       	ldi	r26, 0x76	; 118
    1d0e:	b1 e0       	ldi	r27, 0x01	; 1
    1d10:	81 50       	subi	r24, 0x01	; 1
    1d12:	90 40       	sbci	r25, 0x00	; 0
    1d14:	a0 40       	sbci	r26, 0x00	; 0
    1d16:	b0 40       	sbci	r27, 0x00	; 0
    1d18:	d9 f7       	brne	.-10     	; 0x1d10 <main+0x71c>
    1d1a:	00 c0       	rjmp	.+0      	; 0x1d1c <main+0x728>
    1d1c:	00 00       	nop
						_delay_ms(10000);
						return 0;
    1d1e:	73 c0       	rjmp	.+230    	; 0x1e06 <main+0x812>
					}
					
					via=dest=color1=color2=angle1=angle2=deb=j=0;
    1d20:	10 92 6a 05 	sts	0x056A, r1
    1d24:	10 92 69 05 	sts	0x0569, r1
    1d28:	10 92 36 05 	sts	0x0536, r1
    1d2c:	10 92 35 05 	sts	0x0535, r1
    1d30:	10 92 38 05 	sts	0x0538, r1
    1d34:	10 92 37 05 	sts	0x0537, r1
    1d38:	10 92 3a 05 	sts	0x053A, r1
    1d3c:	10 92 39 05 	sts	0x0539, r1
    1d40:	10 92 3c 05 	sts	0x053C, r1
    1d44:	10 92 3b 05 	sts	0x053B, r1
    1d48:	10 92 3e 05 	sts	0x053E, r1
    1d4c:	10 92 3d 05 	sts	0x053D, r1
					via=original[count-1];
    1d50:	80 91 49 05 	lds	r24, 0x0549
    1d54:	90 91 4a 05 	lds	r25, 0x054A
    1d58:	01 97       	sbiw	r24, 0x01	; 1
    1d5a:	88 0f       	add	r24, r24
    1d5c:	99 1f       	adc	r25, r25
    1d5e:	8e 0d       	add	r24, r14
    1d60:	9f 1d       	adc	r25, r15
    1d62:	dc 01       	movw	r26, r24
    1d64:	8d 91       	ld	r24, X+
    1d66:	9c 91       	ld	r25, X
    1d68:	90 93 42 05 	sts	0x0542, r25
    1d6c:	80 93 41 05 	sts	0x0541, r24
					dest=sdest;
    1d70:	d0 92 40 05 	sts	0x0540, r13
    1d74:	c0 92 3f 05 	sts	0x053F, r12
					
					servo_1(0);
    1d78:	80 e0       	ldi	r24, 0x00	; 0
    1d7a:	0e 94 38 08 	call	0x1070	; 0x1070 <_Z7servo_1h>
					servo_2(90);
    1d7e:	8a e5       	ldi	r24, 0x5A	; 90
    1d80:	0e 94 ec 07 	call	0xfd8	; 0xfd8 <_Z7servo_2h>
					//box=0;
					//_delay_ms(3000);
					right_angle_rotate(110);
    1d84:	8e e6       	ldi	r24, 0x6E	; 110
    1d86:	90 e0       	ldi	r25, 0x00	; 0
    1d88:	0e 94 5f 09 	call	0x12be	; 0x12be <_Z18right_angle_rotatej>
					stop();
    1d8c:	0e 94 d1 06 	call	0xda2	; 0xda2 <_Z4stopv>
					servo_1(0);
    1d90:	80 e0       	ldi	r24, 0x00	; 0
    1d92:	0e 94 38 08 	call	0x1070	; 0x1070 <_Z7servo_1h>
					left_degrees(50);
    1d96:	82 e3       	ldi	r24, 0x32	; 50
    1d98:	90 e0       	ldi	r25, 0x00	; 0
    1d9a:	0e 94 a2 07 	call	0xf44	; 0xf44 <_Z12left_degreesj>
					stop();
    1d9e:	0e 94 d1 06 	call	0xda2	; 0xda2 <_Z4stopv>
					left_angle_rotate(180);
    1da2:	84 eb       	ldi	r24, 0xB4	; 180
    1da4:	90 e0       	ldi	r25, 0x00	; 0
    1da6:	0e 94 cc 08 	call	0x1198	; 0x1198 <_Z17left_angle_rotatej>
					stop();
    1daa:	0e 94 d1 06 	call	0xda2	; 0xda2 <_Z4stopv>
					
					servo_1(0);
    1dae:	80 e0       	ldi	r24, 0x00	; 0
    1db0:	0e 94 38 08 	call	0x1070	; 0x1070 <_Z7servo_1h>
					right_degrees(30);
    1db4:	8e e1       	ldi	r24, 0x1E	; 30
    1db6:	90 e0       	ldi	r25, 0x00	; 0
    1db8:	0e 94 ad 07 	call	0xf5a	; 0xf5a <_Z13right_degreesj>
					servo_2_rest();
    1dbc:	0e 94 55 08 	call	0x10aa	; 0x10aa <_Z12servo_2_restv>
    1dc0:	8f ef       	ldi	r24, 0xFF	; 255
    1dc2:	9f ef       	ldi	r25, 0xFF	; 255
    1dc4:	ac e2       	ldi	r26, 0x2C	; 44
    1dc6:	81 50       	subi	r24, 0x01	; 1
    1dc8:	90 40       	sbci	r25, 0x00	; 0
    1dca:	a0 40       	sbci	r26, 0x00	; 0
    1dcc:	e1 f7       	brne	.-8      	; 0x1dc6 <main+0x7d2>
    1dce:	00 c0       	rjmp	.+0      	; 0x1dd0 <main+0x7dc>
    1dd0:	00 00       	nop
					_delay_ms(1000);
					servo_1_rest();
    1dd2:	0e 94 51 08 	call	0x10a2	; 0x10a2 <_Z12servo_1_restv>
					
					right_count();
    1dd6:	0e 94 f9 09 	call	0x13f2	; 0x13f2 <_Z11right_countv>
					stop();
    1dda:	0e 94 d1 06 	call	0xda2	; 0xda2 <_Z4stopv>
					current=destination;
    1dde:	86 01       	movw	r16, r12
					//makeitright(x);
					break;
    1de0:	0a c0       	rjmp	.+20     	; 0x1df6 <main+0x802>
					
				}
				count++;
    1de2:	80 91 49 05 	lds	r24, 0x0549
    1de6:	90 91 4a 05 	lds	r25, 0x054A
    1dea:	01 96       	adiw	r24, 0x01	; 1
    1dec:	90 93 4a 05 	sts	0x054A, r25
    1df0:	80 93 49 05 	sts	0x0549, r24
    1df4:	8a cc       	rjmp	.-1772   	; 0x170a <main+0x116>
	UDR0=data;
	flag=4;
	x=0;
	int etc=0,sdest=0,t=0,destination=0;
	unsigned int current=49;
	for(int k=0;k<100;k++,etc++)
    1df6:	08 94       	sec
    1df8:	81 1c       	adc	r8, r1
    1dfa:	91 1c       	adc	r9, r1
    1dfc:	94 e6       	ldi	r25, 0x64	; 100
    1dfe:	89 16       	cp	r8, r25
    1e00:	91 04       	cpc	r9, r1
    1e02:	09 f0       	breq	.+2      	; 0x1e06 <main+0x812>
    1e04:	46 cc       	rjmp	.-1908   	; 0x1692 <main+0x9e>
		
		
	}
	

    1e06:	80 e0       	ldi	r24, 0x00	; 0
    1e08:	90 e0       	ldi	r25, 0x00	; 0
    1e0a:	0f 90       	pop	r0
    1e0c:	0f 90       	pop	r0
    1e0e:	0f 90       	pop	r0
    1e10:	0f 90       	pop	r0
    1e12:	df 91       	pop	r29
    1e14:	cf 91       	pop	r28
    1e16:	1f 91       	pop	r17
    1e18:	0f 91       	pop	r16
    1e1a:	ff 90       	pop	r15
    1e1c:	ef 90       	pop	r14
    1e1e:	df 90       	pop	r13
    1e20:	cf 90       	pop	r12
    1e22:	bf 90       	pop	r11
    1e24:	af 90       	pop	r10
    1e26:	9f 90       	pop	r9
    1e28:	8f 90       	pop	r8
    1e2a:	7f 90       	pop	r7
    1e2c:	6f 90       	pop	r6
    1e2e:	5f 90       	pop	r5
    1e30:	4f 90       	pop	r4
    1e32:	3f 90       	pop	r3
    1e34:	2f 90       	pop	r2
    1e36:	08 95       	ret

00001e38 <__subsf3>:
    1e38:	50 58       	subi	r21, 0x80	; 128

00001e3a <__addsf3>:
    1e3a:	bb 27       	eor	r27, r27
    1e3c:	aa 27       	eor	r26, r26
    1e3e:	0e d0       	rcall	.+28     	; 0x1e5c <__addsf3x>
    1e40:	4d c1       	rjmp	.+666    	; 0x20dc <__fp_round>
    1e42:	3e d1       	rcall	.+636    	; 0x20c0 <__fp_pscA>
    1e44:	30 f0       	brcs	.+12     	; 0x1e52 <__addsf3+0x18>
    1e46:	43 d1       	rcall	.+646    	; 0x20ce <__fp_pscB>
    1e48:	20 f0       	brcs	.+8      	; 0x1e52 <__addsf3+0x18>
    1e4a:	31 f4       	brne	.+12     	; 0x1e58 <__addsf3+0x1e>
    1e4c:	9f 3f       	cpi	r25, 0xFF	; 255
    1e4e:	11 f4       	brne	.+4      	; 0x1e54 <__addsf3+0x1a>
    1e50:	1e f4       	brtc	.+6      	; 0x1e58 <__addsf3+0x1e>
    1e52:	33 c1       	rjmp	.+614    	; 0x20ba <__fp_nan>
    1e54:	0e f4       	brtc	.+2      	; 0x1e58 <__addsf3+0x1e>
    1e56:	e0 95       	com	r30
    1e58:	e7 fb       	bst	r30, 7
    1e5a:	29 c1       	rjmp	.+594    	; 0x20ae <__fp_inf>

00001e5c <__addsf3x>:
    1e5c:	e9 2f       	mov	r30, r25
    1e5e:	4f d1       	rcall	.+670    	; 0x20fe <__fp_split3>
    1e60:	80 f3       	brcs	.-32     	; 0x1e42 <__addsf3+0x8>
    1e62:	ba 17       	cp	r27, r26
    1e64:	62 07       	cpc	r22, r18
    1e66:	73 07       	cpc	r23, r19
    1e68:	84 07       	cpc	r24, r20
    1e6a:	95 07       	cpc	r25, r21
    1e6c:	18 f0       	brcs	.+6      	; 0x1e74 <__addsf3x+0x18>
    1e6e:	71 f4       	brne	.+28     	; 0x1e8c <__addsf3x+0x30>
    1e70:	9e f5       	brtc	.+102    	; 0x1ed8 <__addsf3x+0x7c>
    1e72:	67 c1       	rjmp	.+718    	; 0x2142 <__fp_zero>
    1e74:	0e f4       	brtc	.+2      	; 0x1e78 <__addsf3x+0x1c>
    1e76:	e0 95       	com	r30
    1e78:	0b 2e       	mov	r0, r27
    1e7a:	ba 2f       	mov	r27, r26
    1e7c:	a0 2d       	mov	r26, r0
    1e7e:	0b 01       	movw	r0, r22
    1e80:	b9 01       	movw	r22, r18
    1e82:	90 01       	movw	r18, r0
    1e84:	0c 01       	movw	r0, r24
    1e86:	ca 01       	movw	r24, r20
    1e88:	a0 01       	movw	r20, r0
    1e8a:	11 24       	eor	r1, r1
    1e8c:	ff 27       	eor	r31, r31
    1e8e:	59 1b       	sub	r21, r25
    1e90:	99 f0       	breq	.+38     	; 0x1eb8 <__addsf3x+0x5c>
    1e92:	59 3f       	cpi	r21, 0xF9	; 249
    1e94:	50 f4       	brcc	.+20     	; 0x1eaa <__addsf3x+0x4e>
    1e96:	50 3e       	cpi	r21, 0xE0	; 224
    1e98:	68 f1       	brcs	.+90     	; 0x1ef4 <__addsf3x+0x98>
    1e9a:	1a 16       	cp	r1, r26
    1e9c:	f0 40       	sbci	r31, 0x00	; 0
    1e9e:	a2 2f       	mov	r26, r18
    1ea0:	23 2f       	mov	r18, r19
    1ea2:	34 2f       	mov	r19, r20
    1ea4:	44 27       	eor	r20, r20
    1ea6:	58 5f       	subi	r21, 0xF8	; 248
    1ea8:	f3 cf       	rjmp	.-26     	; 0x1e90 <__addsf3x+0x34>
    1eaa:	46 95       	lsr	r20
    1eac:	37 95       	ror	r19
    1eae:	27 95       	ror	r18
    1eb0:	a7 95       	ror	r26
    1eb2:	f0 40       	sbci	r31, 0x00	; 0
    1eb4:	53 95       	inc	r21
    1eb6:	c9 f7       	brne	.-14     	; 0x1eaa <__addsf3x+0x4e>
    1eb8:	7e f4       	brtc	.+30     	; 0x1ed8 <__addsf3x+0x7c>
    1eba:	1f 16       	cp	r1, r31
    1ebc:	ba 0b       	sbc	r27, r26
    1ebe:	62 0b       	sbc	r22, r18
    1ec0:	73 0b       	sbc	r23, r19
    1ec2:	84 0b       	sbc	r24, r20
    1ec4:	ba f0       	brmi	.+46     	; 0x1ef4 <__addsf3x+0x98>
    1ec6:	91 50       	subi	r25, 0x01	; 1
    1ec8:	a1 f0       	breq	.+40     	; 0x1ef2 <__addsf3x+0x96>
    1eca:	ff 0f       	add	r31, r31
    1ecc:	bb 1f       	adc	r27, r27
    1ece:	66 1f       	adc	r22, r22
    1ed0:	77 1f       	adc	r23, r23
    1ed2:	88 1f       	adc	r24, r24
    1ed4:	c2 f7       	brpl	.-16     	; 0x1ec6 <__addsf3x+0x6a>
    1ed6:	0e c0       	rjmp	.+28     	; 0x1ef4 <__addsf3x+0x98>
    1ed8:	ba 0f       	add	r27, r26
    1eda:	62 1f       	adc	r22, r18
    1edc:	73 1f       	adc	r23, r19
    1ede:	84 1f       	adc	r24, r20
    1ee0:	48 f4       	brcc	.+18     	; 0x1ef4 <__addsf3x+0x98>
    1ee2:	87 95       	ror	r24
    1ee4:	77 95       	ror	r23
    1ee6:	67 95       	ror	r22
    1ee8:	b7 95       	ror	r27
    1eea:	f7 95       	ror	r31
    1eec:	9e 3f       	cpi	r25, 0xFE	; 254
    1eee:	08 f0       	brcs	.+2      	; 0x1ef2 <__addsf3x+0x96>
    1ef0:	b3 cf       	rjmp	.-154    	; 0x1e58 <__addsf3+0x1e>
    1ef2:	93 95       	inc	r25
    1ef4:	88 0f       	add	r24, r24
    1ef6:	08 f0       	brcs	.+2      	; 0x1efa <__addsf3x+0x9e>
    1ef8:	99 27       	eor	r25, r25
    1efa:	ee 0f       	add	r30, r30
    1efc:	97 95       	ror	r25
    1efe:	87 95       	ror	r24
    1f00:	08 95       	ret

00001f02 <__divsf3>:
    1f02:	0c d0       	rcall	.+24     	; 0x1f1c <__divsf3x>
    1f04:	eb c0       	rjmp	.+470    	; 0x20dc <__fp_round>
    1f06:	e3 d0       	rcall	.+454    	; 0x20ce <__fp_pscB>
    1f08:	40 f0       	brcs	.+16     	; 0x1f1a <__divsf3+0x18>
    1f0a:	da d0       	rcall	.+436    	; 0x20c0 <__fp_pscA>
    1f0c:	30 f0       	brcs	.+12     	; 0x1f1a <__divsf3+0x18>
    1f0e:	21 f4       	brne	.+8      	; 0x1f18 <__divsf3+0x16>
    1f10:	5f 3f       	cpi	r21, 0xFF	; 255
    1f12:	19 f0       	breq	.+6      	; 0x1f1a <__divsf3+0x18>
    1f14:	cc c0       	rjmp	.+408    	; 0x20ae <__fp_inf>
    1f16:	51 11       	cpse	r21, r1
    1f18:	15 c1       	rjmp	.+554    	; 0x2144 <__fp_szero>
    1f1a:	cf c0       	rjmp	.+414    	; 0x20ba <__fp_nan>

00001f1c <__divsf3x>:
    1f1c:	f0 d0       	rcall	.+480    	; 0x20fe <__fp_split3>
    1f1e:	98 f3       	brcs	.-26     	; 0x1f06 <__divsf3+0x4>

00001f20 <__divsf3_pse>:
    1f20:	99 23       	and	r25, r25
    1f22:	c9 f3       	breq	.-14     	; 0x1f16 <__divsf3+0x14>
    1f24:	55 23       	and	r21, r21
    1f26:	b1 f3       	breq	.-20     	; 0x1f14 <__divsf3+0x12>
    1f28:	95 1b       	sub	r25, r21
    1f2a:	55 0b       	sbc	r21, r21
    1f2c:	bb 27       	eor	r27, r27
    1f2e:	aa 27       	eor	r26, r26
    1f30:	62 17       	cp	r22, r18
    1f32:	73 07       	cpc	r23, r19
    1f34:	84 07       	cpc	r24, r20
    1f36:	38 f0       	brcs	.+14     	; 0x1f46 <__divsf3_pse+0x26>
    1f38:	9f 5f       	subi	r25, 0xFF	; 255
    1f3a:	5f 4f       	sbci	r21, 0xFF	; 255
    1f3c:	22 0f       	add	r18, r18
    1f3e:	33 1f       	adc	r19, r19
    1f40:	44 1f       	adc	r20, r20
    1f42:	aa 1f       	adc	r26, r26
    1f44:	a9 f3       	breq	.-22     	; 0x1f30 <__divsf3_pse+0x10>
    1f46:	33 d0       	rcall	.+102    	; 0x1fae <__divsf3_pse+0x8e>
    1f48:	0e 2e       	mov	r0, r30
    1f4a:	3a f0       	brmi	.+14     	; 0x1f5a <__divsf3_pse+0x3a>
    1f4c:	e0 e8       	ldi	r30, 0x80	; 128
    1f4e:	30 d0       	rcall	.+96     	; 0x1fb0 <__divsf3_pse+0x90>
    1f50:	91 50       	subi	r25, 0x01	; 1
    1f52:	50 40       	sbci	r21, 0x00	; 0
    1f54:	e6 95       	lsr	r30
    1f56:	00 1c       	adc	r0, r0
    1f58:	ca f7       	brpl	.-14     	; 0x1f4c <__divsf3_pse+0x2c>
    1f5a:	29 d0       	rcall	.+82     	; 0x1fae <__divsf3_pse+0x8e>
    1f5c:	fe 2f       	mov	r31, r30
    1f5e:	27 d0       	rcall	.+78     	; 0x1fae <__divsf3_pse+0x8e>
    1f60:	66 0f       	add	r22, r22
    1f62:	77 1f       	adc	r23, r23
    1f64:	88 1f       	adc	r24, r24
    1f66:	bb 1f       	adc	r27, r27
    1f68:	26 17       	cp	r18, r22
    1f6a:	37 07       	cpc	r19, r23
    1f6c:	48 07       	cpc	r20, r24
    1f6e:	ab 07       	cpc	r26, r27
    1f70:	b0 e8       	ldi	r27, 0x80	; 128
    1f72:	09 f0       	breq	.+2      	; 0x1f76 <__divsf3_pse+0x56>
    1f74:	bb 0b       	sbc	r27, r27
    1f76:	80 2d       	mov	r24, r0
    1f78:	bf 01       	movw	r22, r30
    1f7a:	ff 27       	eor	r31, r31
    1f7c:	93 58       	subi	r25, 0x83	; 131
    1f7e:	5f 4f       	sbci	r21, 0xFF	; 255
    1f80:	2a f0       	brmi	.+10     	; 0x1f8c <__divsf3_pse+0x6c>
    1f82:	9e 3f       	cpi	r25, 0xFE	; 254
    1f84:	51 05       	cpc	r21, r1
    1f86:	68 f0       	brcs	.+26     	; 0x1fa2 <__divsf3_pse+0x82>
    1f88:	92 c0       	rjmp	.+292    	; 0x20ae <__fp_inf>
    1f8a:	dc c0       	rjmp	.+440    	; 0x2144 <__fp_szero>
    1f8c:	5f 3f       	cpi	r21, 0xFF	; 255
    1f8e:	ec f3       	brlt	.-6      	; 0x1f8a <__divsf3_pse+0x6a>
    1f90:	98 3e       	cpi	r25, 0xE8	; 232
    1f92:	dc f3       	brlt	.-10     	; 0x1f8a <__divsf3_pse+0x6a>
    1f94:	86 95       	lsr	r24
    1f96:	77 95       	ror	r23
    1f98:	67 95       	ror	r22
    1f9a:	b7 95       	ror	r27
    1f9c:	f7 95       	ror	r31
    1f9e:	9f 5f       	subi	r25, 0xFF	; 255
    1fa0:	c9 f7       	brne	.-14     	; 0x1f94 <__divsf3_pse+0x74>
    1fa2:	88 0f       	add	r24, r24
    1fa4:	91 1d       	adc	r25, r1
    1fa6:	96 95       	lsr	r25
    1fa8:	87 95       	ror	r24
    1faa:	97 f9       	bld	r25, 7
    1fac:	08 95       	ret
    1fae:	e1 e0       	ldi	r30, 0x01	; 1
    1fb0:	66 0f       	add	r22, r22
    1fb2:	77 1f       	adc	r23, r23
    1fb4:	88 1f       	adc	r24, r24
    1fb6:	bb 1f       	adc	r27, r27
    1fb8:	62 17       	cp	r22, r18
    1fba:	73 07       	cpc	r23, r19
    1fbc:	84 07       	cpc	r24, r20
    1fbe:	ba 07       	cpc	r27, r26
    1fc0:	20 f0       	brcs	.+8      	; 0x1fca <__divsf3_pse+0xaa>
    1fc2:	62 1b       	sub	r22, r18
    1fc4:	73 0b       	sbc	r23, r19
    1fc6:	84 0b       	sbc	r24, r20
    1fc8:	ba 0b       	sbc	r27, r26
    1fca:	ee 1f       	adc	r30, r30
    1fcc:	88 f7       	brcc	.-30     	; 0x1fb0 <__divsf3_pse+0x90>
    1fce:	e0 95       	com	r30
    1fd0:	08 95       	ret

00001fd2 <__fixsfsi>:
    1fd2:	04 d0       	rcall	.+8      	; 0x1fdc <__fixunssfsi>
    1fd4:	68 94       	set
    1fd6:	b1 11       	cpse	r27, r1
    1fd8:	b5 c0       	rjmp	.+362    	; 0x2144 <__fp_szero>
    1fda:	08 95       	ret

00001fdc <__fixunssfsi>:
    1fdc:	98 d0       	rcall	.+304    	; 0x210e <__fp_splitA>
    1fde:	88 f0       	brcs	.+34     	; 0x2002 <__fixunssfsi+0x26>
    1fe0:	9f 57       	subi	r25, 0x7F	; 127
    1fe2:	90 f0       	brcs	.+36     	; 0x2008 <__fixunssfsi+0x2c>
    1fe4:	b9 2f       	mov	r27, r25
    1fe6:	99 27       	eor	r25, r25
    1fe8:	b7 51       	subi	r27, 0x17	; 23
    1fea:	a0 f0       	brcs	.+40     	; 0x2014 <__fixunssfsi+0x38>
    1fec:	d1 f0       	breq	.+52     	; 0x2022 <__fixunssfsi+0x46>
    1fee:	66 0f       	add	r22, r22
    1ff0:	77 1f       	adc	r23, r23
    1ff2:	88 1f       	adc	r24, r24
    1ff4:	99 1f       	adc	r25, r25
    1ff6:	1a f0       	brmi	.+6      	; 0x1ffe <__fixunssfsi+0x22>
    1ff8:	ba 95       	dec	r27
    1ffa:	c9 f7       	brne	.-14     	; 0x1fee <__fixunssfsi+0x12>
    1ffc:	12 c0       	rjmp	.+36     	; 0x2022 <__fixunssfsi+0x46>
    1ffe:	b1 30       	cpi	r27, 0x01	; 1
    2000:	81 f0       	breq	.+32     	; 0x2022 <__fixunssfsi+0x46>
    2002:	9f d0       	rcall	.+318    	; 0x2142 <__fp_zero>
    2004:	b1 e0       	ldi	r27, 0x01	; 1
    2006:	08 95       	ret
    2008:	9c c0       	rjmp	.+312    	; 0x2142 <__fp_zero>
    200a:	67 2f       	mov	r22, r23
    200c:	78 2f       	mov	r23, r24
    200e:	88 27       	eor	r24, r24
    2010:	b8 5f       	subi	r27, 0xF8	; 248
    2012:	39 f0       	breq	.+14     	; 0x2022 <__fixunssfsi+0x46>
    2014:	b9 3f       	cpi	r27, 0xF9	; 249
    2016:	cc f3       	brlt	.-14     	; 0x200a <__fixunssfsi+0x2e>
    2018:	86 95       	lsr	r24
    201a:	77 95       	ror	r23
    201c:	67 95       	ror	r22
    201e:	b3 95       	inc	r27
    2020:	d9 f7       	brne	.-10     	; 0x2018 <__fixunssfsi+0x3c>
    2022:	3e f4       	brtc	.+14     	; 0x2032 <__fixunssfsi+0x56>
    2024:	90 95       	com	r25
    2026:	80 95       	com	r24
    2028:	70 95       	com	r23
    202a:	61 95       	neg	r22
    202c:	7f 4f       	sbci	r23, 0xFF	; 255
    202e:	8f 4f       	sbci	r24, 0xFF	; 255
    2030:	9f 4f       	sbci	r25, 0xFF	; 255
    2032:	08 95       	ret

00002034 <__floatunsisf>:
    2034:	e8 94       	clt
    2036:	09 c0       	rjmp	.+18     	; 0x204a <__floatsisf+0x12>

00002038 <__floatsisf>:
    2038:	97 fb       	bst	r25, 7
    203a:	3e f4       	brtc	.+14     	; 0x204a <__floatsisf+0x12>
    203c:	90 95       	com	r25
    203e:	80 95       	com	r24
    2040:	70 95       	com	r23
    2042:	61 95       	neg	r22
    2044:	7f 4f       	sbci	r23, 0xFF	; 255
    2046:	8f 4f       	sbci	r24, 0xFF	; 255
    2048:	9f 4f       	sbci	r25, 0xFF	; 255
    204a:	99 23       	and	r25, r25
    204c:	a9 f0       	breq	.+42     	; 0x2078 <__floatsisf+0x40>
    204e:	f9 2f       	mov	r31, r25
    2050:	96 e9       	ldi	r25, 0x96	; 150
    2052:	bb 27       	eor	r27, r27
    2054:	93 95       	inc	r25
    2056:	f6 95       	lsr	r31
    2058:	87 95       	ror	r24
    205a:	77 95       	ror	r23
    205c:	67 95       	ror	r22
    205e:	b7 95       	ror	r27
    2060:	f1 11       	cpse	r31, r1
    2062:	f8 cf       	rjmp	.-16     	; 0x2054 <__floatsisf+0x1c>
    2064:	fa f4       	brpl	.+62     	; 0x20a4 <__floatsisf+0x6c>
    2066:	bb 0f       	add	r27, r27
    2068:	11 f4       	brne	.+4      	; 0x206e <__floatsisf+0x36>
    206a:	60 ff       	sbrs	r22, 0
    206c:	1b c0       	rjmp	.+54     	; 0x20a4 <__floatsisf+0x6c>
    206e:	6f 5f       	subi	r22, 0xFF	; 255
    2070:	7f 4f       	sbci	r23, 0xFF	; 255
    2072:	8f 4f       	sbci	r24, 0xFF	; 255
    2074:	9f 4f       	sbci	r25, 0xFF	; 255
    2076:	16 c0       	rjmp	.+44     	; 0x20a4 <__floatsisf+0x6c>
    2078:	88 23       	and	r24, r24
    207a:	11 f0       	breq	.+4      	; 0x2080 <__floatsisf+0x48>
    207c:	96 e9       	ldi	r25, 0x96	; 150
    207e:	11 c0       	rjmp	.+34     	; 0x20a2 <__floatsisf+0x6a>
    2080:	77 23       	and	r23, r23
    2082:	21 f0       	breq	.+8      	; 0x208c <__floatsisf+0x54>
    2084:	9e e8       	ldi	r25, 0x8E	; 142
    2086:	87 2f       	mov	r24, r23
    2088:	76 2f       	mov	r23, r22
    208a:	05 c0       	rjmp	.+10     	; 0x2096 <__floatsisf+0x5e>
    208c:	66 23       	and	r22, r22
    208e:	71 f0       	breq	.+28     	; 0x20ac <__floatsisf+0x74>
    2090:	96 e8       	ldi	r25, 0x86	; 134
    2092:	86 2f       	mov	r24, r22
    2094:	70 e0       	ldi	r23, 0x00	; 0
    2096:	60 e0       	ldi	r22, 0x00	; 0
    2098:	2a f0       	brmi	.+10     	; 0x20a4 <__floatsisf+0x6c>
    209a:	9a 95       	dec	r25
    209c:	66 0f       	add	r22, r22
    209e:	77 1f       	adc	r23, r23
    20a0:	88 1f       	adc	r24, r24
    20a2:	da f7       	brpl	.-10     	; 0x209a <__floatsisf+0x62>
    20a4:	88 0f       	add	r24, r24
    20a6:	96 95       	lsr	r25
    20a8:	87 95       	ror	r24
    20aa:	97 f9       	bld	r25, 7
    20ac:	08 95       	ret

000020ae <__fp_inf>:
    20ae:	97 f9       	bld	r25, 7
    20b0:	9f 67       	ori	r25, 0x7F	; 127
    20b2:	80 e8       	ldi	r24, 0x80	; 128
    20b4:	70 e0       	ldi	r23, 0x00	; 0
    20b6:	60 e0       	ldi	r22, 0x00	; 0
    20b8:	08 95       	ret

000020ba <__fp_nan>:
    20ba:	9f ef       	ldi	r25, 0xFF	; 255
    20bc:	80 ec       	ldi	r24, 0xC0	; 192
    20be:	08 95       	ret

000020c0 <__fp_pscA>:
    20c0:	00 24       	eor	r0, r0
    20c2:	0a 94       	dec	r0
    20c4:	16 16       	cp	r1, r22
    20c6:	17 06       	cpc	r1, r23
    20c8:	18 06       	cpc	r1, r24
    20ca:	09 06       	cpc	r0, r25
    20cc:	08 95       	ret

000020ce <__fp_pscB>:
    20ce:	00 24       	eor	r0, r0
    20d0:	0a 94       	dec	r0
    20d2:	12 16       	cp	r1, r18
    20d4:	13 06       	cpc	r1, r19
    20d6:	14 06       	cpc	r1, r20
    20d8:	05 06       	cpc	r0, r21
    20da:	08 95       	ret

000020dc <__fp_round>:
    20dc:	09 2e       	mov	r0, r25
    20de:	03 94       	inc	r0
    20e0:	00 0c       	add	r0, r0
    20e2:	11 f4       	brne	.+4      	; 0x20e8 <__fp_round+0xc>
    20e4:	88 23       	and	r24, r24
    20e6:	52 f0       	brmi	.+20     	; 0x20fc <__fp_round+0x20>
    20e8:	bb 0f       	add	r27, r27
    20ea:	40 f4       	brcc	.+16     	; 0x20fc <__fp_round+0x20>
    20ec:	bf 2b       	or	r27, r31
    20ee:	11 f4       	brne	.+4      	; 0x20f4 <__fp_round+0x18>
    20f0:	60 ff       	sbrs	r22, 0
    20f2:	04 c0       	rjmp	.+8      	; 0x20fc <__fp_round+0x20>
    20f4:	6f 5f       	subi	r22, 0xFF	; 255
    20f6:	7f 4f       	sbci	r23, 0xFF	; 255
    20f8:	8f 4f       	sbci	r24, 0xFF	; 255
    20fa:	9f 4f       	sbci	r25, 0xFF	; 255
    20fc:	08 95       	ret

000020fe <__fp_split3>:
    20fe:	57 fd       	sbrc	r21, 7
    2100:	90 58       	subi	r25, 0x80	; 128
    2102:	44 0f       	add	r20, r20
    2104:	55 1f       	adc	r21, r21
    2106:	59 f0       	breq	.+22     	; 0x211e <__fp_splitA+0x10>
    2108:	5f 3f       	cpi	r21, 0xFF	; 255
    210a:	71 f0       	breq	.+28     	; 0x2128 <__fp_splitA+0x1a>
    210c:	47 95       	ror	r20

0000210e <__fp_splitA>:
    210e:	88 0f       	add	r24, r24
    2110:	97 fb       	bst	r25, 7
    2112:	99 1f       	adc	r25, r25
    2114:	61 f0       	breq	.+24     	; 0x212e <__fp_splitA+0x20>
    2116:	9f 3f       	cpi	r25, 0xFF	; 255
    2118:	79 f0       	breq	.+30     	; 0x2138 <__fp_splitA+0x2a>
    211a:	87 95       	ror	r24
    211c:	08 95       	ret
    211e:	12 16       	cp	r1, r18
    2120:	13 06       	cpc	r1, r19
    2122:	14 06       	cpc	r1, r20
    2124:	55 1f       	adc	r21, r21
    2126:	f2 cf       	rjmp	.-28     	; 0x210c <__fp_split3+0xe>
    2128:	46 95       	lsr	r20
    212a:	f1 df       	rcall	.-30     	; 0x210e <__fp_splitA>
    212c:	08 c0       	rjmp	.+16     	; 0x213e <__fp_splitA+0x30>
    212e:	16 16       	cp	r1, r22
    2130:	17 06       	cpc	r1, r23
    2132:	18 06       	cpc	r1, r24
    2134:	99 1f       	adc	r25, r25
    2136:	f1 cf       	rjmp	.-30     	; 0x211a <__fp_splitA+0xc>
    2138:	86 95       	lsr	r24
    213a:	71 05       	cpc	r23, r1
    213c:	61 05       	cpc	r22, r1
    213e:	08 94       	sec
    2140:	08 95       	ret

00002142 <__fp_zero>:
    2142:	e8 94       	clt

00002144 <__fp_szero>:
    2144:	bb 27       	eor	r27, r27
    2146:	66 27       	eor	r22, r22
    2148:	77 27       	eor	r23, r23
    214a:	cb 01       	movw	r24, r22
    214c:	97 f9       	bld	r25, 7
    214e:	08 95       	ret

00002150 <__mulsf3>:
    2150:	0b d0       	rcall	.+22     	; 0x2168 <__mulsf3x>
    2152:	c4 cf       	rjmp	.-120    	; 0x20dc <__fp_round>
    2154:	b5 df       	rcall	.-150    	; 0x20c0 <__fp_pscA>
    2156:	28 f0       	brcs	.+10     	; 0x2162 <__mulsf3+0x12>
    2158:	ba df       	rcall	.-140    	; 0x20ce <__fp_pscB>
    215a:	18 f0       	brcs	.+6      	; 0x2162 <__mulsf3+0x12>
    215c:	95 23       	and	r25, r21
    215e:	09 f0       	breq	.+2      	; 0x2162 <__mulsf3+0x12>
    2160:	a6 cf       	rjmp	.-180    	; 0x20ae <__fp_inf>
    2162:	ab cf       	rjmp	.-170    	; 0x20ba <__fp_nan>
    2164:	11 24       	eor	r1, r1
    2166:	ee cf       	rjmp	.-36     	; 0x2144 <__fp_szero>

00002168 <__mulsf3x>:
    2168:	ca df       	rcall	.-108    	; 0x20fe <__fp_split3>
    216a:	a0 f3       	brcs	.-24     	; 0x2154 <__mulsf3+0x4>

0000216c <__mulsf3_pse>:
    216c:	95 9f       	mul	r25, r21
    216e:	d1 f3       	breq	.-12     	; 0x2164 <__mulsf3+0x14>
    2170:	95 0f       	add	r25, r21
    2172:	50 e0       	ldi	r21, 0x00	; 0
    2174:	55 1f       	adc	r21, r21
    2176:	62 9f       	mul	r22, r18
    2178:	f0 01       	movw	r30, r0
    217a:	72 9f       	mul	r23, r18
    217c:	bb 27       	eor	r27, r27
    217e:	f0 0d       	add	r31, r0
    2180:	b1 1d       	adc	r27, r1
    2182:	63 9f       	mul	r22, r19
    2184:	aa 27       	eor	r26, r26
    2186:	f0 0d       	add	r31, r0
    2188:	b1 1d       	adc	r27, r1
    218a:	aa 1f       	adc	r26, r26
    218c:	64 9f       	mul	r22, r20
    218e:	66 27       	eor	r22, r22
    2190:	b0 0d       	add	r27, r0
    2192:	a1 1d       	adc	r26, r1
    2194:	66 1f       	adc	r22, r22
    2196:	82 9f       	mul	r24, r18
    2198:	22 27       	eor	r18, r18
    219a:	b0 0d       	add	r27, r0
    219c:	a1 1d       	adc	r26, r1
    219e:	62 1f       	adc	r22, r18
    21a0:	73 9f       	mul	r23, r19
    21a2:	b0 0d       	add	r27, r0
    21a4:	a1 1d       	adc	r26, r1
    21a6:	62 1f       	adc	r22, r18
    21a8:	83 9f       	mul	r24, r19
    21aa:	a0 0d       	add	r26, r0
    21ac:	61 1d       	adc	r22, r1
    21ae:	22 1f       	adc	r18, r18
    21b0:	74 9f       	mul	r23, r20
    21b2:	33 27       	eor	r19, r19
    21b4:	a0 0d       	add	r26, r0
    21b6:	61 1d       	adc	r22, r1
    21b8:	23 1f       	adc	r18, r19
    21ba:	84 9f       	mul	r24, r20
    21bc:	60 0d       	add	r22, r0
    21be:	21 1d       	adc	r18, r1
    21c0:	82 2f       	mov	r24, r18
    21c2:	76 2f       	mov	r23, r22
    21c4:	6a 2f       	mov	r22, r26
    21c6:	11 24       	eor	r1, r1
    21c8:	9f 57       	subi	r25, 0x7F	; 127
    21ca:	50 40       	sbci	r21, 0x00	; 0
    21cc:	8a f0       	brmi	.+34     	; 0x21f0 <__mulsf3_pse+0x84>
    21ce:	e1 f0       	breq	.+56     	; 0x2208 <__stack+0x9>
    21d0:	88 23       	and	r24, r24
    21d2:	4a f0       	brmi	.+18     	; 0x21e6 <__mulsf3_pse+0x7a>
    21d4:	ee 0f       	add	r30, r30
    21d6:	ff 1f       	adc	r31, r31
    21d8:	bb 1f       	adc	r27, r27
    21da:	66 1f       	adc	r22, r22
    21dc:	77 1f       	adc	r23, r23
    21de:	88 1f       	adc	r24, r24
    21e0:	91 50       	subi	r25, 0x01	; 1
    21e2:	50 40       	sbci	r21, 0x00	; 0
    21e4:	a9 f7       	brne	.-22     	; 0x21d0 <__mulsf3_pse+0x64>
    21e6:	9e 3f       	cpi	r25, 0xFE	; 254
    21e8:	51 05       	cpc	r21, r1
    21ea:	70 f0       	brcs	.+28     	; 0x2208 <__stack+0x9>
    21ec:	60 cf       	rjmp	.-320    	; 0x20ae <__fp_inf>
    21ee:	aa cf       	rjmp	.-172    	; 0x2144 <__fp_szero>
    21f0:	5f 3f       	cpi	r21, 0xFF	; 255
    21f2:	ec f3       	brlt	.-6      	; 0x21ee <__mulsf3_pse+0x82>
    21f4:	98 3e       	cpi	r25, 0xE8	; 232
    21f6:	dc f3       	brlt	.-10     	; 0x21ee <__mulsf3_pse+0x82>
    21f8:	86 95       	lsr	r24
    21fa:	77 95       	ror	r23
    21fc:	67 95       	ror	r22
    21fe:	b7 95       	ror	r27
    2200:	f7 95       	ror	r31
    2202:	e7 95       	ror	r30
    2204:	9f 5f       	subi	r25, 0xFF	; 255
    2206:	c1 f7       	brne	.-16     	; 0x21f8 <__mulsf3_pse+0x8c>
    2208:	fe 2b       	or	r31, r30
    220a:	88 0f       	add	r24, r24
    220c:	91 1d       	adc	r25, r1
    220e:	96 95       	lsr	r25
    2210:	87 95       	ror	r24
    2212:	97 f9       	bld	r25, 7
    2214:	08 95       	ret

00002216 <pow>:
    2216:	fa 01       	movw	r30, r20
    2218:	ee 0f       	add	r30, r30
    221a:	ff 1f       	adc	r31, r31
    221c:	30 96       	adiw	r30, 0x00	; 0
    221e:	21 05       	cpc	r18, r1
    2220:	31 05       	cpc	r19, r1
    2222:	99 f1       	breq	.+102    	; 0x228a <pow+0x74>
    2224:	61 15       	cp	r22, r1
    2226:	71 05       	cpc	r23, r1
    2228:	61 f4       	brne	.+24     	; 0x2242 <pow+0x2c>
    222a:	80 38       	cpi	r24, 0x80	; 128
    222c:	bf e3       	ldi	r27, 0x3F	; 63
    222e:	9b 07       	cpc	r25, r27
    2230:	49 f1       	breq	.+82     	; 0x2284 <pow+0x6e>
    2232:	68 94       	set
    2234:	90 38       	cpi	r25, 0x80	; 128
    2236:	81 05       	cpc	r24, r1
    2238:	61 f0       	breq	.+24     	; 0x2252 <pow+0x3c>
    223a:	80 38       	cpi	r24, 0x80	; 128
    223c:	bf ef       	ldi	r27, 0xFF	; 255
    223e:	9b 07       	cpc	r25, r27
    2240:	41 f0       	breq	.+16     	; 0x2252 <pow+0x3c>
    2242:	99 23       	and	r25, r25
    2244:	42 f5       	brpl	.+80     	; 0x2296 <pow+0x80>
    2246:	ff 3f       	cpi	r31, 0xFF	; 255
    2248:	e1 05       	cpc	r30, r1
    224a:	31 05       	cpc	r19, r1
    224c:	21 05       	cpc	r18, r1
    224e:	11 f1       	breq	.+68     	; 0x2294 <pow+0x7e>
    2250:	e8 94       	clt
    2252:	08 94       	sec
    2254:	e7 95       	ror	r30
    2256:	d9 01       	movw	r26, r18
    2258:	aa 23       	and	r26, r26
    225a:	29 f4       	brne	.+10     	; 0x2266 <pow+0x50>
    225c:	ab 2f       	mov	r26, r27
    225e:	be 2f       	mov	r27, r30
    2260:	f8 5f       	subi	r31, 0xF8	; 248
    2262:	d0 f3       	brcs	.-12     	; 0x2258 <pow+0x42>
    2264:	10 c0       	rjmp	.+32     	; 0x2286 <pow+0x70>
    2266:	ff 5f       	subi	r31, 0xFF	; 255
    2268:	70 f4       	brcc	.+28     	; 0x2286 <pow+0x70>
    226a:	a6 95       	lsr	r26
    226c:	e0 f7       	brcc	.-8      	; 0x2266 <pow+0x50>
    226e:	f7 39       	cpi	r31, 0x97	; 151
    2270:	50 f0       	brcs	.+20     	; 0x2286 <pow+0x70>
    2272:	19 f0       	breq	.+6      	; 0x227a <pow+0x64>
    2274:	ff 3a       	cpi	r31, 0xAF	; 175
    2276:	38 f4       	brcc	.+14     	; 0x2286 <pow+0x70>
    2278:	9f 77       	andi	r25, 0x7F	; 127
    227a:	9f 93       	push	r25
    227c:	0c d0       	rcall	.+24     	; 0x2296 <pow+0x80>
    227e:	0f 90       	pop	r0
    2280:	07 fc       	sbrc	r0, 7
    2282:	90 58       	subi	r25, 0x80	; 128
    2284:	08 95       	ret
    2286:	3e f0       	brts	.+14     	; 0x2296 <pow+0x80>
    2288:	18 cf       	rjmp	.-464    	; 0x20ba <__fp_nan>
    228a:	60 e0       	ldi	r22, 0x00	; 0
    228c:	70 e0       	ldi	r23, 0x00	; 0
    228e:	80 e8       	ldi	r24, 0x80	; 128
    2290:	9f e3       	ldi	r25, 0x3F	; 63
    2292:	08 95       	ret
    2294:	4f e7       	ldi	r20, 0x7F	; 127
    2296:	9f 77       	andi	r25, 0x7F	; 127
    2298:	5f 93       	push	r21
    229a:	4f 93       	push	r20
    229c:	3f 93       	push	r19
    229e:	2f 93       	push	r18
    22a0:	9e d0       	rcall	.+316    	; 0x23de <log>
    22a2:	2f 91       	pop	r18
    22a4:	3f 91       	pop	r19
    22a6:	4f 91       	pop	r20
    22a8:	5f 91       	pop	r21
    22aa:	52 df       	rcall	.-348    	; 0x2150 <__mulsf3>
    22ac:	05 c0       	rjmp	.+10     	; 0x22b8 <exp>
    22ae:	19 f4       	brne	.+6      	; 0x22b6 <pow+0xa0>
    22b0:	0e f0       	brts	.+2      	; 0x22b4 <pow+0x9e>
    22b2:	fd ce       	rjmp	.-518    	; 0x20ae <__fp_inf>
    22b4:	46 cf       	rjmp	.-372    	; 0x2142 <__fp_zero>
    22b6:	01 cf       	rjmp	.-510    	; 0x20ba <__fp_nan>

000022b8 <exp>:
    22b8:	2a df       	rcall	.-428    	; 0x210e <__fp_splitA>
    22ba:	c8 f3       	brcs	.-14     	; 0x22ae <pow+0x98>
    22bc:	96 38       	cpi	r25, 0x86	; 134
    22be:	c0 f7       	brcc	.-16     	; 0x22b0 <pow+0x9a>
    22c0:	07 f8       	bld	r0, 7
    22c2:	0f 92       	push	r0
    22c4:	e8 94       	clt
    22c6:	2b e3       	ldi	r18, 0x3B	; 59
    22c8:	3a ea       	ldi	r19, 0xAA	; 170
    22ca:	48 eb       	ldi	r20, 0xB8	; 184
    22cc:	5f e7       	ldi	r21, 0x7F	; 127
    22ce:	4e df       	rcall	.-356    	; 0x216c <__mulsf3_pse>
    22d0:	0f 92       	push	r0
    22d2:	0f 92       	push	r0
    22d4:	0f 92       	push	r0
    22d6:	4d b7       	in	r20, 0x3d	; 61
    22d8:	5e b7       	in	r21, 0x3e	; 62
    22da:	0f 92       	push	r0
    22dc:	c0 d0       	rcall	.+384    	; 0x245e <modf>
    22de:	e4 ee       	ldi	r30, 0xE4	; 228
    22e0:	f0 e0       	ldi	r31, 0x00	; 0
    22e2:	16 d0       	rcall	.+44     	; 0x2310 <__fp_powser>
    22e4:	4f 91       	pop	r20
    22e6:	5f 91       	pop	r21
    22e8:	ef 91       	pop	r30
    22ea:	ff 91       	pop	r31
    22ec:	e5 95       	asr	r30
    22ee:	ee 1f       	adc	r30, r30
    22f0:	ff 1f       	adc	r31, r31
    22f2:	49 f0       	breq	.+18     	; 0x2306 <exp+0x4e>
    22f4:	fe 57       	subi	r31, 0x7E	; 126
    22f6:	e0 68       	ori	r30, 0x80	; 128
    22f8:	44 27       	eor	r20, r20
    22fa:	ee 0f       	add	r30, r30
    22fc:	44 1f       	adc	r20, r20
    22fe:	fa 95       	dec	r31
    2300:	e1 f7       	brne	.-8      	; 0x22fa <exp+0x42>
    2302:	41 95       	neg	r20
    2304:	55 0b       	sbc	r21, r21
    2306:	32 d0       	rcall	.+100    	; 0x236c <ldexp>
    2308:	0f 90       	pop	r0
    230a:	07 fe       	sbrs	r0, 7
    230c:	26 c0       	rjmp	.+76     	; 0x235a <inverse>
    230e:	08 95       	ret

00002310 <__fp_powser>:
    2310:	df 93       	push	r29
    2312:	cf 93       	push	r28
    2314:	1f 93       	push	r17
    2316:	0f 93       	push	r16
    2318:	ff 92       	push	r15
    231a:	ef 92       	push	r14
    231c:	df 92       	push	r13
    231e:	7b 01       	movw	r14, r22
    2320:	8c 01       	movw	r16, r24
    2322:	68 94       	set
    2324:	05 c0       	rjmp	.+10     	; 0x2330 <__fp_powser+0x20>
    2326:	da 2e       	mov	r13, r26
    2328:	ef 01       	movw	r28, r30
    232a:	1e df       	rcall	.-452    	; 0x2168 <__mulsf3x>
    232c:	fe 01       	movw	r30, r28
    232e:	e8 94       	clt
    2330:	a5 91       	lpm	r26, Z+
    2332:	25 91       	lpm	r18, Z+
    2334:	35 91       	lpm	r19, Z+
    2336:	45 91       	lpm	r20, Z+
    2338:	55 91       	lpm	r21, Z+
    233a:	ae f3       	brts	.-22     	; 0x2326 <__fp_powser+0x16>
    233c:	ef 01       	movw	r28, r30
    233e:	8e dd       	rcall	.-1252   	; 0x1e5c <__addsf3x>
    2340:	fe 01       	movw	r30, r28
    2342:	97 01       	movw	r18, r14
    2344:	a8 01       	movw	r20, r16
    2346:	da 94       	dec	r13
    2348:	79 f7       	brne	.-34     	; 0x2328 <__fp_powser+0x18>
    234a:	df 90       	pop	r13
    234c:	ef 90       	pop	r14
    234e:	ff 90       	pop	r15
    2350:	0f 91       	pop	r16
    2352:	1f 91       	pop	r17
    2354:	cf 91       	pop	r28
    2356:	df 91       	pop	r29
    2358:	08 95       	ret

0000235a <inverse>:
    235a:	9b 01       	movw	r18, r22
    235c:	ac 01       	movw	r20, r24
    235e:	60 e0       	ldi	r22, 0x00	; 0
    2360:	70 e0       	ldi	r23, 0x00	; 0
    2362:	80 e8       	ldi	r24, 0x80	; 128
    2364:	9f e3       	ldi	r25, 0x3F	; 63
    2366:	cd cd       	rjmp	.-1126   	; 0x1f02 <__divsf3>
    2368:	a2 ce       	rjmp	.-700    	; 0x20ae <__fp_inf>
    236a:	ac c0       	rjmp	.+344    	; 0x24c4 <__fp_mpack>

0000236c <ldexp>:
    236c:	d0 de       	rcall	.-608    	; 0x210e <__fp_splitA>
    236e:	e8 f3       	brcs	.-6      	; 0x236a <inverse+0x10>
    2370:	99 23       	and	r25, r25
    2372:	d9 f3       	breq	.-10     	; 0x236a <inverse+0x10>
    2374:	94 0f       	add	r25, r20
    2376:	51 1d       	adc	r21, r1
    2378:	bb f3       	brvs	.-18     	; 0x2368 <inverse+0xe>
    237a:	91 50       	subi	r25, 0x01	; 1
    237c:	50 40       	sbci	r21, 0x00	; 0
    237e:	94 f0       	brlt	.+36     	; 0x23a4 <ldexp+0x38>
    2380:	59 f0       	breq	.+22     	; 0x2398 <ldexp+0x2c>
    2382:	88 23       	and	r24, r24
    2384:	32 f0       	brmi	.+12     	; 0x2392 <ldexp+0x26>
    2386:	66 0f       	add	r22, r22
    2388:	77 1f       	adc	r23, r23
    238a:	88 1f       	adc	r24, r24
    238c:	91 50       	subi	r25, 0x01	; 1
    238e:	50 40       	sbci	r21, 0x00	; 0
    2390:	c1 f7       	brne	.-16     	; 0x2382 <ldexp+0x16>
    2392:	9e 3f       	cpi	r25, 0xFE	; 254
    2394:	51 05       	cpc	r21, r1
    2396:	44 f7       	brge	.-48     	; 0x2368 <inverse+0xe>
    2398:	88 0f       	add	r24, r24
    239a:	91 1d       	adc	r25, r1
    239c:	96 95       	lsr	r25
    239e:	87 95       	ror	r24
    23a0:	97 f9       	bld	r25, 7
    23a2:	08 95       	ret
    23a4:	5f 3f       	cpi	r21, 0xFF	; 255
    23a6:	ac f0       	brlt	.+42     	; 0x23d2 <ldexp+0x66>
    23a8:	98 3e       	cpi	r25, 0xE8	; 232
    23aa:	9c f0       	brlt	.+38     	; 0x23d2 <ldexp+0x66>
    23ac:	bb 27       	eor	r27, r27
    23ae:	86 95       	lsr	r24
    23b0:	77 95       	ror	r23
    23b2:	67 95       	ror	r22
    23b4:	b7 95       	ror	r27
    23b6:	08 f4       	brcc	.+2      	; 0x23ba <ldexp+0x4e>
    23b8:	b1 60       	ori	r27, 0x01	; 1
    23ba:	93 95       	inc	r25
    23bc:	c1 f7       	brne	.-16     	; 0x23ae <ldexp+0x42>
    23be:	bb 0f       	add	r27, r27
    23c0:	58 f7       	brcc	.-42     	; 0x2398 <ldexp+0x2c>
    23c2:	11 f4       	brne	.+4      	; 0x23c8 <ldexp+0x5c>
    23c4:	60 ff       	sbrs	r22, 0
    23c6:	e8 cf       	rjmp	.-48     	; 0x2398 <ldexp+0x2c>
    23c8:	6f 5f       	subi	r22, 0xFF	; 255
    23ca:	7f 4f       	sbci	r23, 0xFF	; 255
    23cc:	8f 4f       	sbci	r24, 0xFF	; 255
    23ce:	9f 4f       	sbci	r25, 0xFF	; 255
    23d0:	e3 cf       	rjmp	.-58     	; 0x2398 <ldexp+0x2c>
    23d2:	b8 ce       	rjmp	.-656    	; 0x2144 <__fp_szero>
    23d4:	0e f0       	brts	.+2      	; 0x23d8 <ldexp+0x6c>
    23d6:	76 c0       	rjmp	.+236    	; 0x24c4 <__fp_mpack>
    23d8:	70 ce       	rjmp	.-800    	; 0x20ba <__fp_nan>
    23da:	68 94       	set
    23dc:	68 ce       	rjmp	.-816    	; 0x20ae <__fp_inf>

000023de <log>:
    23de:	97 de       	rcall	.-722    	; 0x210e <__fp_splitA>
    23e0:	c8 f3       	brcs	.-14     	; 0x23d4 <ldexp+0x68>
    23e2:	99 23       	and	r25, r25
    23e4:	d1 f3       	breq	.-12     	; 0x23da <ldexp+0x6e>
    23e6:	c6 f3       	brts	.-16     	; 0x23d8 <ldexp+0x6c>
    23e8:	df 93       	push	r29
    23ea:	cf 93       	push	r28
    23ec:	1f 93       	push	r17
    23ee:	0f 93       	push	r16
    23f0:	ff 92       	push	r15
    23f2:	c9 2f       	mov	r28, r25
    23f4:	dd 27       	eor	r29, r29
    23f6:	88 23       	and	r24, r24
    23f8:	2a f0       	brmi	.+10     	; 0x2404 <log+0x26>
    23fa:	21 97       	sbiw	r28, 0x01	; 1
    23fc:	66 0f       	add	r22, r22
    23fe:	77 1f       	adc	r23, r23
    2400:	88 1f       	adc	r24, r24
    2402:	da f7       	brpl	.-10     	; 0x23fa <log+0x1c>
    2404:	20 e0       	ldi	r18, 0x00	; 0
    2406:	30 e0       	ldi	r19, 0x00	; 0
    2408:	40 e8       	ldi	r20, 0x80	; 128
    240a:	5f eb       	ldi	r21, 0xBF	; 191
    240c:	9f e3       	ldi	r25, 0x3F	; 63
    240e:	88 39       	cpi	r24, 0x98	; 152
    2410:	20 f0       	brcs	.+8      	; 0x241a <log+0x3c>
    2412:	80 3e       	cpi	r24, 0xE0	; 224
    2414:	30 f0       	brcs	.+12     	; 0x2422 <log+0x44>
    2416:	21 96       	adiw	r28, 0x01	; 1
    2418:	8f 77       	andi	r24, 0x7F	; 127
    241a:	0f dd       	rcall	.-1506   	; 0x1e3a <__addsf3>
    241c:	ec e0       	ldi	r30, 0x0C	; 12
    241e:	f1 e0       	ldi	r31, 0x01	; 1
    2420:	03 c0       	rjmp	.+6      	; 0x2428 <log+0x4a>
    2422:	0b dd       	rcall	.-1514   	; 0x1e3a <__addsf3>
    2424:	e9 e3       	ldi	r30, 0x39	; 57
    2426:	f1 e0       	ldi	r31, 0x01	; 1
    2428:	73 df       	rcall	.-282    	; 0x2310 <__fp_powser>
    242a:	8b 01       	movw	r16, r22
    242c:	be 01       	movw	r22, r28
    242e:	ec 01       	movw	r28, r24
    2430:	fb 2e       	mov	r15, r27
    2432:	6f 57       	subi	r22, 0x7F	; 127
    2434:	71 09       	sbc	r23, r1
    2436:	75 95       	asr	r23
    2438:	77 1f       	adc	r23, r23
    243a:	88 0b       	sbc	r24, r24
    243c:	99 0b       	sbc	r25, r25
    243e:	fc dd       	rcall	.-1032   	; 0x2038 <__floatsisf>
    2440:	28 e1       	ldi	r18, 0x18	; 24
    2442:	32 e7       	ldi	r19, 0x72	; 114
    2444:	41 e3       	ldi	r20, 0x31	; 49
    2446:	5f e3       	ldi	r21, 0x3F	; 63
    2448:	8f de       	rcall	.-738    	; 0x2168 <__mulsf3x>
    244a:	af 2d       	mov	r26, r15
    244c:	98 01       	movw	r18, r16
    244e:	ae 01       	movw	r20, r28
    2450:	ff 90       	pop	r15
    2452:	0f 91       	pop	r16
    2454:	1f 91       	pop	r17
    2456:	cf 91       	pop	r28
    2458:	df 91       	pop	r29
    245a:	00 dd       	rcall	.-1536   	; 0x1e5c <__addsf3x>
    245c:	3f ce       	rjmp	.-898    	; 0x20dc <__fp_round>

0000245e <modf>:
    245e:	fa 01       	movw	r30, r20
    2460:	dc 01       	movw	r26, r24
    2462:	aa 0f       	add	r26, r26
    2464:	bb 1f       	adc	r27, r27
    2466:	9b 01       	movw	r18, r22
    2468:	ac 01       	movw	r20, r24
    246a:	bf 57       	subi	r27, 0x7F	; 127
    246c:	28 f4       	brcc	.+10     	; 0x2478 <modf+0x1a>
    246e:	22 27       	eor	r18, r18
    2470:	33 27       	eor	r19, r19
    2472:	44 27       	eor	r20, r20
    2474:	50 78       	andi	r21, 0x80	; 128
    2476:	1f c0       	rjmp	.+62     	; 0x24b6 <modf+0x58>
    2478:	b7 51       	subi	r27, 0x17	; 23
    247a:	88 f4       	brcc	.+34     	; 0x249e <modf+0x40>
    247c:	ab 2f       	mov	r26, r27
    247e:	00 24       	eor	r0, r0
    2480:	46 95       	lsr	r20
    2482:	37 95       	ror	r19
    2484:	27 95       	ror	r18
    2486:	01 1c       	adc	r0, r1
    2488:	a3 95       	inc	r26
    248a:	d2 f3       	brmi	.-12     	; 0x2480 <modf+0x22>
    248c:	00 20       	and	r0, r0
    248e:	69 f0       	breq	.+26     	; 0x24aa <modf+0x4c>
    2490:	22 0f       	add	r18, r18
    2492:	33 1f       	adc	r19, r19
    2494:	44 1f       	adc	r20, r20
    2496:	b3 95       	inc	r27
    2498:	da f3       	brmi	.-10     	; 0x2490 <modf+0x32>
    249a:	0d d0       	rcall	.+26     	; 0x24b6 <modf+0x58>
    249c:	cd cc       	rjmp	.-1638   	; 0x1e38 <__subsf3>
    249e:	61 30       	cpi	r22, 0x01	; 1
    24a0:	71 05       	cpc	r23, r1
    24a2:	a0 e8       	ldi	r26, 0x80	; 128
    24a4:	8a 07       	cpc	r24, r26
    24a6:	b9 46       	sbci	r27, 0x69	; 105
    24a8:	30 f4       	brcc	.+12     	; 0x24b6 <modf+0x58>
    24aa:	9b 01       	movw	r18, r22
    24ac:	ac 01       	movw	r20, r24
    24ae:	66 27       	eor	r22, r22
    24b0:	77 27       	eor	r23, r23
    24b2:	88 27       	eor	r24, r24
    24b4:	90 78       	andi	r25, 0x80	; 128
    24b6:	30 96       	adiw	r30, 0x00	; 0
    24b8:	21 f0       	breq	.+8      	; 0x24c2 <modf+0x64>
    24ba:	20 83       	st	Z, r18
    24bc:	31 83       	std	Z+1, r19	; 0x01
    24be:	42 83       	std	Z+2, r20	; 0x02
    24c0:	53 83       	std	Z+3, r21	; 0x03
    24c2:	08 95       	ret

000024c4 <__fp_mpack>:
    24c4:	9f 3f       	cpi	r25, 0xFF	; 255
    24c6:	31 f0       	breq	.+12     	; 0x24d4 <__fp_mpack_finite+0xc>

000024c8 <__fp_mpack_finite>:
    24c8:	91 50       	subi	r25, 0x01	; 1
    24ca:	20 f4       	brcc	.+8      	; 0x24d4 <__fp_mpack_finite+0xc>
    24cc:	87 95       	ror	r24
    24ce:	77 95       	ror	r23
    24d0:	67 95       	ror	r22
    24d2:	b7 95       	ror	r27
    24d4:	88 0f       	add	r24, r24
    24d6:	91 1d       	adc	r25, r1
    24d8:	96 95       	lsr	r25
    24da:	87 95       	ror	r24
    24dc:	97 f9       	bld	r25, 7
    24de:	08 95       	ret

000024e0 <__udivmodhi4>:
    24e0:	aa 1b       	sub	r26, r26
    24e2:	bb 1b       	sub	r27, r27
    24e4:	51 e1       	ldi	r21, 0x11	; 17
    24e6:	07 c0       	rjmp	.+14     	; 0x24f6 <__udivmodhi4_ep>

000024e8 <__udivmodhi4_loop>:
    24e8:	aa 1f       	adc	r26, r26
    24ea:	bb 1f       	adc	r27, r27
    24ec:	a6 17       	cp	r26, r22
    24ee:	b7 07       	cpc	r27, r23
    24f0:	10 f0       	brcs	.+4      	; 0x24f6 <__udivmodhi4_ep>
    24f2:	a6 1b       	sub	r26, r22
    24f4:	b7 0b       	sbc	r27, r23

000024f6 <__udivmodhi4_ep>:
    24f6:	88 1f       	adc	r24, r24
    24f8:	99 1f       	adc	r25, r25
    24fa:	5a 95       	dec	r21
    24fc:	a9 f7       	brne	.-22     	; 0x24e8 <__udivmodhi4_loop>
    24fe:	80 95       	com	r24
    2500:	90 95       	com	r25
    2502:	bc 01       	movw	r22, r24
    2504:	cd 01       	movw	r24, r26
    2506:	08 95       	ret

00002508 <__divmodhi4>:
    2508:	97 fb       	bst	r25, 7
    250a:	09 2e       	mov	r0, r25
    250c:	07 26       	eor	r0, r23
    250e:	0a d0       	rcall	.+20     	; 0x2524 <__divmodhi4_neg1>
    2510:	77 fd       	sbrc	r23, 7
    2512:	04 d0       	rcall	.+8      	; 0x251c <__divmodhi4_neg2>
    2514:	e5 df       	rcall	.-54     	; 0x24e0 <__udivmodhi4>
    2516:	06 d0       	rcall	.+12     	; 0x2524 <__divmodhi4_neg1>
    2518:	00 20       	and	r0, r0
    251a:	1a f4       	brpl	.+6      	; 0x2522 <__divmodhi4_exit>

0000251c <__divmodhi4_neg2>:
    251c:	70 95       	com	r23
    251e:	61 95       	neg	r22
    2520:	7f 4f       	sbci	r23, 0xFF	; 255

00002522 <__divmodhi4_exit>:
    2522:	08 95       	ret

00002524 <__divmodhi4_neg1>:
    2524:	f6 f7       	brtc	.-4      	; 0x2522 <__divmodhi4_exit>
    2526:	90 95       	com	r25
    2528:	81 95       	neg	r24
    252a:	9f 4f       	sbci	r25, 0xFF	; 255
    252c:	08 95       	ret

0000252e <_exit>:
    252e:	f8 94       	cli

00002530 <__stop_program>:
    2530:	ff cf       	rjmp	.-2      	; 0x2530 <__stop_program>
